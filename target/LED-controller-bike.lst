
/Users/ido/projects/LED-controller-bike/target/LED-controller-bike.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .module_info  00000018  080a0000  080a0000  00010000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         00004478  080a0018  080a0018  00010018  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .backup       00000004  40024000  080a4490  00024000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  3 .data         000000ac  20000300  080a4494  00030300  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  4 .bss          00000dc0  200003ac  200003ac  000403ac  2**2
                  ALLOC
  5 .module_info_suffix 00000028  080a4540  080a4540  00034540  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  6 .module_info_crc 00000004  080a4568  080a4568  00034568  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  7 .debug_info   000e4868  00000000  00000000  0003456c  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00013fb2  00000000  00000000  00118dd4  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_loc    00023afa  00000000  00000000  0012cd86  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_aranges 00002388  00000000  00000000  00150880  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00005630  00000000  00000000  00152c08  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_macro  0002b43e  00000000  00000000  00158238  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_line   00030acd  00000000  00000000  00183676  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_str    0009fe97  00000000  00000000  001b4143  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_frame  0000c764  00000000  00000000  00253fdc  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

080a0018 <user_part_module>:
 80a0018:	8c 3d 0a 08                                         .=..

080a001c <module_user_pre_init>:
/**
 * Initializes this user module. Returns the start of the heap.
 */
void* module_user_pre_init() {

    if ( (&link_global_data_start!=&link_global_data_initial_values) && (link_global_data_size != 0))
 80a001c:	4809      	ldr	r0, [pc, #36]	; (80a0044 <module_user_pre_init+0x28>)
 80a001e:	490a      	ldr	r1, [pc, #40]	; (80a0048 <module_user_pre_init+0x2c>)
extern constructor_ptr_t link_constructors_end;

/**
 * Initializes this user module. Returns the start of the heap.
 */
void* module_user_pre_init() {
 80a0020:	b508      	push	{r3, lr}

    if ( (&link_global_data_start!=&link_global_data_initial_values) && (link_global_data_size != 0))
 80a0022:	4288      	cmp	r0, r1
 80a0024:	d005      	beq.n	80a0032 <module_user_pre_init+0x16>
 80a0026:	4a09      	ldr	r2, [pc, #36]	; (80a004c <module_user_pre_init+0x30>)
 80a0028:	4282      	cmp	r2, r0
 80a002a:	d002      	beq.n	80a0032 <module_user_pre_init+0x16>
    {
        memcpy(&link_global_data_start, &link_global_data_initial_values, link_global_data_size);
 80a002c:	1a12      	subs	r2, r2, r0
 80a002e:	f003 fd11 	bl	80a3a54 <memcpy>
    }

    memset(&link_bss_location, 0, link_bss_size );
 80a0032:	4807      	ldr	r0, [pc, #28]	; (80a0050 <module_user_pre_init+0x34>)
 80a0034:	4a07      	ldr	r2, [pc, #28]	; (80a0054 <module_user_pre_init+0x38>)
 80a0036:	2100      	movs	r1, #0
 80a0038:	1a12      	subs	r2, r2, r0
 80a003a:	f003 fd16 	bl	80a3a6a <memset>
    return &link_heap_start;
}
 80a003e:	4806      	ldr	r0, [pc, #24]	; (80a0058 <module_user_pre_init+0x3c>)
 80a0040:	bd08      	pop	{r3, pc}
 80a0042:	bf00      	nop
 80a0044:	20000300 	.word	0x20000300
 80a0048:	080a4494 	.word	0x080a4494
 80a004c:	200003ac 	.word	0x200003ac
 80a0050:	200003ac 	.word	0x200003ac
 80a0054:	2000116c 	.word	0x2000116c
 80a0058:	2000116c 	.word	0x2000116c

080a005c <module_user_init>:
extern constructor_ptr_t link_constructors_location[];
extern constructor_ptr_t link_constructors_end;
#define link_constructors_size   ((unsigned long)&link_constructors_end  -  (unsigned long)&link_constructors_location )

void module_user_init()
{
 80a005c:	b570      	push	{r4, r5, r6, lr}
    module_user_init_hook();
 80a005e:	f002 ffb9 	bl	80a2fd4 <module_user_init_hook>
 80a0062:	4b07      	ldr	r3, [pc, #28]	; (80a0080 <module_user_init+0x24>)
 80a0064:	4c07      	ldr	r4, [pc, #28]	; (80a0084 <module_user_init+0x28>)
 80a0066:	461e      	mov	r6, r3
 80a0068:	1ae4      	subs	r4, r4, r3
 80a006a:	08a4      	lsrs	r4, r4, #2

    // invoke constructors
    int ctor_num;
    for (ctor_num=0; ctor_num < link_constructors_size/sizeof(constructor_ptr_t); ctor_num++ )
 80a006c:	2500      	movs	r5, #0
 80a006e:	42a5      	cmp	r5, r4
 80a0070:	d004      	beq.n	80a007c <module_user_init+0x20>
    {
        link_constructors_location[ctor_num]();
 80a0072:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
 80a0076:	4798      	blx	r3
{
    module_user_init_hook();

    // invoke constructors
    int ctor_num;
    for (ctor_num=0; ctor_num < link_constructors_size/sizeof(constructor_ptr_t); ctor_num++ )
 80a0078:	3501      	adds	r5, #1
 80a007a:	e7f8      	b.n	80a006e <module_user_init+0x12>
    {
        link_constructors_location[ctor_num]();
    }
}
 80a007c:	bd70      	pop	{r4, r5, r6, pc}
 80a007e:	bf00      	nop
 80a0080:	080a4438 	.word	0x080a4438
 80a0084:	080a4488 	.word	0x080a4488

080a0088 <module_user_setup>:

/**
 * Export these functions with a fuller name so they don't clash with the setup/loop wrappers in the system module.
 */
void module_user_setup() {
    setup();
 80a0088:	f001 b912 	b.w	80a12b0 <setup>

080a008c <module_user_loop>:
}

void module_user_loop() {
 80a008c:	b508      	push	{r3, lr}
    loop();
 80a008e:	f000 fcc1 	bl	80a0a14 <loop>
    _post_loop();
}
 80a0092:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    setup();
}

void module_user_loop() {
    loop();
    _post_loop();
 80a0096:	f002 bf5f 	b.w	80a2f58 <_post_loop>

080a009a <_ZdlPv>:
 80a009a:	f002 ba6d 	b.w	80a2578 <free>

080a009e <__cxa_guard_acquire>:

/* Provide default implemenation for __cxa_guard_acquire() and
 * __cxa_guard_release(). Note: these must be revisited if a multitasking
 * OS is ported to this platform. */
__extension__ typedef int __guard __attribute__((mode (__DI__)));
int __cxa_guard_acquire(__guard *g) {return !*(char *)(g);};
 80a009e:	7800      	ldrb	r0, [r0, #0]
 80a00a0:	fab0 f080 	clz	r0, r0
 80a00a4:	0940      	lsrs	r0, r0, #5
 80a00a6:	4770      	bx	lr

080a00a8 <__cxa_guard_release>:
void __cxa_guard_release (__guard *g) {*(char *)g = 1;};
 80a00a8:	2301      	movs	r3, #1
 80a00aa:	7003      	strb	r3, [r0, #0]
 80a00ac:	4770      	bx	lr

080a00ae <_ZN10CloudClass22update_string_variableEPKc18Spark_Data_TypeDefPKvPv>:

    static const void* update_string_variable(const char* name, Spark_Data_TypeDef type, const void* var, void* reserved)
    {
        const String* s = (const String*)var;
        return s->c_str();
    }
 80a00ae:	6810      	ldr	r0, [r2, #0]
 80a00b0:	4770      	bx	lr
	...

080a00b4 <_ZN9NSFastLEDL7random8Ev>:
extern uint16_t rand16seed;// = RAND16_SEED;


LIB8STATIC uint8_t random8()
{
    rand16seed = (rand16seed * RAND16_2053) + RAND16_13849;
 80a00b4:	4a07      	ldr	r2, [pc, #28]	; (80a00d4 <_ZN9NSFastLEDL7random8Ev+0x20>)
 80a00b6:	8813      	ldrh	r3, [r2, #0]
 80a00b8:	eb03 2043 	add.w	r0, r3, r3, lsl #9
 80a00bc:	eb03 0080 	add.w	r0, r3, r0, lsl #2
 80a00c0:	f500 5058 	add.w	r0, r0, #13824	; 0x3600
 80a00c4:	3019      	adds	r0, #25
 80a00c6:	b280      	uxth	r0, r0
 80a00c8:	8010      	strh	r0, [r2, #0]
    // return the sum of the high and low bytes, for better
    //  mixing and non-sequential correlation
    return (uint8_t)(((uint8_t)(rand16seed & 0xFF)) +
                     ((uint8_t)(rand16seed >> 8)));
 80a00ca:	eb00 2010 	add.w	r0, r0, r0, lsr #8
}
 80a00ce:	b2c0      	uxtb	r0, r0
 80a00d0:	4770      	bx	lr
 80a00d2:	bf00      	nop
 80a00d4:	2000033c 	.word	0x2000033c

080a00d8 <_ZN9NSFastLEDL7sin16_CEt>:
    static const uint16_t base[] =
    { 0, 6393, 12539, 18204, 23170, 27245, 30273, 32137 };
    static const uint8_t slope[] =
    { 49, 48, 44, 38, 31, 23, 14, 4 };

    uint16_t offset = (theta & 0x3FFF) >> 3; // 0..2047
 80a00d8:	f3c0 03ca 	ubfx	r3, r0, #3, #11
    if( theta & 0x4000 ) offset = 2047 - offset;
 80a00dc:	0441      	lsls	r1, r0, #17
 80a00de:	bf42      	ittt	mi
 80a00e0:	f5c3 63ff 	rsbmi	r3, r3, #2040	; 0x7f8
 80a00e4:	3307      	addmi	r3, #7
 80a00e6:	b29b      	uxthmi	r3, r3

    uint8_t section = offset / 256; // 0..7
    uint16_t b   = base[section];
    uint8_t  m   = slope[section];
 80a00e8:	4a08      	ldr	r2, [pc, #32]	; (80a010c <_ZN9NSFastLEDL7sin16_CEt+0x34>)

    uint16_t offset = (theta & 0x3FFF) >> 3; // 0..2047
    if( theta & 0x4000 ) offset = 2047 - offset;

    uint8_t section = offset / 256; // 0..7
    uint16_t b   = base[section];
 80a00ea:	0a19      	lsrs	r1, r3, #8

    return y;
}

LIB8STATIC int16_t sin16_C( uint16_t theta )
{
 80a00ec:	b510      	push	{r4, lr}
    uint8_t  m   = slope[section];

    uint8_t secoffset8 = (uint8_t)(offset) / 2;

    uint16_t mx = m * secoffset8;
    int16_t  y  = mx + b;
 80a00ee:	5c54      	ldrb	r4, [r2, r1]
 80a00f0:	f3c3 0246 	ubfx	r2, r3, #1, #7

    uint16_t offset = (theta & 0x3FFF) >> 3; // 0..2047
    if( theta & 0x4000 ) offset = 2047 - offset;

    uint8_t section = offset / 256; // 0..7
    uint16_t b   = base[section];
 80a00f4:	4b06      	ldr	r3, [pc, #24]	; (80a0110 <_ZN9NSFastLEDL7sin16_CEt+0x38>)
    uint8_t  m   = slope[section];

    uint8_t secoffset8 = (uint8_t)(offset) / 2;

    uint16_t mx = m * secoffset8;
    int16_t  y  = mx + b;
 80a00f6:	f833 3011 	ldrh.w	r3, [r3, r1, lsl #1]
 80a00fa:	fb04 3302 	mla	r3, r4, r2, r3

    if( theta & 0x8000 ) y = -y;
 80a00fe:	0402      	lsls	r2, r0, #16
    uint8_t  m   = slope[section];

    uint8_t secoffset8 = (uint8_t)(offset) / 2;

    uint16_t mx = m * secoffset8;
    int16_t  y  = mx + b;
 80a0100:	b29b      	uxth	r3, r3
 80a0102:	bf52      	itee	pl
 80a0104:	b218      	sxthpl	r0, r3

    if( theta & 0x8000 ) y = -y;
 80a0106:	4258      	negmi	r0, r3
 80a0108:	b200      	sxthmi	r0, r0

    return y;
}
 80a010a:	bd10      	pop	{r4, pc}
 80a010c:	080a3db8 	.word	0x080a3db8
 80a0110:	080a3ef0 	.word	0x080a3ef0

080a0114 <_ZN9NSFastLEDL6sin8_CEh>:
    return y;
}


LIB8STATIC uint8_t sin8_C( uint8_t theta)
{
 80a0114:	f000 0340 	and.w	r3, r0, #64	; 0x40
 80a0118:	b510      	push	{r4, lr}
    uint8_t offset = theta;
    if( theta & 0x40 ) {
 80a011a:	f003 01ff 	and.w	r1, r3, #255	; 0xff
 80a011e:	b113      	cbz	r3, 80a0126 <_ZN9NSFastLEDL6sin8_CEh+0x12>
        offset = (uint8_t)255 - offset;
 80a0120:	43c3      	mvns	r3, r0
 80a0122:	b2db      	uxtb	r3, r3
 80a0124:	e000      	b.n	80a0128 <_ZN9NSFastLEDL6sin8_CEh+0x14>
 80a0126:	4603      	mov	r3, r0
    }
    offset &= 0x3F; // 0..63
 80a0128:	f003 023f 	and.w	r2, r3, #63	; 0x3f

    uint8_t secoffset  = offset & 0x0F; // 0..15
 80a012c:	f003 030f 	and.w	r3, r3, #15
    if( theta & 0x40) secoffset++;
 80a0130:	b101      	cbz	r1, 80a0134 <_ZN9NSFastLEDL6sin8_CEh+0x20>
 80a0132:	3301      	adds	r3, #1

    uint8_t section = offset >> 4; // 0..3
    uint8_t s2 = section * 2;
    const uint8_t* p = b_m16_interleave;
    p += s2;
 80a0134:	4908      	ldr	r1, [pc, #32]	; (80a0158 <_ZN9NSFastLEDL6sin8_CEh+0x44>)
 80a0136:	1112      	asrs	r2, r2, #4
 80a0138:	0052      	lsls	r2, r2, #1
 80a013a:	188c      	adds	r4, r1, r2
    p++;
    uint8_t m16 =  *p;

    uint8_t mx = (m16 * secoffset) >> 4;

    int8_t y = mx + b;
 80a013c:	7864      	ldrb	r4, [r4, #1]
 80a013e:	5c8a      	ldrb	r2, [r1, r2]
 80a0140:	4363      	muls	r3, r4
 80a0142:	eb02 1323 	add.w	r3, r2, r3, asr #4
 80a0146:	b2db      	uxtb	r3, r3
    if( theta & 0x80 ) y = -y;
 80a0148:	0602      	lsls	r2, r0, #24
 80a014a:	bf4a      	itet	mi
 80a014c:	4258      	negmi	r0, r3
    p++;
    uint8_t m16 =  *p;

    uint8_t mx = (m16 * secoffset) >> 4;

    int8_t y = mx + b;
 80a014e:	b258      	sxtbpl	r0, r3
    if( theta & 0x80 ) y = -y;
 80a0150:	b240      	sxtbmi	r0, r0

    y += 128;

    return y;
 80a0152:	3880      	subs	r0, #128	; 0x80
}
 80a0154:	b2c0      	uxtb	r0, r0
 80a0156:	bd10      	pop	{r4, pc}
 80a0158:	080a3f00 	.word	0x080a3f00

080a015c <_ZN9NSFastLED19ClocklessControllerILi15ELi30ELi75ELi45ELNS_6EOrderE66ELi0ELb0ELi50EE9clearLedsEi>:
    FastPin<DATA_PIN>::setOutput();
    mPinMask = FastPin<DATA_PIN>::mask();
    mPort = FastPin<DATA_PIN>::port();
  }

  virtual void clearLeds(int nLeds) {
 80a015c:	b513      	push	{r0, r1, r4, lr}
    showColor(CRGB(0, 0, 0), nLeds, 0);
 80a015e:	6803      	ldr	r3, [r0, #0]
 80a0160:	460a      	mov	r2, r1
 80a0162:	681c      	ldr	r4, [r3, #0]
    {
    }

    // allow construction from R, G, B
    inline CRGB( uint8_t ir, uint8_t ig, uint8_t ib)  __attribute__((always_inline))
        : r(ir), g(ig), b(ib)
 80a0164:	2300      	movs	r3, #0
 80a0166:	f88d 3000 	strb.w	r3, [sp]
 80a016a:	f88d 3001 	strb.w	r3, [sp, #1]
 80a016e:	f88d 3002 	strb.w	r3, [sp, #2]
    {
    }

    // allow construction from 32-bit (really 24-bit) bit 0xRRGGBB color code
    inline CRGB( uint32_t colorcode)  __attribute__((always_inline))
    : r((colorcode >> 16) & 0xFF), g((colorcode >> 8) & 0xFF), b((colorcode >> 0) & 0xFF)
 80a0172:	f88d 3004 	strb.w	r3, [sp, #4]
 80a0176:	f88d 3005 	strb.w	r3, [sp, #5]
 80a017a:	f88d 3006 	strb.w	r3, [sp, #6]
 80a017e:	4669      	mov	r1, sp
 80a0180:	ab01      	add	r3, sp, #4
 80a0182:	47a0      	blx	r4
  }
 80a0184:	b002      	add	sp, #8
 80a0186:	bd10      	pop	{r4, pc}

080a0188 <_ZN9NSFastLED19ClocklessControllerILi15ELi30ELi75ELi45ELNS_6EOrderE66ELi0ELb0ELi50EE4initEv>:

  data_t mPinMask;
  data_ptr_t mPort;
  CMinWait<WAIT_TIME> mWait;
public:
  virtual void init() {
 80a0188:	b510      	push	{r4, lr}
 80a018a:	4604      	mov	r4, r0
    }
  }
  inline static void setInput() { /* TODO */ } // TODO: preform MUX config { _PDDR::r() &= ~_MASK; }
  #endif

  inline static void setOutput() { pinMode(PIN, OUTPUT); } // TODO: perform MUX config { _PDDR::r() |= _MASK; }
 80a018c:	2101      	movs	r1, #1
 80a018e:	200f      	movs	r0, #15
 80a0190:	f002 ff70 	bl	80a3074 <pinMode>
    FastPin<DATA_PIN>::setOutput();
    mPinMask = FastPin<DATA_PIN>::mask();
 80a0194:	2380      	movs	r3, #128	; 0x80
 80a0196:	61a3      	str	r3, [r4, #24]
    mPort = FastPin<DATA_PIN>::port();
 80a0198:	4b01      	ldr	r3, [pc, #4]	; (80a01a0 <_ZN9NSFastLED19ClocklessControllerILi15ELi30ELi75ELi45ELNS_6EOrderE66ELi0ELb0ELi50EE4initEv+0x18>)
 80a019a:	61e3      	str	r3, [r4, #28]
 80a019c:	bd10      	pop	{r4, pc}
 80a019e:	bf00      	nop
 80a01a0:	40020014 	.word	0x40020014

080a01a4 <__tcf_0>:
typedef struct { SimplePattern drawFrame;  String name; } PatternAndName;
typedef PatternAndName PatternAndNameList[];

// List of patterns to cycle through.  Each is defined as a separate function below.                                                                                                                                                                                                                    

const PatternAndNameList patterns =
 80a01a4:	b538      	push	{r3, r4, r5, lr}

#include "MeteorShower.h"

typedef uint8_t (*SimplePattern)();
typedef SimplePattern SimplePatternList[];
typedef struct { SimplePattern drawFrame;  String name; } PatternAndName;
 80a01a6:	4d06      	ldr	r5, [pc, #24]	; (80a01c0 <__tcf_0+0x1c>)
typedef PatternAndName PatternAndNameList[];

// List of patterns to cycle through.  Each is defined as a separate function below.                                                                                                                                                                                                                    

const PatternAndNameList patterns =
 80a01a8:	2400      	movs	r4, #0

#include "MeteorShower.h"

typedef uint8_t (*SimplePattern)();
typedef SimplePattern SimplePatternList[];
typedef struct { SimplePattern drawFrame;  String name; } PatternAndName;
 80a01aa:	f104 00a4 	add.w	r0, r4, #164	; 0xa4
 80a01ae:	4428      	add	r0, r5
 80a01b0:	3c14      	subs	r4, #20
 80a01b2:	f002 fb56 	bl	80a2862 <_ZN6StringD1Ev>
typedef PatternAndName PatternAndNameList[];

// List of patterns to cycle through.  Each is defined as a separate function below.                                                                                                                                                                                                                    

const PatternAndNameList patterns =
 80a01b6:	f114 0fb4 	cmn.w	r4, #180	; 0xb4
 80a01ba:	d1f6      	bne.n	80a01aa <__tcf_0+0x6>
 80a01bc:	bd38      	pop	{r3, r4, r5, pc}
 80a01be:	bf00      	nop
 80a01c0:	20000858 	.word	0x20000858

080a01c4 <_Z7rainbowv>:
}

// Patterns from FastLED example DemoReel100: https://github.com/FastLED/FastLED/blob/master/examples/DemoReel100/DemoReel100.ino

uint8_t rainbow()
{
 80a01c4:	b508      	push	{r3, lr}
  // FastLED's built-in rainbow generator
  fill_rainbow( leds, NUM_LEDS, gHue, 255 / NUM_LEDS);
 80a01c6:	4a04      	ldr	r2, [pc, #16]	; (80a01d8 <_Z7rainbowv+0x14>)
 80a01c8:	2301      	movs	r3, #1
 80a01ca:	7812      	ldrb	r2, [r2, #0]
 80a01cc:	2196      	movs	r1, #150	; 0x96
 80a01ce:	4803      	ldr	r0, [pc, #12]	; (80a01dc <_Z7rainbowv+0x18>)
 80a01d0:	f001 fe1d 	bl	80a1e0e <_ZN9NSFastLED12fill_rainbowEPNS_4CRGBEihh>
  return 8;
}
 80a01d4:	2008      	movs	r0, #8
 80a01d6:	bd08      	pop	{r3, pc}
 80a01d8:	200005a9 	.word	0x200005a9
 80a01dc:	200005b7 	.word	0x200005b7

080a01e0 <_ZN11EEPROMClass4readEi.isra.2>:

    EERef( const int index )
        : index( index )                 {}

    //Access/read members.
    uint8_t operator*() const            { return HAL_EEPROM_Read(index); }
 80a01e0:	f002 b882 	b.w	80a22e8 <HAL_EEPROM_Read>

080a01e4 <_ZN11EEPROMClass5writeEih.isra.3>:
    operator const uint8_t() const       { return **this; }

    //Assignment/write members.
    EERef &operator=( const EERef &ref ) { return *this = *ref; }
    EERef &operator=( uint8_t in )       { return HAL_EEPROM_Write(index, in), *this;  }
 80a01e4:	f002 b888 	b.w	80a22f8 <HAL_EEPROM_Write>

080a01e8 <_Z15setPatternIndex6String>:

    return c;
}

int setPatternIndex(String args)
{
 80a01e8:	b510      	push	{r4, lr}
    patternIndex = args.toInt();
 80a01ea:	f002 fc6e 	bl	80a2aca <_ZNK6String5toIntEv>
 80a01ee:	4c0a      	ldr	r4, [pc, #40]	; (80a0218 <_Z15setPatternIndex6String+0x30>)
    if(patternIndex < 0)
 80a01f0:	2800      	cmp	r0, #0
    return c;
}

int setPatternIndex(String args)
{
    patternIndex = args.toInt();
 80a01f2:	6020      	str	r0, [r4, #0]
    if(patternIndex < 0)
 80a01f4:	da01      	bge.n	80a01fa <_Z15setPatternIndex6String+0x12>
        patternIndex = 0;
 80a01f6:	2300      	movs	r3, #0
 80a01f8:	e004      	b.n	80a0204 <_Z15setPatternIndex6String+0x1c>
    else if (patternIndex >= patternCount)
 80a01fa:	4b08      	ldr	r3, [pc, #32]	; (80a021c <_Z15setPatternIndex6String+0x34>)
 80a01fc:	681b      	ldr	r3, [r3, #0]
 80a01fe:	4298      	cmp	r0, r3
 80a0200:	db01      	blt.n	80a0206 <_Z15setPatternIndex6String+0x1e>
        patternIndex = patternCount - 1;
 80a0202:	3b01      	subs	r3, #1
 80a0204:	6023      	str	r3, [r4, #0]

    EEPROM.write(1, patternIndex);
 80a0206:	f002 ff59 	bl	80a30bc <_Z21__fetch_global_EEPROMv>
 80a020a:	7821      	ldrb	r1, [r4, #0]
 80a020c:	2001      	movs	r0, #1
 80a020e:	f7ff ffe9 	bl	80a01e4 <_ZN11EEPROMClass5writeEih.isra.3>

    return patternIndex;
}
 80a0212:	6820      	ldr	r0, [r4, #0]
 80a0214:	bd10      	pop	{r4, pc}
 80a0216:	bf00      	nop
 80a0218:	20000790 	.word	0x20000790
 80a021c:	20000338 	.word	0x20000338

080a0220 <_Z3bpmv>:
  leds[pos] += CHSV( gHue, 255, 192);
  return 8;
}

uint8_t bpm()
{
 80a0220:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
#endif

#include "timer_hal.h"
#include "delay_hal.h"

inline system_tick_t millis(void) { return HAL_Timer_Get_Milli_Seconds(); }
 80a0224:	f002 f850 	bl	80a22c8 <HAL_Timer_Get_Milli_Seconds>
//           that oscillates within a given range.
LIB8STATIC uint8_t beatsin8( accum88 beats_per_minute, uint8_t lowest = 0, uint8_t highest = 255,
                            uint32_t timebase = 0, uint8_t phase_offset = 0)
{
    uint8_t beat = beat8( beats_per_minute, timebase);
    uint8_t beatsin = sin8( beat + phase_offset);
 80a0228:	4b18      	ldr	r3, [pc, #96]	; (80a028c <_Z3bpmv+0x6c>)
    uint8_t rangewidth = highest - lowest;
    uint8_t scaledbeat = scale8( beatsin, rangewidth);
    uint8_t result = lowest + scaledbeat;
 80a022a:	2600      	movs	r6, #0
//           that oscillates within a given range.
LIB8STATIC uint8_t beatsin8( accum88 beats_per_minute, uint8_t lowest = 0, uint8_t highest = 255,
                            uint32_t timebase = 0, uint8_t phase_offset = 0)
{
    uint8_t beat = beat8( beats_per_minute, timebase);
    uint8_t beatsin = sin8( beat + phase_offset);
 80a022c:	4358      	muls	r0, r3
 80a022e:	0e00      	lsrs	r0, r0, #24
 80a0230:	f7ff ff70 	bl	80a0114 <_ZN9NSFastLEDL6sin8_CEh>
    uint8_t rangewidth = highest - lowest;
    uint8_t scaledbeat = scale8( beatsin, rangewidth);
    uint8_t result = lowest + scaledbeat;
 80a0234:	4635      	mov	r5, r6
 80a0236:	24bf      	movs	r4, #191	; 0xbf
 80a0238:	4360      	muls	r0, r4
 80a023a:	1204      	asrs	r4, r0, #8
 80a023c:	3440      	adds	r4, #64	; 0x40
  // colored stripes pulsing at a defined Beats-Per-Minute (BPM)
  uint8_t BeatsPerMinute = 62;
  uint8_t beat = beatsin8( BeatsPerMinute, 64, 255);
  for( int i = 0; i < NUM_LEDS; i++) { //9948
    leds[i] = ColorFromPalette(currentPalette, gHue+(i*2), beat-gHue+(i*10));
 80a023e:	f8df 8058 	ldr.w	r8, [pc, #88]	; 80a0298 <_Z3bpmv+0x78>
    }

    // allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
 80a0242:	4f13      	ldr	r7, [pc, #76]	; (80a0290 <_Z3bpmv+0x70>)
 80a0244:	b2e4      	uxtb	r4, r4
 80a0246:	f898 2000 	ldrb.w	r2, [r8]
 80a024a:	eb05 0385 	add.w	r3, r5, r5, lsl #2
 80a024e:	1aa1      	subs	r1, r4, r2
 80a0250:	440b      	add	r3, r1
 80a0252:	442a      	add	r2, r5
 80a0254:	2101      	movs	r1, #1
 80a0256:	9100      	str	r1, [sp, #0]
 80a0258:	b2db      	uxtb	r3, r3
 80a025a:	b2d2      	uxtb	r2, r2
 80a025c:	490d      	ldr	r1, [pc, #52]	; (80a0294 <_Z3bpmv+0x74>)
 80a025e:	a803      	add	r0, sp, #12
 80a0260:	f001 fece 	bl	80a2000 <_ZN9NSFastLED16ColorFromPaletteERKNS_13CRGBPalette16EhhNS_10TBlendTypeE>
 80a0264:	f89d 300c 	ldrb.w	r3, [sp, #12]
        g = rhs.g;
 80a0268:	f89d 200d 	ldrb.w	r2, [sp, #13]
    }

    // allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
 80a026c:	55f3      	strb	r3, [r6, r7]
 80a026e:	19bb      	adds	r3, r7, r6
        g = rhs.g;
 80a0270:	705a      	strb	r2, [r3, #1]
 80a0272:	3603      	adds	r6, #3
        b = rhs.b;
 80a0274:	f89d 200e 	ldrb.w	r2, [sp, #14]
 80a0278:	3502      	adds	r5, #2
uint8_t bpm()
{
  // colored stripes pulsing at a defined Beats-Per-Minute (BPM)
  uint8_t BeatsPerMinute = 62;
  uint8_t beat = beatsin8( BeatsPerMinute, 64, 255);
  for( int i = 0; i < NUM_LEDS; i++) { //9948
 80a027a:	f5b6 7fe1 	cmp.w	r6, #450	; 0x1c2
 80a027e:	709a      	strb	r2, [r3, #2]
 80a0280:	b2ed      	uxtb	r5, r5
 80a0282:	d1e0      	bne.n	80a0246 <_Z3bpmv+0x26>
    leds[i] = ColorFromPalette(currentPalette, gHue+(i*2), beat-gHue+(i*10));
  }

  return 8;
}
 80a0284:	2008      	movs	r0, #8
 80a0286:	b004      	add	sp, #16
 80a0288:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80a028c:	0043d000 	.word	0x0043d000
 80a0290:	200005b7 	.word	0x200005b7
 80a0294:	20000942 	.word	0x20000942
 80a0298:	200005a9 	.word	0x200005a9

080a029c <_Z12meteorShowerv>:
  else { r = NUM_LEDS - 1; }
  return r;
}

uint8_t meteorShower()
{
 80a029c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
  static byte colorTIP = 0;
  static byte meteorLENGTH;
  static byte loopCount = 1;    //low number loop counter

  //hue master
  hue++;
 80a029e:	4c9b      	ldr	r4, [pc, #620]	; (80a050c <_Z12meteorShowerv+0x270>)

  //populate the leds[] with stored ledsX[] array data
  for(byte i = 0; i < NUM_LEDS; i++ ) {
    ledsX[i][0] = leds[i].r;
 80a02a0:	4e9b      	ldr	r6, [pc, #620]	; (80a0510 <_Z12meteorShowerv+0x274>)
  static byte colorTIP = 0;
  static byte meteorLENGTH;
  static byte loopCount = 1;    //low number loop counter

  //hue master
  hue++;
 80a02a2:	7822      	ldrb	r2, [r4, #0]

  //populate the leds[] with stored ledsX[] array data
  for(byte i = 0; i < NUM_LEDS; i++ ) {
    ledsX[i][0] = leds[i].r;
 80a02a4:	4f9b      	ldr	r7, [pc, #620]	; (80a0514 <_Z12meteorShowerv+0x278>)
  static byte colorTIP = 0;
  static byte meteorLENGTH;
  static byte loopCount = 1;    //low number loop counter

  //hue master
  hue++;
 80a02a6:	1c53      	adds	r3, r2, #1
 80a02a8:	7023      	strb	r3, [r4, #0]
 80a02aa:	2300      	movs	r3, #0

  //populate the leds[] with stored ledsX[] array data
  for(byte i = 0; i < NUM_LEDS; i++ ) {
    ledsX[i][0] = leds[i].r;
 80a02ac:	5dd9      	ldrb	r1, [r3, r7]
 80a02ae:	18f8      	adds	r0, r7, r3
 80a02b0:	5599      	strb	r1, [r3, r6]
    ledsX[i][1] = leds[i].g;
 80a02b2:	7845      	ldrb	r5, [r0, #1]
 80a02b4:	18f1      	adds	r1, r6, r3
    ledsX[i][2] = leds[i].b;
 80a02b6:	7880      	ldrb	r0, [r0, #2]
 80a02b8:	3303      	adds	r3, #3

  //hue master
  hue++;

  //populate the leds[] with stored ledsX[] array data
  for(byte i = 0; i < NUM_LEDS; i++ ) {
 80a02ba:	f5b3 7fe1 	cmp.w	r3, #450	; 0x1c2
    ledsX[i][0] = leds[i].r;
    ledsX[i][1] = leds[i].g;
 80a02be:	704d      	strb	r5, [r1, #1]
    ledsX[i][2] = leds[i].b;
 80a02c0:	7088      	strb	r0, [r1, #2]
 80a02c2:	4d93      	ldr	r5, [pc, #588]	; (80a0510 <_Z12meteorShowerv+0x274>)
 80a02c4:	4993      	ldr	r1, [pc, #588]	; (80a0514 <_Z12meteorShowerv+0x278>)

  //hue master
  hue++;

  //populate the leds[] with stored ledsX[] array data
  for(byte i = 0; i < NUM_LEDS; i++ ) {
 80a02c6:	d1f1      	bne.n	80a02ac <_Z12meteorShowerv+0x10>
  }
  //clear the previous counter clockwise position
  byte iCCW;

  //we are keeping track of elapsed time
  timeframe++;    //fx timer
 80a02c8:	4e93      	ldr	r6, [pc, #588]	; (80a0518 <_Z12meteorShowerv+0x27c>)
 80a02ca:	8833      	ldrh	r3, [r6, #0]
 80a02cc:	1c58      	adds	r0, r3, #1

  //meteorLENGTH fx is only shown for this time frame
  if((timeframe >= 1) && (timeframe <= 280)) { meteorLENGTH = 29; }
 80a02ce:	f5b3 7f8c 	cmp.w	r3, #280	; 0x118
  }
  //clear the previous counter clockwise position
  byte iCCW;

  //we are keeping track of elapsed time
  timeframe++;    //fx timer
 80a02d2:	8030      	strh	r0, [r6, #0]

  //meteorLENGTH fx is only shown for this time frame
  if((timeframe >= 1) && (timeframe <= 280)) { meteorLENGTH = 29; }
 80a02d4:	bf3e      	ittt	cc
 80a02d6:	4891      	ldrcc	r0, [pc, #580]	; (80a051c <_Z12meteorShowerv+0x280>)
 80a02d8:	271d      	movcc	r7, #29
 80a02da:	7007      	strbcc	r7, [r0, #0]
  if((timeframe > 280) && (timeframe <= 500)) { meteorLENGTH = 45; }
 80a02dc:	f5a3 708c 	sub.w	r0, r3, #280	; 0x118
 80a02e0:	28db      	cmp	r0, #219	; 0xdb
 80a02e2:	488f      	ldr	r0, [pc, #572]	; (80a0520 <_Z12meteorShowerv+0x284>)
 80a02e4:	d805      	bhi.n	80a02f2 <_Z12meteorShowerv+0x56>
 80a02e6:	4f8d      	ldr	r7, [pc, #564]	; (80a051c <_Z12meteorShowerv+0x280>)
 80a02e8:	f04f 0e2d 	mov.w	lr, #45	; 0x2d
 80a02ec:	f887 e000 	strb.w	lr, [r7]
 80a02f0:	e004      	b.n	80a02fc <_Z12meteorShowerv+0x60>

  //RAINBOWs fx add rainbow tails during this time frame only
  if((timeframe > 0) && (timeframe <= 280)) { RAINBOWs = true; }
 80a02f2:	f5b3 7f8c 	cmp.w	r3, #280	; 0x118
 80a02f6:	d201      	bcs.n	80a02fc <_Z12meteorShowerv+0x60>
 80a02f8:	2701      	movs	r7, #1
 80a02fa:	e000      	b.n	80a02fe <_Z12meteorShowerv+0x62>
  else{ RAINBOWs = false; }
 80a02fc:	2700      	movs	r7, #0
 80a02fe:	7007      	strb	r7, [r0, #0]
  //keep our RAINBOWs within a specific range of hue
  if(RAINBOWs == true){ hue = hue - 20; if(hue <= 0){  hue = 1; } }
 80a0300:	7800      	ldrb	r0, [r0, #0]
 80a0302:	b128      	cbz	r0, 80a0310 <_Z12meteorShowerv+0x74>
 80a0304:	3a13      	subs	r2, #19
 80a0306:	f012 02ff 	ands.w	r2, r2, #255	; 0xff
 80a030a:	bf08      	it	eq
 80a030c:	2201      	moveq	r2, #1
 80a030e:	7022      	strb	r2, [r4, #0]

  //RANDOMpick fx is only enabled during this timeframe
  if((timeframe > 600) && (timeframe <= 790)) { RANDOMpick = true; }
 80a0310:	f5a3 7316 	sub.w	r3, r3, #600	; 0x258
 80a0314:	2bbd      	cmp	r3, #189	; 0xbd
 80a0316:	4b83      	ldr	r3, [pc, #524]	; (80a0524 <_Z12meteorShowerv+0x288>)
 80a0318:	bf94      	ite	ls
 80a031a:	2201      	movls	r2, #1
  else{ RANDOMpick = false; }
 80a031c:	2200      	movhi	r2, #0
 80a031e:	701a      	strb	r2, [r3, #0]

  //pick a random spot in the meteor switch case statement below
  if (RANDOMpick == true){ idex = random8(46); }
 80a0320:	781a      	ldrb	r2, [r3, #0]
 80a0322:	4f81      	ldr	r7, [pc, #516]	; (80a0528 <_Z12meteorShowerv+0x28c>)
 80a0324:	b132      	cbz	r2, 80a0334 <_Z12meteorShowerv+0x98>
}


LIB8STATIC uint8_t random8(uint8_t lim)
{
    uint8_t r = random8();
 80a0326:	f7ff fec5 	bl	80a00b4 <_ZN9NSFastLEDL7random8Ev>
 80a032a:	232e      	movs	r3, #46	; 0x2e
 80a032c:	4358      	muls	r0, r3
 80a032e:	1200      	asrs	r0, r0, #8
 80a0330:	7038      	strb	r0, [r7, #0]
 80a0332:	e008      	b.n	80a0346 <_Z12meteorShowerv+0xaa>
  else{
    //increment the meteor display frame
    idex++;
 80a0334:	783b      	ldrb	r3, [r7, #0]
    //make sure we don't drift into space
    if (idex > meteorLENGTH) { idex = 0; } }
 80a0336:	4879      	ldr	r0, [pc, #484]	; (80a051c <_Z12meteorShowerv+0x280>)

  //pick a random spot in the meteor switch case statement below
  if (RANDOMpick == true){ idex = random8(46); }
  else{
    //increment the meteor display frame
    idex++;
 80a0338:	3301      	adds	r3, #1
    //make sure we don't drift into space
    if (idex > meteorLENGTH) { idex = 0; } }
 80a033a:	7800      	ldrb	r0, [r0, #0]

  //pick a random spot in the meteor switch case statement below
  if (RANDOMpick == true){ idex = random8(46); }
  else{
    //increment the meteor display frame
    idex++;
 80a033c:	b2db      	uxtb	r3, r3
    //make sure we don't drift into space
    if (idex > meteorLENGTH) { idex = 0; } }
 80a033e:	4298      	cmp	r0, r3

  //pick a random spot in the meteor switch case statement below
  if (RANDOMpick == true){ idex = random8(46); }
  else{
    //increment the meteor display frame
    idex++;
 80a0340:	703b      	strb	r3, [r7, #0]
    //make sure we don't drift into space
    if (idex > meteorLENGTH) { idex = 0; } }
 80a0342:	bf38      	it	cc
 80a0344:	703a      	strbcc	r2, [r7, #0]

  //meteorLENGTH is randomized during this timeframe only
  if((timeframe > 790) && (timeframe <= 1090)) { meteorLENGTH = random8(7, 38); }
 80a0346:	8833      	ldrh	r3, [r6, #0]
 80a0348:	4e78      	ldr	r6, [pc, #480]	; (80a052c <_Z12meteorShowerv+0x290>)
 80a034a:	f2a3 3217 	subw	r2, r3, #791	; 0x317
 80a034e:	f5b2 7f96 	cmp.w	r2, #300	; 0x12c
 80a0352:	d208      	bcs.n	80a0366 <_Z12meteorShowerv+0xca>
 80a0354:	f7ff feae 	bl	80a00b4 <_ZN9NSFastLEDL7random8Ev>
 80a0358:	ebc0 1040 	rsb	r0, r0, r0, lsl #5
 80a035c:	1200      	asrs	r0, r0, #8
 80a035e:	4b6f      	ldr	r3, [pc, #444]	; (80a051c <_Z12meteorShowerv+0x280>)
 80a0360:	3007      	adds	r0, #7
 80a0362:	7018      	strb	r0, [r3, #0]
 80a0364:	e009      	b.n	80a037a <_Z12meteorShowerv+0xde>

  //during this point in the animation timeframe
  if(timeframe == 1180) {
 80a0366:	f240 429c 	movw	r2, #1180	; 0x49c
 80a036a:	4293      	cmp	r3, r2
 80a036c:	d105      	bne.n	80a037a <_Z12meteorShowerv+0xde>
    //reset the timeframe
    timeframe = 0;
 80a036e:	4b6a      	ldr	r3, [pc, #424]	; (80a0518 <_Z12meteorShowerv+0x27c>)
 80a0370:	2200      	movs	r2, #0
 80a0372:	801a      	strh	r2, [r3, #0]
    //increment the loop counter
    loopCount++;
 80a0374:	7833      	ldrb	r3, [r6, #0]
 80a0376:	3301      	adds	r3, #1
 80a0378:	7033      	strb	r3, [r6, #0]
  }

  //during this part of the loopCount, all meteors have a white colored tip
  if(loopCount == 1) { colorTIP = 0; }
 80a037a:	7833      	ldrb	r3, [r6, #0]
 80a037c:	2b01      	cmp	r3, #1
 80a037e:	d101      	bne.n	80a0384 <_Z12meteorShowerv+0xe8>
 80a0380:	2200      	movs	r2, #0
 80a0382:	e002      	b.n	80a038a <_Z12meteorShowerv+0xee>
  if(loopCount == 2) { colorTIP = 1; }
 80a0384:	2b02      	cmp	r3, #2
 80a0386:	d103      	bne.n	80a0390 <_Z12meteorShowerv+0xf4>
 80a0388:	2201      	movs	r2, #1
 80a038a:	4b69      	ldr	r3, [pc, #420]	; (80a0530 <_Z12meteorShowerv+0x294>)
 80a038c:	701a      	strb	r2, [r3, #0]
 80a038e:	e010      	b.n	80a03b2 <_Z12meteorShowerv+0x116>
  if(loopCount == 3) { colorTIP = random8(11); }
 80a0390:	2b03      	cmp	r3, #3
 80a0392:	d107      	bne.n	80a03a4 <_Z12meteorShowerv+0x108>
 80a0394:	f7ff fe8e 	bl	80a00b4 <_ZN9NSFastLEDL7random8Ev>
 80a0398:	230b      	movs	r3, #11
 80a039a:	4358      	muls	r0, r3
 80a039c:	4b64      	ldr	r3, [pc, #400]	; (80a0530 <_Z12meteorShowerv+0x294>)
 80a039e:	1200      	asrs	r0, r0, #8
 80a03a0:	7018      	strb	r0, [r3, #0]
 80a03a2:	e006      	b.n	80a03b2 <_Z12meteorShowerv+0x116>
  //end of the desired fx, reset the variable for the next time around
  if(loopCount == 4) {
 80a03a4:	2b04      	cmp	r3, #4
 80a03a6:	d104      	bne.n	80a03b2 <_Z12meteorShowerv+0x116>
    colorTIP = 0;
 80a03a8:	4a61      	ldr	r2, [pc, #388]	; (80a0530 <_Z12meteorShowerv+0x294>)
 80a03aa:	2300      	movs	r3, #0
 80a03ac:	7013      	strb	r3, [r2, #0]
    loopCount = 0;
 80a03ae:	4a5f      	ldr	r2, [pc, #380]	; (80a052c <_Z12meteorShowerv+0x290>)
 80a03b0:	7013      	strb	r3, [r2, #0]
  }

  //there are two switch case statements nestled into one another
  //we always want to control the color of the meteor tip
  //the other controls the actual meteor animation in 45 frames/case statements
  switch (idex) {
 80a03b2:	783a      	ldrb	r2, [r7, #0]
 80a03b4:	2300      	movs	r3, #0
 80a03b6:	2a2d      	cmp	r2, #45	; 0x2d
 80a03b8:	d830      	bhi.n	80a041c <_Z12meteorShowerv+0x180>
 80a03ba:	e8df f002 	tbb	[pc, r2]
 80a03be:	5b17      	.short	0x5b17
 80a03c0:	857c736a 	.word	0x857c736a
 80a03c4:	bba0978e 	.word	0xbba0978e
 80a03c8:	2c2c2c2c 	.word	0x2c2c2c2c
 80a03cc:	2c2c2c2c 	.word	0x2c2c2c2c
 80a03d0:	2c2c2c2c 	.word	0x2c2c2c2c
 80a03d4:	2c2c2c2c 	.word	0x2c2c2c2c
 80a03d8:	2c2c2c2c 	.word	0x2c2c2c2c
 80a03dc:	2c2c2c2c 	.word	0x2c2c2c2c
 80a03e0:	2c2c2c2c 	.word	0x2c2c2c2c
 80a03e4:	2c2c2c2c 	.word	0x2c2c2c2c
 80a03e8:	2c2c2c2c 	.word	0x2c2c2c2c
  case 0:
    switch (colorTIP){
 80a03ec:	4b50      	ldr	r3, [pc, #320]	; (80a0530 <_Z12meteorShowerv+0x294>)
 80a03ee:	781a      	ldrb	r2, [r3, #0]
 80a03f0:	2300      	movs	r3, #0
 80a03f2:	2a0a      	cmp	r2, #10
 80a03f4:	d812      	bhi.n	80a041c <_Z12meteorShowerv+0x180>
 80a03f6:	e8df f002 	tbb	[pc, r2]
 80a03fa:	0d06      	.short	0x0d06
 80a03fc:	211d1916 	.word	0x211d1916
 80a0400:	322c2923 	.word	0x322c2923
 80a0404:	37          	.byte	0x37
 80a0405:	00          	.byte	0x00
    {
    }

    // allow construction from H, S, V
    inline CHSV( uint8_t ih, uint8_t is, uint8_t iv) __attribute__((always_inline))
        : h(ih), s(is), v(iv)
 80a0406:	7823      	ldrb	r3, [r4, #0]
 80a0408:	f88d 3004 	strb.w	r3, [sp, #4]
 80a040c:	23ff      	movs	r3, #255	; 0xff
 80a040e:	f88d 3005 	strb.w	r3, [sp, #5]
 80a0412:	e037      	b.n	80a0484 <_Z12meteorShowerv+0x1e8>
    }

    // allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
 80a0414:	2364      	movs	r3, #100	; 0x64
 80a0416:	700b      	strb	r3, [r1, #0]
        g = rhs.g;
 80a0418:	704b      	strb	r3, [r1, #1]
        b = rhs.b;
 80a041a:	708b      	strb	r3, [r1, #2]
 80a041c:	4a3d      	ldr	r2, [pc, #244]	; (80a0514 <_Z12meteorShowerv+0x278>)
  static byte colorTIP = 0;
  static byte meteorLENGTH;
  static byte loopCount = 1;    //low number loop counter

  //hue master
  hue++;
 80a041e:	2300      	movs	r3, #0
  case 45:
    leds[0] = CRGB::Black;
    break;
  }
  //copy the LED Array
  for(byte i = 1; i < NUM_LEDS; i++ ) {
 80a0420:	f240 10bf 	movw	r0, #447	; 0x1bf
 80a0424:	e08f      	b.n	80a0546 <_Z12meteorShowerv+0x2aa>
    }

    // allow assignment from 32-bit (really 24-bit) 0xRRGGBB color code
	inline CRGB& operator= (const uint32_t colorcode) __attribute__((always_inline))
    {
        r = (colorcode >> 16) & 0xFF;
 80a0426:	23ff      	movs	r3, #255	; 0xff
 80a0428:	700b      	strb	r3, [r1, #0]
 80a042a:	e00c      	b.n	80a0446 <_Z12meteorShowerv+0x1aa>
 80a042c:	23ee      	movs	r3, #238	; 0xee
 80a042e:	700b      	strb	r3, [r1, #0]
        g = (colorcode >>  8) & 0xFF;
 80a0430:	2282      	movs	r2, #130	; 0x82
 80a0432:	e001      	b.n	80a0438 <_Z12meteorShowerv+0x19c>
    }

    // allow assignment from 32-bit (really 24-bit) 0xRRGGBB color code
	inline CRGB& operator= (const uint32_t colorcode) __attribute__((always_inline))
    {
        r = (colorcode >> 16) & 0xFF;
 80a0434:	700b      	strb	r3, [r1, #0]
        g = (colorcode >>  8) & 0xFF;
 80a0436:	2280      	movs	r2, #128	; 0x80
 80a0438:	704a      	strb	r2, [r1, #1]
 80a043a:	e7ee      	b.n	80a041a <_Z12meteorShowerv+0x17e>
    }

    // allow assignment from 32-bit (really 24-bit) 0xRRGGBB color code
	inline CRGB& operator= (const uint32_t colorcode) __attribute__((always_inline))
    {
        r = (colorcode >> 16) & 0xFF;
 80a043c:	2280      	movs	r2, #128	; 0x80
 80a043e:	e00f      	b.n	80a0460 <_Z12meteorShowerv+0x1c4>
 80a0440:	23ff      	movs	r3, #255	; 0xff
 80a0442:	700b      	strb	r3, [r1, #0]
        g = (colorcode >>  8) & 0xFF;
 80a0444:	23a5      	movs	r3, #165	; 0xa5
 80a0446:	704b      	strb	r3, [r1, #1]
        b = (colorcode >>  0) & 0xFF;
 80a0448:	2300      	movs	r3, #0
 80a044a:	e7e6      	b.n	80a041a <_Z12meteorShowerv+0x17e>
    }

    // allow assignment from 32-bit (really 24-bit) 0xRRGGBB color code
	inline CRGB& operator= (const uint32_t colorcode) __attribute__((always_inline))
    {
        r = (colorcode >> 16) & 0xFF;
 80a044c:	700b      	strb	r3, [r1, #0]
        g = (colorcode >>  8) & 0xFF;
 80a044e:	23ff      	movs	r3, #255	; 0xff
 80a0450:	e7e2      	b.n	80a0418 <_Z12meteorShowerv+0x17c>
    }

    // allow assignment from 32-bit (really 24-bit) 0xRRGGBB color code
	inline CRGB& operator= (const uint32_t colorcode) __attribute__((always_inline))
    {
        r = (colorcode >> 16) & 0xFF;
 80a0452:	23ad      	movs	r3, #173	; 0xad
 80a0454:	700b      	strb	r3, [r1, #0]
        g = (colorcode >>  8) & 0xFF;
 80a0456:	23ff      	movs	r3, #255	; 0xff
 80a0458:	704b      	strb	r3, [r1, #1]
        b = (colorcode >>  0) & 0xFF;
 80a045a:	232f      	movs	r3, #47	; 0x2f
 80a045c:	e7dd      	b.n	80a041a <_Z12meteorShowerv+0x17e>
    }

    // allow assignment from 32-bit (really 24-bit) 0xRRGGBB color code
	inline CRGB& operator= (const uint32_t colorcode) __attribute__((always_inline))
    {
        r = (colorcode >> 16) & 0xFF;
 80a045e:	22ff      	movs	r2, #255	; 0xff
 80a0460:	700a      	strb	r2, [r1, #0]
        g = (colorcode >>  8) & 0xFF;
 80a0462:	704b      	strb	r3, [r1, #1]
        b = (colorcode >>  0) & 0xFF;
 80a0464:	708a      	strb	r2, [r1, #2]
 80a0466:	e7d9      	b.n	80a041c <_Z12meteorShowerv+0x180>
    }

    // allow assignment from 32-bit (really 24-bit) 0xRRGGBB color code
	inline CRGB& operator= (const uint32_t colorcode) __attribute__((always_inline))
    {
        r = (colorcode >> 16) & 0xFF;
 80a0468:	2387      	movs	r3, #135	; 0x87
 80a046a:	700b      	strb	r3, [r1, #0]
        g = (colorcode >>  8) & 0xFF;
 80a046c:	23ce      	movs	r3, #206	; 0xce
 80a046e:	704b      	strb	r3, [r1, #1]
        b = (colorcode >>  0) & 0xFF;
 80a0470:	23eb      	movs	r3, #235	; 0xeb
 80a0472:	e7d2      	b.n	80a041a <_Z12meteorShowerv+0x17e>
    {
    }

    // allow construction from H, S, V
    inline CHSV( uint8_t ih, uint8_t is, uint8_t iv) __attribute__((always_inline))
        : h(ih), s(is), v(iv)
 80a0474:	7823      	ldrb	r3, [r4, #0]
 80a0476:	3b14      	subs	r3, #20
 80a0478:	f88d 3004 	strb.w	r3, [sp, #4]
 80a047c:	23ff      	movs	r3, #255	; 0xff
 80a047e:	f88d 3005 	strb.w	r3, [sp, #5]
 80a0482:	23d2      	movs	r3, #210	; 0xd2
    }

    // allow assignment from HSV color
	inline CRGB& operator= (const CHSV& rhs) __attribute__((always_inline))
    {
        hsv2rgb_rainbow( rhs, *this);
 80a0484:	4923      	ldr	r1, [pc, #140]	; (80a0514 <_Z12meteorShowerv+0x278>)
 80a0486:	a801      	add	r0, sp, #4
    {
    }

    // allow construction from H, S, V
    inline CHSV( uint8_t ih, uint8_t is, uint8_t iv) __attribute__((always_inline))
        : h(ih), s(is), v(iv)
 80a0488:	f88d 3006 	strb.w	r3, [sp, #6]
    }

    // allow assignment from HSV color
	inline CRGB& operator= (const CHSV& rhs) __attribute__((always_inline))
    {
        hsv2rgb_rainbow( rhs, *this);
 80a048c:	f001 fe4a 	bl	80a2124 <_ZN9NSFastLED15hsv2rgb_rainbowERKNS_4CHSVERNS_4CRGBE>
      leds[0] = CRGB::SkyBlue;
    }
    break;
  case 1:
    leds[0] = CHSV((hue - 20), 255, 210);
    break;
 80a0490:	e7c4      	b.n	80a041c <_Z12meteorShowerv+0x180>
    {
    }

    // allow construction from H, S, V
    inline CHSV( uint8_t ih, uint8_t is, uint8_t iv) __attribute__((always_inline))
        : h(ih), s(is), v(iv)
 80a0492:	7823      	ldrb	r3, [r4, #0]
 80a0494:	3b16      	subs	r3, #22
 80a0496:	f88d 3004 	strb.w	r3, [sp, #4]
 80a049a:	23ff      	movs	r3, #255	; 0xff
 80a049c:	f88d 3005 	strb.w	r3, [sp, #5]
 80a04a0:	23b4      	movs	r3, #180	; 0xb4
 80a04a2:	e7ef      	b.n	80a0484 <_Z12meteorShowerv+0x1e8>
 80a04a4:	7823      	ldrb	r3, [r4, #0]
 80a04a6:	3b17      	subs	r3, #23
 80a04a8:	f88d 3004 	strb.w	r3, [sp, #4]
 80a04ac:	23ff      	movs	r3, #255	; 0xff
 80a04ae:	f88d 3005 	strb.w	r3, [sp, #5]
 80a04b2:	2396      	movs	r3, #150	; 0x96
 80a04b4:	e7e6      	b.n	80a0484 <_Z12meteorShowerv+0x1e8>
 80a04b6:	7823      	ldrb	r3, [r4, #0]
 80a04b8:	3b18      	subs	r3, #24
 80a04ba:	f88d 3004 	strb.w	r3, [sp, #4]
 80a04be:	23ff      	movs	r3, #255	; 0xff
 80a04c0:	f88d 3005 	strb.w	r3, [sp, #5]
 80a04c4:	236e      	movs	r3, #110	; 0x6e
 80a04c6:	e7dd      	b.n	80a0484 <_Z12meteorShowerv+0x1e8>
 80a04c8:	7823      	ldrb	r3, [r4, #0]
 80a04ca:	3b19      	subs	r3, #25
 80a04cc:	f88d 3004 	strb.w	r3, [sp, #4]
 80a04d0:	23ff      	movs	r3, #255	; 0xff
 80a04d2:	f88d 3005 	strb.w	r3, [sp, #5]
 80a04d6:	235a      	movs	r3, #90	; 0x5a
 80a04d8:	e7d4      	b.n	80a0484 <_Z12meteorShowerv+0x1e8>
 80a04da:	7823      	ldrb	r3, [r4, #0]
 80a04dc:	3b1a      	subs	r3, #26
 80a04de:	f88d 3004 	strb.w	r3, [sp, #4]
 80a04e2:	23a0      	movs	r3, #160	; 0xa0
 80a04e4:	f88d 3005 	strb.w	r3, [sp, #5]
 80a04e8:	233c      	movs	r3, #60	; 0x3c
 80a04ea:	e7cb      	b.n	80a0484 <_Z12meteorShowerv+0x1e8>
 80a04ec:	7823      	ldrb	r3, [r4, #0]
 80a04ee:	3b1b      	subs	r3, #27
 80a04f0:	f88d 3004 	strb.w	r3, [sp, #4]
 80a04f4:	238c      	movs	r3, #140	; 0x8c
 80a04f6:	f88d 3005 	strb.w	r3, [sp, #5]
 80a04fa:	2328      	movs	r3, #40	; 0x28
 80a04fc:	e7c2      	b.n	80a0484 <_Z12meteorShowerv+0x1e8>
 80a04fe:	7823      	ldrb	r3, [r4, #0]
 80a0500:	3b1c      	subs	r3, #28
 80a0502:	f88d 3004 	strb.w	r3, [sp, #4]
 80a0506:	2378      	movs	r3, #120	; 0x78
 80a0508:	e019      	b.n	80a053e <_Z12meteorShowerv+0x2a2>
 80a050a:	bf00      	nop
 80a050c:	200005a8 	.word	0x200005a8
 80a0510:	200003e0 	.word	0x200003e0
 80a0514:	200005b7 	.word	0x200005b7
 80a0518:	200007d2 	.word	0x200007d2
 80a051c:	20000854 	.word	0x20000854
 80a0520:	200007d1 	.word	0x200007d1
 80a0524:	200005b0 	.word	0x200005b0
 80a0528:	200005b6 	.word	0x200005b6
 80a052c:	20000327 	.word	0x20000327
 80a0530:	200005a2 	.word	0x200005a2
 80a0534:	7823      	ldrb	r3, [r4, #0]
 80a0536:	3b1d      	subs	r3, #29
 80a0538:	f88d 3004 	strb.w	r3, [sp, #4]
 80a053c:	2364      	movs	r3, #100	; 0x64
 80a053e:	f88d 3005 	strb.w	r3, [sp, #5]
 80a0542:	2314      	movs	r3, #20
 80a0544:	e79e      	b.n	80a0484 <_Z12meteorShowerv+0x1e8>
    break;
  }
  //copy the LED Array
  for(byte i = 1; i < NUM_LEDS; i++ ) {
    iCCW = adjacent_ccw(i);
    leds[i].r = ledsX[iCCW][0];
 80a0546:	5ce9      	ldrb	r1, [r5, r3]
 80a0548:	3203      	adds	r2, #3
 80a054a:	7011      	strb	r1, [r2, #0]
 80a054c:	18e9      	adds	r1, r5, r3
    leds[i].g = ledsX[iCCW][1];
 80a054e:	784c      	ldrb	r4, [r1, #1]
 80a0550:	3303      	adds	r3, #3
    leds[i].b = ledsX[iCCW][2];
 80a0552:	7889      	ldrb	r1, [r1, #2]
  case 45:
    leds[0] = CRGB::Black;
    break;
  }
  //copy the LED Array
  for(byte i = 1; i < NUM_LEDS; i++ ) {
 80a0554:	4283      	cmp	r3, r0
    iCCW = adjacent_ccw(i);
    leds[i].r = ledsX[iCCW][0];
    leds[i].g = ledsX[iCCW][1];
 80a0556:	7054      	strb	r4, [r2, #1]
    leds[i].b = ledsX[iCCW][2];
 80a0558:	7091      	strb	r1, [r2, #2]
  case 45:
    leds[0] = CRGB::Black;
    break;
  }
  //copy the LED Array
  for(byte i = 1; i < NUM_LEDS; i++ ) {
 80a055a:	d1f4      	bne.n	80a0546 <_Z12meteorShowerv+0x2aa>
    leds[i].g = ledsX[iCCW][1];
    leds[i].b = ledsX[iCCW][2];
  }

  return 30;
 80a055c:	201e      	movs	r0, #30
 80a055e:	b003      	add	sp, #12
 80a0560:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80a0562:	bf00      	nop

080a0564 <_Z7juggle2v>:

  return 0;
}

uint8_t juggle2()
{
 80a0564:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}

  static uint8_t dotcount = 1;
  static uint8_t dotinc = 1;
  static bool handled = false;

  for( int i = 0; i < dotcount; i++)
 80a0568:	4f42      	ldr	r7, [pc, #264]	; (80a0674 <_Z7juggle2v+0x110>)
  return 0;
}

uint8_t juggle2()
{
  fadeToBlackBy( leds, NUM_LEDS, 20);
 80a056a:	2214      	movs	r2, #20
 80a056c:	2196      	movs	r1, #150	; 0x96
 80a056e:	4842      	ldr	r0, [pc, #264]	; (80a0678 <_Z7juggle2v+0x114>)

  static uint8_t dotcount = 1;
  static uint8_t dotinc = 1;
  static bool handled = false;

  for( int i = 0; i < dotcount; i++)
 80a0570:	2600      	movs	r6, #0
  return 0;
}

uint8_t juggle2()
{
  fadeToBlackBy( leds, NUM_LEDS, 20);
 80a0572:	f001 fd43 	bl	80a1ffc <_ZN9NSFastLED13fadeToBlackByEPNS_4CRGBEth>
  byte dothue = 0;
 80a0576:	46b2      	mov	sl, r6
 80a0578:	46b9      	mov	r9, r7
    }

    // "or" operator brings each channel up to the higher of the two values
    inline CRGB& operator|= (const CRGB& rhs )
    {
        if( rhs.r > r) r = rhs.r;
 80a057a:	f8df 80fc 	ldr.w	r8, [pc, #252]	; 80a0678 <_Z7juggle2v+0x114>

  static uint8_t dotcount = 1;
  static uint8_t dotinc = 1;
  static bool handled = false;

  for( int i = 0; i < dotcount; i++)
 80a057e:	f897 b000 	ldrb.w	fp, [r7]
 80a0582:	4c3c      	ldr	r4, [pc, #240]	; (80a0674 <_Z7juggle2v+0x110>)
 80a0584:	455e      	cmp	r6, fp
 80a0586:	da45      	bge.n	80a0614 <_Z7juggle2v+0xb0>
 80a0588:	f001 fe9e 	bl	80a22c8 <HAL_Timer_Get_Milli_Seconds>
//           that oscillates within a given range.
LIB8STATIC uint8_t beatsin8( accum88 beats_per_minute, uint8_t lowest = 0, uint8_t highest = 255,
                            uint32_t timebase = 0, uint8_t phase_offset = 0)
{
    uint8_t beat = beat8( beats_per_minute, timebase);
    uint8_t beatsin = sin8( beat + phase_offset);
 80a058c:	f44f 13af 	mov.w	r3, #1433600	; 0x15e000
 80a0590:	4358      	muls	r0, r3
 80a0592:	0173      	lsls	r3, r6, #5
 80a0594:	eb03 6010 	add.w	r0, r3, r0, lsr #24
 80a0598:	b2c0      	uxtb	r0, r0
 80a059a:	f7ff fdbb 	bl	80a0114 <_ZN9NSFastLEDL6sin8_CEh>
//         In other words, it computes i * (scale / 256)
//         4 clocks AVR with MUL, 2 clocks ARM
LIB8STATIC uint8_t scale8( uint8_t i, fract8 scale)
{
#if SCALE8_C == 1
    return ((uint16_t)i * (uint16_t)(scale) ) >> 8;
 80a059e:	244b      	movs	r4, #75	; 0x4b
 80a05a0:	4360      	muls	r0, r4
  {
    uint8_t pos = beatsin8(bpm, 0, NUM_LEDS / 2, 0, i * (256 / maxdotcount));

    if(i % 2 == 0)
 80a05a2:	07f3      	lsls	r3, r6, #31
 80a05a4:	f3c0 2407 	ubfx	r4, r0, #8, #8
      pos = (NUM_LEDS - 1) - pos;
 80a05a8:	bf5c      	itt	pl
 80a05aa:	f1c4 0495 	rsbpl	r4, r4, #149	; 0x95
 80a05ae:	b2e4      	uxtbpl	r4, r4
    {
    }

    // allow construction from H, S, V
    inline CHSV( uint8_t ih, uint8_t is, uint8_t iv) __attribute__((always_inline))
        : h(ih), s(is), v(iv)
 80a05b0:	23ff      	movs	r3, #255	; 0xff
    }

    // allow construction from HSV color
	inline CRGB(const CHSV& rhs) __attribute__((always_inline))
    {
        hsv2rgb_rainbow( rhs, *this);
 80a05b2:	a901      	add	r1, sp, #4
 80a05b4:	4668      	mov	r0, sp
    {
    }

    // allow construction from H, S, V
    inline CHSV( uint8_t ih, uint8_t is, uint8_t iv) __attribute__((always_inline))
        : h(ih), s(is), v(iv)
 80a05b6:	f88d a000 	strb.w	sl, [sp]
 80a05ba:	f88d 3001 	strb.w	r3, [sp, #1]
 80a05be:	f88d 3002 	strb.w	r3, [sp, #2]
    }

    // allow construction from HSV color
	inline CRGB(const CHSV& rhs) __attribute__((always_inline))
    {
        hsv2rgb_rainbow( rhs, *this);
 80a05c2:	f001 fdaf 	bl	80a2124 <_ZN9NSFastLED15hsv2rgb_rainbowERKNS_4CHSVERNS_4CRGBE>
    }

    // "or" operator brings each channel up to the higher of the two values
    inline CRGB& operator|= (const CRGB& rhs )
    {
        if( rhs.r > r) r = rhs.r;
 80a05c6:	0060      	lsls	r0, r4, #1
 80a05c8:	1903      	adds	r3, r0, r4
 80a05ca:	f818 2003 	ldrb.w	r2, [r8, r3]
 80a05ce:	f89d 1004 	ldrb.w	r1, [sp, #4]

  static uint8_t dotcount = 1;
  static uint8_t dotinc = 1;
  static bool handled = false;

  for( int i = 0; i < dotcount; i++)
 80a05d2:	3601      	adds	r6, #1
 80a05d4:	428a      	cmp	r2, r1
 80a05d6:	4a28      	ldr	r2, [pc, #160]	; (80a0678 <_Z7juggle2v+0x114>)
 80a05d8:	bf38      	it	cc
 80a05da:	f808 1003 	strbcc.w	r1, [r8, r3]
        if( rhs.g > g) g = rhs.g;
 80a05de:	1903      	adds	r3, r0, r4
 80a05e0:	4413      	add	r3, r2
 80a05e2:	f893 e001 	ldrb.w	lr, [r3, #1]
 80a05e6:	f89d 1005 	ldrb.w	r1, [sp, #5]
        if( rhs.b > b) b = rhs.b;
 80a05ea:	4404      	add	r4, r0

    // "or" operator brings each channel up to the higher of the two values
    inline CRGB& operator|= (const CRGB& rhs )
    {
        if( rhs.r > r) r = rhs.r;
        if( rhs.g > g) g = rhs.g;
 80a05ec:	458e      	cmp	lr, r1
 80a05ee:	bf38      	it	cc
 80a05f0:	7059      	strbcc	r1, [r3, #1]
        if( rhs.b > b) b = rhs.b;
 80a05f2:	4414      	add	r4, r2
 80a05f4:	f89d 3006 	ldrb.w	r3, [sp, #6]
 80a05f8:	78a2      	ldrb	r2, [r4, #2]
 80a05fa:	429a      	cmp	r2, r3
    if(i % 2 == 0)
      pos = (NUM_LEDS - 1) - pos;

    leds[pos] |= CHSV(dothue, 255, 255);

    dothue += 256 / dotcount;
 80a05fc:	f899 2000 	ldrb.w	r2, [r9]
 80a0600:	bf38      	it	cc
 80a0602:	70a3      	strbcc	r3, [r4, #2]
 80a0604:	f44f 7380 	mov.w	r3, #256	; 0x100
 80a0608:	fb93 f3f2 	sdiv	r3, r3, r2
 80a060c:	4453      	add	r3, sl
 80a060e:	fa5f fa83 	uxtb.w	sl, r3

  static uint8_t dotcount = 1;
  static uint8_t dotinc = 1;
  static bool handled = false;

  for( int i = 0; i < dotcount; i++)
 80a0612:	e7b4      	b.n	80a057e <_Z7juggle2v+0x1a>
    dothue += 256 / dotcount;
  }

  uint8_t newdotpos;

  if(dotinc == 1)
 80a0614:	4e19      	ldr	r6, [pc, #100]	; (80a067c <_Z7juggle2v+0x118>)
 80a0616:	7833      	ldrb	r3, [r6, #0]
 80a0618:	2b01      	cmp	r3, #1
 80a061a:	d10f      	bne.n	80a063c <_Z7juggle2v+0xd8>
 80a061c:	f001 fe54 	bl	80a22c8 <HAL_Timer_Get_Milli_Seconds>
//           that oscillates within a given range.
LIB8STATIC uint8_t beatsin8( accum88 beats_per_minute, uint8_t lowest = 0, uint8_t highest = 255,
                            uint32_t timebase = 0, uint8_t phase_offset = 0)
{
    uint8_t beat = beat8( beats_per_minute, timebase);
    uint8_t beatsin = sin8( beat + phase_offset);
 80a0620:	f44f 12af 	mov.w	r2, #1433600	; 0x15e000
 80a0624:	4350      	muls	r0, r2
 80a0626:	ea4f 134b 	mov.w	r3, fp, lsl #5
 80a062a:	eb03 6010 	add.w	r0, r3, r0, lsr #24
 80a062e:	b2c0      	uxtb	r0, r0
 80a0630:	f7ff fd70 	bl	80a0114 <_ZN9NSFastLEDL6sin8_CEh>
//         In other words, it computes i * (scale / 256)
//         4 clocks AVR with MUL, 2 clocks ARM
LIB8STATIC uint8_t scale8( uint8_t i, fract8 scale)
{
#if SCALE8_C == 1
    return ((uint16_t)i * (uint16_t)(scale) ) >> 8;
 80a0634:	254b      	movs	r5, #75	; 0x4b
 80a0636:	4368      	muls	r0, r5
 80a0638:	f3c0 2507 	ubfx	r5, r0, #8, #8
    newdotpos = beatsin8(bpm, 0, NUM_LEDS / 2, 0, dotcount * (256 / maxdotcount));
  else if (dotinc == -1)
    newdotpos = beatsin8(bpm, 0, NUM_LEDS / 2, 0, (dotcount - 1) * (256 / maxdotcount));

  if((newdotpos == NUM_LEDS / 2 || newdotpos == (NUM_LEDS / 2) - 1))
 80a063c:	3d4a      	subs	r5, #74	; 0x4a
 80a063e:	b2ed      	uxtb	r5, r5
 80a0640:	2d01      	cmp	r5, #1
 80a0642:	4b0f      	ldr	r3, [pc, #60]	; (80a0680 <_Z7juggle2v+0x11c>)
 80a0644:	d80f      	bhi.n	80a0666 <_Z7juggle2v+0x102>
  {
    if(!handled)
 80a0646:	781a      	ldrb	r2, [r3, #0]
 80a0648:	b97a      	cbnz	r2, 80a066a <_Z7juggle2v+0x106>
    {
      handled = true;
 80a064a:	2201      	movs	r2, #1
 80a064c:	701a      	strb	r2, [r3, #0]

      dotcount += dotinc;
 80a064e:	7823      	ldrb	r3, [r4, #0]
 80a0650:	7832      	ldrb	r2, [r6, #0]
 80a0652:	4413      	add	r3, r2
 80a0654:	b2db      	uxtb	r3, r3

      if(dotcount == maxdotcount - 1 || dotcount == 1)
 80a0656:	2b07      	cmp	r3, #7
  {
    if(!handled)
    {
      handled = true;

      dotcount += dotinc;
 80a0658:	7023      	strb	r3, [r4, #0]

      if(dotcount == maxdotcount - 1 || dotcount == 1)
 80a065a:	d001      	beq.n	80a0660 <_Z7juggle2v+0xfc>
 80a065c:	2b01      	cmp	r3, #1
 80a065e:	d104      	bne.n	80a066a <_Z7juggle2v+0x106>
        dotinc *= -1;
 80a0660:	4252      	negs	r2, r2
 80a0662:	7032      	strb	r2, [r6, #0]
 80a0664:	e001      	b.n	80a066a <_Z7juggle2v+0x106>
    }
  }
  else
  {
    handled = false;
 80a0666:	2200      	movs	r2, #0
 80a0668:	701a      	strb	r2, [r3, #0]
  }

  return 0;
}
 80a066a:	2000      	movs	r0, #0
 80a066c:	b003      	add	sp, #12
 80a066e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80a0672:	bf00      	nop
 80a0674:	20000326 	.word	0x20000326
 80a0678:	200005b7 	.word	0x200005b7
 80a067c:	20000324 	.word	0x20000324
 80a0680:	20000bc4 	.word	0x20000bc4

080a0684 <_ZN9NSFastLED13CEveryNMillis5readyEv>:
    void reset() { mPrevTrigger = getTime(); }; \
    void trigger() { mPrevTrigger = getTime() - mPeriod; }; \
        \
    operator bool() { return ready(); } \
};
INSTANTIATE_EVERY_N_TIME_PERIODS(CEveryNMillis,uint32_t,GET_MILLIS);
 80a0684:	b538      	push	{r3, r4, r5, lr}
 80a0686:	4604      	mov	r4, r0
 80a0688:	f001 fe1e 	bl	80a22c8 <HAL_Timer_Get_Milli_Seconds>
 80a068c:	6823      	ldr	r3, [r4, #0]
 80a068e:	1ac0      	subs	r0, r0, r3
 80a0690:	6863      	ldr	r3, [r4, #4]
 80a0692:	4283      	cmp	r3, r0
 80a0694:	bf94      	ite	ls
 80a0696:	2501      	movls	r5, #1
 80a0698:	2500      	movhi	r5, #0
 80a069a:	d802      	bhi.n	80a06a2 <_ZN9NSFastLED13CEveryNMillis5readyEv+0x1e>
 80a069c:	f001 fe14 	bl	80a22c8 <HAL_Timer_Get_Milli_Seconds>
 80a06a0:	6020      	str	r0, [r4, #0]
 80a06a2:	4628      	mov	r0, r5
 80a06a4:	bd38      	pop	{r3, r4, r5, pc}

080a06a6 <_ZN9NSFastLED14CEveryNSeconds5readyEv>:
INSTANTIATE_EVERY_N_TIME_PERIODS(CEveryNSeconds,uint16_t,seconds16);
 80a06a6:	b570      	push	{r4, r5, r6, lr}
 80a06a8:	4605      	mov	r5, r0
 80a06aa:	f001 fe0d 	bl	80a22c8 <HAL_Timer_Get_Milli_Seconds>
 80a06ae:	f44f 747a 	mov.w	r4, #1000	; 0x3e8
 80a06b2:	fbb0 f0f4 	udiv	r0, r0, r4
 80a06b6:	882b      	ldrh	r3, [r5, #0]
 80a06b8:	1ac0      	subs	r0, r0, r3
 80a06ba:	886b      	ldrh	r3, [r5, #2]
 80a06bc:	b280      	uxth	r0, r0
 80a06be:	4283      	cmp	r3, r0
 80a06c0:	bf94      	ite	ls
 80a06c2:	2601      	movls	r6, #1
 80a06c4:	2600      	movhi	r6, #0
 80a06c6:	d804      	bhi.n	80a06d2 <_ZN9NSFastLED14CEveryNSeconds5readyEv+0x2c>
 80a06c8:	f001 fdfe 	bl	80a22c8 <HAL_Timer_Get_Milli_Seconds>
 80a06cc:	fbb0 f0f4 	udiv	r0, r0, r4
 80a06d0:	8028      	strh	r0, [r5, #0]
 80a06d2:	4630      	mov	r0, r6
 80a06d4:	bd70      	pop	{r4, r5, r6, pc}

080a06d6 <_ZN9NSFastLED4CRGBpLERKS0_>:
        return *this;
    }


    // add one RGB to another, saturating at 0xFF for each channel
    inline CRGB& operator+= (const CRGB& rhs )
 80a06d6:	b510      	push	{r4, lr}

// qadd8: add one byte to another, saturating at 0xFF
LIB8STATIC uint8_t qadd8( uint8_t i, uint8_t j)
{
#if QADD8_C == 1
    unsigned int t = i + j;
 80a06d8:	7804      	ldrb	r4, [r0, #0]
 80a06da:	780a      	ldrb	r2, [r1, #0]
 80a06dc:	4422      	add	r2, r4
 80a06de:	2aff      	cmp	r2, #255	; 0xff
 80a06e0:	bfa8      	it	ge
 80a06e2:	22ff      	movge	r2, #255	; 0xff
    {
        r = qadd8( r, rhs.r);
 80a06e4:	7002      	strb	r2, [r0, #0]
 80a06e6:	784a      	ldrb	r2, [r1, #1]
 80a06e8:	7844      	ldrb	r4, [r0, #1]
 80a06ea:	4422      	add	r2, r4
 80a06ec:	2aff      	cmp	r2, #255	; 0xff
 80a06ee:	bfa8      	it	ge
 80a06f0:	22ff      	movge	r2, #255	; 0xff
        g = qadd8( g, rhs.g);
 80a06f2:	7042      	strb	r2, [r0, #1]
 80a06f4:	7889      	ldrb	r1, [r1, #2]
 80a06f6:	7882      	ldrb	r2, [r0, #2]
 80a06f8:	440a      	add	r2, r1
 80a06fa:	2aff      	cmp	r2, #255	; 0xff
 80a06fc:	bfa8      	it	ge
 80a06fe:	22ff      	movge	r2, #255	; 0xff
        b = qadd8( b, rhs.b);
 80a0700:	7082      	strb	r2, [r0, #2]
        return *this;
    }
 80a0702:	bd10      	pop	{r4, pc}

080a0704 <_Z7sinelonv>:
  leds[pos] += CHSV( gHue + random8(64), 200, 255);
  return 8;
}

uint8_t sinelon()
{
 80a0704:	b537      	push	{r0, r1, r2, r4, r5, lr}
  // a colored dot sweeping back and forth, with fading trails
  fadeToBlackBy( leds, NUM_LEDS, 20);
 80a0706:	4d15      	ldr	r5, [pc, #84]	; (80a075c <_Z7sinelonv+0x58>)
 80a0708:	2214      	movs	r2, #20
 80a070a:	2196      	movs	r1, #150	; 0x96
 80a070c:	4628      	mov	r0, r5
 80a070e:	f001 fc75 	bl	80a1ffc <_ZN9NSFastLED13fadeToBlackByEPNS_4CRGBEth>
 80a0712:	f001 fdd9 	bl	80a22c8 <HAL_Timer_Get_Milli_Seconds>
//           that oscillates within a given range.
LIB8STATIC uint16_t beatsin16( accum88 beats_per_minute, uint16_t lowest = 0, uint16_t highest = 65535,
                               uint32_t timebase = 0, uint16_t phase_offset = 0)
{
    uint16_t beat = beat16( beats_per_minute, timebase);
    uint16_t beatsin = (sin16( beat + phase_offset) + 32768);
 80a0716:	4b12      	ldr	r3, [pc, #72]	; (80a0760 <_Z7sinelonv+0x5c>)
 80a0718:	4358      	muls	r0, r3
 80a071a:	0c00      	lsrs	r0, r0, #16
 80a071c:	f7ff fcdc 	bl	80a00d8 <_ZN9NSFastLEDL7sin16_CEt>
 80a0720:	4604      	mov	r4, r0
  int pos = beatsin16(13,0,NUM_LEDS);
  leds[pos] += CHSV( gHue, 255, 192);
 80a0722:	4b10      	ldr	r3, [pc, #64]	; (80a0764 <_Z7sinelonv+0x60>)
    }

    // allow construction from HSV color
	inline CRGB(const CHSV& rhs) __attribute__((always_inline))
    {
        hsv2rgb_rainbow( rhs, *this);
 80a0724:	a901      	add	r1, sp, #4
    {
    }

    // allow construction from H, S, V
    inline CHSV( uint8_t ih, uint8_t is, uint8_t iv) __attribute__((always_inline))
        : h(ih), s(is), v(iv)
 80a0726:	781b      	ldrb	r3, [r3, #0]
    }

    // allow construction from HSV color
	inline CRGB(const CHSV& rhs) __attribute__((always_inline))
    {
        hsv2rgb_rainbow( rhs, *this);
 80a0728:	4668      	mov	r0, sp
    {
    }

    // allow construction from H, S, V
    inline CHSV( uint8_t ih, uint8_t is, uint8_t iv) __attribute__((always_inline))
        : h(ih), s(is), v(iv)
 80a072a:	f88d 3000 	strb.w	r3, [sp]
 80a072e:	23ff      	movs	r3, #255	; 0xff
 80a0730:	f88d 3001 	strb.w	r3, [sp, #1]
 80a0734:	23c0      	movs	r3, #192	; 0xc0
 80a0736:	f88d 3002 	strb.w	r3, [sp, #2]
    }

    // allow construction from HSV color
	inline CRGB(const CHSV& rhs) __attribute__((always_inline))
    {
        hsv2rgb_rainbow( rhs, *this);
 80a073a:	f001 fcf3 	bl	80a2124 <_ZN9NSFastLED15hsv2rgb_rainbowERKNS_4CHSVERNS_4CRGBE>
 80a073e:	f5a4 4000 	sub.w	r0, r4, #32768	; 0x8000
 80a0742:	2396      	movs	r3, #150	; 0x96
 80a0744:	b280      	uxth	r0, r0
 80a0746:	4358      	muls	r0, r3
 80a0748:	0c00      	lsrs	r0, r0, #16
 80a074a:	eb00 0040 	add.w	r0, r0, r0, lsl #1
 80a074e:	a901      	add	r1, sp, #4
 80a0750:	4428      	add	r0, r5
 80a0752:	f7ff ffc0 	bl	80a06d6 <_ZN9NSFastLED4CRGBpLERKS0_>
  return 8;
}
 80a0756:	2008      	movs	r0, #8
 80a0758:	b003      	add	sp, #12
 80a075a:	bd30      	pop	{r4, r5, pc}
 80a075c:	200005b7 	.word	0x200005b7
 80a0760:	000e3800 	.word	0x000e3800
 80a0764:	200005a9 	.word	0x200005a9

080a0768 <_Z6jugglev>:

  return 8;
}

uint8_t juggle()
{
 80a0768:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
  static uint8_t    numdots =   4; // Number of dots in use.
  static uint8_t   faderate =   2; // How long should the trails be. Very low value = longer trails.
  static uint8_t     hueinc =  255 / numdots - 1; // Incremental change in hue between each dot.
 80a076c:	4c4d      	ldr	r4, [pc, #308]	; (80a08a4 <_Z6jugglev+0x13c>)
 80a076e:	4e4e      	ldr	r6, [pc, #312]	; (80a08a8 <_Z6jugglev+0x140>)
 80a0770:	6823      	ldr	r3, [r4, #0]
 80a0772:	f013 0f01 	tst.w	r3, #1
 80a0776:	d10d      	bne.n	80a0794 <_Z6jugglev+0x2c>
 80a0778:	4620      	mov	r0, r4
 80a077a:	f7ff fc90 	bl	80a009e <__cxa_guard_acquire>
 80a077e:	b148      	cbz	r0, 80a0794 <_Z6jugglev+0x2c>
 80a0780:	7832      	ldrb	r2, [r6, #0]
 80a0782:	23ff      	movs	r3, #255	; 0xff
 80a0784:	fb93 f3f2 	sdiv	r3, r3, r2
 80a0788:	4a48      	ldr	r2, [pc, #288]	; (80a08ac <_Z6jugglev+0x144>)
 80a078a:	3b01      	subs	r3, #1
 80a078c:	4620      	mov	r0, r4
 80a078e:	7013      	strb	r3, [r2, #0]
 80a0790:	f7ff fc8a 	bl	80a00a8 <__cxa_guard_release>
 80a0794:	f001 fd98 	bl	80a22c8 <HAL_Timer_Get_Milli_Seconds>
  static uint8_t    thissat = 255; // Saturation of the colour.
  static uint8_t thisbright = 255; // How bright should the LED/display be.
  static uint8_t   basebeat =   5; // Higher = faster movement.

  static uint8_t lastSecond =  99;  // Static variable, means it's only defined once. This is our 'debounce' variable.
  uint8_t secondHand = (millis() / 1000) % 30; // IMPORTANT!!! Change '30' to a different value to change duration of the loop.
 80a0798:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 80a079c:	fbb0 f3f3 	udiv	r3, r0, r3
 80a07a0:	221e      	movs	r2, #30
 80a07a2:	fbb3 f0f2 	udiv	r0, r3, r2
 80a07a6:	fb02 3010 	mls	r0, r2, r0, r3

  if (lastSecond != secondHand) { // Debounce to make sure we're not repeating an assignment.
 80a07aa:	4b41      	ldr	r3, [pc, #260]	; (80a08b0 <_Z6jugglev+0x148>)
  static uint8_t    thissat = 255; // Saturation of the colour.
  static uint8_t thisbright = 255; // How bright should the LED/display be.
  static uint8_t   basebeat =   5; // Higher = faster movement.

  static uint8_t lastSecond =  99;  // Static variable, means it's only defined once. This is our 'debounce' variable.
  uint8_t secondHand = (millis() / 1000) % 30; // IMPORTANT!!! Change '30' to a different value to change duration of the loop.
 80a07ac:	b2c2      	uxtb	r2, r0

  if (lastSecond != secondHand) { // Debounce to make sure we're not repeating an assignment.
 80a07ae:	7819      	ldrb	r1, [r3, #0]
 80a07b0:	4c40      	ldr	r4, [pc, #256]	; (80a08b4 <_Z6jugglev+0x14c>)
 80a07b2:	4291      	cmp	r1, r2
 80a07b4:	4940      	ldr	r1, [pc, #256]	; (80a08b8 <_Z6jugglev+0x150>)
 80a07b6:	d028      	beq.n	80a080a <_Z6jugglev+0xa2>
    lastSecond = secondHand;
    switch(secondHand) {
 80a07b8:	280a      	cmp	r0, #10

  static uint8_t lastSecond =  99;  // Static variable, means it's only defined once. This is our 'debounce' variable.
  uint8_t secondHand = (millis() / 1000) % 30; // IMPORTANT!!! Change '30' to a different value to change duration of the loop.

  if (lastSecond != secondHand) { // Debounce to make sure we're not repeating an assignment.
    lastSecond = secondHand;
 80a07ba:	701a      	strb	r2, [r3, #0]
    switch(secondHand) {
 80a07bc:	d00d      	beq.n	80a07da <_Z6jugglev+0x72>
 80a07be:	2814      	cmp	r0, #20
 80a07c0:	d017      	beq.n	80a07f2 <_Z6jugglev+0x8a>
 80a07c2:	bb10      	cbnz	r0, 80a080a <_Z6jugglev+0xa2>
      case  0: numdots = 1; basebeat = 20; hueinc = 16; faderate = 2; thishue = 0; break; // You can change values here, one at a time , or altogether.
 80a07c4:	2301      	movs	r3, #1
 80a07c6:	7033      	strb	r3, [r6, #0]
 80a07c8:	4b3c      	ldr	r3, [pc, #240]	; (80a08bc <_Z6jugglev+0x154>)
 80a07ca:	2214      	movs	r2, #20
 80a07cc:	701a      	strb	r2, [r3, #0]
 80a07ce:	4b37      	ldr	r3, [pc, #220]	; (80a08ac <_Z6jugglev+0x144>)
 80a07d0:	2210      	movs	r2, #16
 80a07d2:	701a      	strb	r2, [r3, #0]
 80a07d4:	2302      	movs	r3, #2
 80a07d6:	700b      	strb	r3, [r1, #0]
 80a07d8:	e016      	b.n	80a0808 <_Z6jugglev+0xa0>
      case 10: numdots = 4; basebeat = 10; hueinc = 16; faderate = 8; thishue = 128; break;
 80a07da:	2304      	movs	r3, #4
 80a07dc:	7033      	strb	r3, [r6, #0]
 80a07de:	4b37      	ldr	r3, [pc, #220]	; (80a08bc <_Z6jugglev+0x154>)
 80a07e0:	2210      	movs	r2, #16
 80a07e2:	7018      	strb	r0, [r3, #0]
 80a07e4:	4b31      	ldr	r3, [pc, #196]	; (80a08ac <_Z6jugglev+0x144>)
 80a07e6:	701a      	strb	r2, [r3, #0]
 80a07e8:	2308      	movs	r3, #8
 80a07ea:	700b      	strb	r3, [r1, #0]
 80a07ec:	2380      	movs	r3, #128	; 0x80
 80a07ee:	7023      	strb	r3, [r4, #0]
 80a07f0:	e00b      	b.n	80a080a <_Z6jugglev+0xa2>
      case 20: numdots = 8; basebeat =  3; hueinc =  0; faderate = 8; thishue=random8(); break; // Only gets called once, and not continuously for the next several seconds. Therefore, no rainbows.
 80a07f2:	4a32      	ldr	r2, [pc, #200]	; (80a08bc <_Z6jugglev+0x154>)
 80a07f4:	2003      	movs	r0, #3
 80a07f6:	7010      	strb	r0, [r2, #0]
 80a07f8:	4a2c      	ldr	r2, [pc, #176]	; (80a08ac <_Z6jugglev+0x144>)
 80a07fa:	2308      	movs	r3, #8
 80a07fc:	2000      	movs	r0, #0
 80a07fe:	7033      	strb	r3, [r6, #0]
 80a0800:	7010      	strb	r0, [r2, #0]
 80a0802:	700b      	strb	r3, [r1, #0]
 80a0804:	f7ff fc56 	bl	80a00b4 <_ZN9NSFastLEDL7random8Ev>
 80a0808:	7020      	strb	r0, [r4, #0]
      case 30: break;
    }
  }

  // Several colored dots, weaving in and out of sync with each other
  curhue = thishue; // Reset the hue values.
 80a080a:	7823      	ldrb	r3, [r4, #0]
 80a080c:	4d2c      	ldr	r5, [pc, #176]	; (80a08c0 <_Z6jugglev+0x158>)
  fadeToBlackBy(leds, NUM_LEDS, faderate);
 80a080e:	780a      	ldrb	r2, [r1, #0]
 80a0810:	482c      	ldr	r0, [pc, #176]	; (80a08c4 <_Z6jugglev+0x15c>)
 80a0812:	2196      	movs	r1, #150	; 0x96
      case 30: break;
    }
  }

  // Several colored dots, weaving in and out of sync with each other
  curhue = thishue; // Reset the hue values.
 80a0814:	702b      	strb	r3, [r5, #0]
  fadeToBlackBy(leds, NUM_LEDS, faderate);
 80a0816:	f001 fbf1 	bl	80a1ffc <_ZN9NSFastLED13fadeToBlackByEPNS_4CRGBEth>
  for( int i = 0; i < numdots; i++) {
    //beat16 is a FastLED 3.1 function
    leds[beatsin16(basebeat+i+numdots,0,NUM_LEDS)] += CHSV(gHue + curhue, thissat, thisbright);
 80a081a:	f8df a0a0 	ldr.w	sl, [pc, #160]	; 80a08bc <_Z6jugglev+0x154>
 80a081e:	f8df 80a8 	ldr.w	r8, [pc, #168]	; 80a08c8 <_Z6jugglev+0x160>
 80a0822:	4f28      	ldr	r7, [pc, #160]	; (80a08c4 <_Z6jugglev+0x15c>)
  }

  // Several colored dots, weaving in and out of sync with each other
  curhue = thishue; // Reset the hue values.
  fadeToBlackBy(leds, NUM_LEDS, faderate);
  for( int i = 0; i < numdots; i++) {
 80a0824:	f04f 0900 	mov.w	r9, #0
 80a0828:	7833      	ldrb	r3, [r6, #0]
 80a082a:	4599      	cmp	r9, r3
 80a082c:	da35      	bge.n	80a089a <_Z6jugglev+0x132>
    //beat16 is a FastLED 3.1 function
    leds[beatsin16(basebeat+i+numdots,0,NUM_LEDS)] += CHSV(gHue + curhue, thissat, thisbright);
 80a082e:	f89a 4000 	ldrb.w	r4, [sl]
 80a0832:	441c      	add	r4, r3
 80a0834:	444c      	add	r4, r9
 80a0836:	b2a4      	uxth	r4, r4

// beat16 generates a 16-bit 'sawtooth' wave at a given BPM
LIB8STATIC uint16_t beat16( accum88 beats_per_minute, uint32_t timebase = 0)
{
    // Convert simple 8-bit BPM's to full Q8.8 accum88's if needed
    if( beats_per_minute < 256) beats_per_minute <<= 8;
 80a0838:	2cff      	cmp	r4, #255	; 0xff
 80a083a:	bf9c      	itt	ls
 80a083c:	0224      	lslls	r4, r4, #8
 80a083e:	b2a4      	uxthls	r4, r4
 80a0840:	f001 fd42 	bl	80a22c8 <HAL_Timer_Get_Milli_Seconds>
//           that oscillates within a given range.
LIB8STATIC uint16_t beatsin16( accum88 beats_per_minute, uint16_t lowest = 0, uint16_t highest = 65535,
                               uint32_t timebase = 0, uint16_t phase_offset = 0)
{
    uint16_t beat = beat16( beats_per_minute, timebase);
    uint16_t beatsin = (sin16( beat + phase_offset) + 32768);
 80a0844:	f44f 738c 	mov.w	r3, #280	; 0x118
 80a0848:	4358      	muls	r0, r3
 80a084a:	4360      	muls	r0, r4
 80a084c:	0c00      	lsrs	r0, r0, #16
 80a084e:	f7ff fc43 	bl	80a00d8 <_ZN9NSFastLEDL7sin16_CEt>
 80a0852:	4604      	mov	r4, r0
    {
    }

    // allow construction from H, S, V
    inline CHSV( uint8_t ih, uint8_t is, uint8_t iv) __attribute__((always_inline))
        : h(ih), s(is), v(iv)
 80a0854:	f898 2000 	ldrb.w	r2, [r8]
 80a0858:	782b      	ldrb	r3, [r5, #0]
    }

    // allow construction from HSV color
	inline CRGB(const CHSV& rhs) __attribute__((always_inline))
    {
        hsv2rgb_rainbow( rhs, *this);
 80a085a:	a901      	add	r1, sp, #4
    {
    }

    // allow construction from H, S, V
    inline CHSV( uint8_t ih, uint8_t is, uint8_t iv) __attribute__((always_inline))
        : h(ih), s(is), v(iv)
 80a085c:	4413      	add	r3, r2
 80a085e:	f88d 3000 	strb.w	r3, [sp]
    }

    // allow construction from HSV color
	inline CRGB(const CHSV& rhs) __attribute__((always_inline))
    {
        hsv2rgb_rainbow( rhs, *this);
 80a0862:	4668      	mov	r0, sp
    {
    }

    // allow construction from H, S, V
    inline CHSV( uint8_t ih, uint8_t is, uint8_t iv) __attribute__((always_inline))
        : h(ih), s(is), v(iv)
 80a0864:	23ff      	movs	r3, #255	; 0xff
 80a0866:	f88d 3001 	strb.w	r3, [sp, #1]
 80a086a:	f88d 3002 	strb.w	r3, [sp, #2]
    }

    // allow construction from HSV color
	inline CRGB(const CHSV& rhs) __attribute__((always_inline))
    {
        hsv2rgb_rainbow( rhs, *this);
 80a086e:	f001 fc59 	bl	80a2124 <_ZN9NSFastLED15hsv2rgb_rainbowERKNS_4CHSVERNS_4CRGBE>
 80a0872:	f5a4 4000 	sub.w	r0, r4, #32768	; 0x8000
 80a0876:	2396      	movs	r3, #150	; 0x96
 80a0878:	b280      	uxth	r0, r0
 80a087a:	4358      	muls	r0, r3
 80a087c:	0c00      	lsrs	r0, r0, #16
 80a087e:	eb00 0040 	add.w	r0, r0, r0, lsl #1
 80a0882:	a901      	add	r1, sp, #4
 80a0884:	4438      	add	r0, r7
 80a0886:	f7ff ff26 	bl	80a06d6 <_ZN9NSFastLED4CRGBpLERKS0_>
    curhue += hueinc;
 80a088a:	4b08      	ldr	r3, [pc, #32]	; (80a08ac <_Z6jugglev+0x144>)
 80a088c:	782a      	ldrb	r2, [r5, #0]
 80a088e:	781b      	ldrb	r3, [r3, #0]
  }

  // Several colored dots, weaving in and out of sync with each other
  curhue = thishue; // Reset the hue values.
  fadeToBlackBy(leds, NUM_LEDS, faderate);
  for( int i = 0; i < numdots; i++) {
 80a0890:	f109 0901 	add.w	r9, r9, #1
    //beat16 is a FastLED 3.1 function
    leds[beatsin16(basebeat+i+numdots,0,NUM_LEDS)] += CHSV(gHue + curhue, thissat, thisbright);
    curhue += hueinc;
 80a0894:	4413      	add	r3, r2
 80a0896:	702b      	strb	r3, [r5, #0]
  }

  // Several colored dots, weaving in and out of sync with each other
  curhue = thishue; // Reset the hue values.
  fadeToBlackBy(leds, NUM_LEDS, faderate);
  for( int i = 0; i < numdots; i++) {
 80a0898:	e7c6      	b.n	80a0828 <_Z6jugglev+0xc0>
    leds[beatsin16(basebeat+i+numdots,0,NUM_LEDS)] += CHSV(gHue + curhue, thissat, thisbright);
    curhue += hueinc;
  }

  return 0;
}
 80a089a:	2000      	movs	r0, #0
 80a089c:	b002      	add	sp, #8
 80a089e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80a08a2:	bf00      	nop
 80a08a4:	2000079c 	.word	0x2000079c
 80a08a8:	20000310 	.word	0x20000310
 80a08ac:	200007d4 	.word	0x200007d4
 80a08b0:	20000308 	.word	0x20000308
 80a08b4:	200007a0 	.word	0x200007a0
 80a08b8:	20000325 	.word	0x20000325
 80a08bc:	20000300 	.word	0x20000300
 80a08c0:	20000779 	.word	0x20000779
 80a08c4:	200005b7 	.word	0x200005b7
 80a08c8:	200005a9 	.word	0x200005a9

080a08cc <_ZN9NSFastLED13CRGBPalette16C1ERA16_Km>:
    		entries[i] = rhs.entries[i]; // implicit HSV-to-RGB conversion
        }
        return *this;
    }

    CRGBPalette16( const TProgmemRGBPalette16& rhs)
 80a08cc:	4603      	mov	r3, r0
 80a08ce:	b530      	push	{r4, r5, lr}
 80a08d0:	3904      	subs	r1, #4
 80a08d2:	f100 0430 	add.w	r4, r0, #48	; 0x30
    {
        for( uint8_t i = 0; i < 16; i++) {
            entries[i] =  pgm_read_dword_near( rhs + i);
 80a08d6:	f851 2f04 	ldr.w	r2, [r1, #4]!
 80a08da:	3303      	adds	r3, #3
    }

    // allow assignment from 32-bit (really 24-bit) 0xRRGGBB color code
	inline CRGB& operator= (const uint32_t colorcode) __attribute__((always_inline))
    {
        r = (colorcode >> 16) & 0xFF;
 80a08dc:	0c15      	lsrs	r5, r2, #16
 80a08de:	f803 5c03 	strb.w	r5, [r3, #-3]
        g = (colorcode >>  8) & 0xFF;
 80a08e2:	0a15      	lsrs	r5, r2, #8
 80a08e4:	f803 5c02 	strb.w	r5, [r3, #-2]
        b = (colorcode >>  0) & 0xFF;
 80a08e8:	f803 2c01 	strb.w	r2, [r3, #-1]
        return *this;
    }

    CRGBPalette16( const TProgmemRGBPalette16& rhs)
    {
        for( uint8_t i = 0; i < 16; i++) {
 80a08ec:	42a3      	cmp	r3, r4
 80a08ee:	d1f2      	bne.n	80a08d6 <_ZN9NSFastLED13CRGBPalette16C1ERA16_Km+0xa>
            entries[i] =  pgm_read_dword_near( rhs + i);
        }
    }
 80a08f0:	bd30      	pop	{r4, r5, pc}

080a08f2 <_ZN9NSFastLED13CRGBPalette16aSEPKh>:
    // the exact stripe widths at the expense of dropping some colors.
    CRGBPalette16( TProgmemRGBGradientPalette_bytes progpal )
    {
        *this = progpal;
    }
    CRGBPalette16& operator=( TProgmemRGBGradientPalette_bytes progpal )
 80a08f2:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80a08f6:	4607      	mov	r7, r0
 80a08f8:	460e      	mov	r6, r1
 80a08fa:	b089      	sub	sp, #36	; 0x24
    {
        TRGBGradientPaletteEntryUnion* progent = (TRGBGradientPaletteEntryUnion*)(progpal);
        TRGBGradientPaletteEntryUnion u;

        // Count entries
        uint8_t count = 0;
 80a08fc:	2400      	movs	r4, #0
        do {
            u.dword = pgm_read_dword_near(progent + count);
 80a08fe:	f856 2024 	ldr.w	r2, [r6, r4, lsl #2]
            count++;;
 80a0902:	3401      	adds	r4, #1
        } while ( u.index != 255);
 80a0904:	b2d2      	uxtb	r2, r2
 80a0906:	2aff      	cmp	r2, #255	; 0xff

        // Count entries
        uint8_t count = 0;
        do {
            u.dword = pgm_read_dword_near(progent + count);
            count++;;
 80a0908:	b2e4      	uxtb	r4, r4
        } while ( u.index != 255);
 80a090a:	d1f8      	bne.n	80a08fe <_ZN9NSFastLED13CRGBPalette16aSEPKh+0xc>

        int8_t lastSlotUsed = -1;

        u.dword = pgm_read_dword_near( progent);
 80a090c:	6832      	ldr	r2, [r6, #0]
        CRGB rgbstart( u.r, u.g, u.b);

        int indexstart = 0;
 80a090e:	2000      	movs	r0, #0
        } while ( u.index != 255);

        int8_t lastSlotUsed = -1;

        u.dword = pgm_read_dword_near( progent);
        CRGB rgbstart( u.r, u.g, u.b);
 80a0910:	f3c2 2e07 	ubfx	lr, r2, #8, #8
 80a0914:	f3c2 4c07 	ubfx	ip, r2, #16, #8
 80a0918:	ea4f 6912 	mov.w	r9, r2, lsr #24
        do {
            u.dword = pgm_read_dword_near(progent + count);
            count++;;
        } while ( u.index != 255);

        int8_t lastSlotUsed = -1;
 80a091c:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
        int indexstart = 0;
        uint8_t istart8 = 0;
        uint8_t iend8 = 0;
        while( indexstart < 255) {
            progent++;
            u.dword = pgm_read_dword_near( progent);
 80a0920:	f856 2f04 	ldr.w	r2, [r6, #4]!
            int indexend  = u.index;
            CRGB rgbend( u.r, u.g, u.b);
            istart8 = indexstart / 16;
 80a0924:	1100      	asrs	r0, r0, #4
        uint8_t iend8 = 0;
        while( indexstart < 255) {
            progent++;
            u.dword = pgm_read_dword_near( progent);
            int indexend  = u.index;
            CRGB rgbend( u.r, u.g, u.b);
 80a0926:	f3c2 2b07 	ubfx	fp, r2, #8, #8
 80a092a:	fa5f f38b 	uxtb.w	r3, fp
 80a092e:	f3c2 4a07 	ubfx	sl, r2, #16, #8
        uint8_t istart8 = 0;
        uint8_t iend8 = 0;
        while( indexstart < 255) {
            progent++;
            u.dword = pgm_read_dword_near( progent);
            int indexend  = u.index;
 80a0932:	fa5f f882 	uxtb.w	r8, r2
            CRGB rgbend( u.r, u.g, u.b);
 80a0936:	9303      	str	r3, [sp, #12]
 80a0938:	f3c2 6207 	ubfx	r2, r2, #24, #8
 80a093c:	fa5f f38a 	uxtb.w	r3, sl
 80a0940:	9304      	str	r3, [sp, #16]
            istart8 = indexstart / 16;
            iend8   = indexend   / 16;
            if( count < 16) {
 80a0942:	2c0f      	cmp	r4, #15
        uint8_t iend8 = 0;
        while( indexstart < 255) {
            progent++;
            u.dword = pgm_read_dword_near( progent);
            int indexend  = u.index;
            CRGB rgbend( u.r, u.g, u.b);
 80a0944:	b2d3      	uxtb	r3, r2
 80a0946:	9305      	str	r3, [sp, #20]
            istart8 = indexstart / 16;
 80a0948:	b2c1      	uxtb	r1, r0
            iend8   = indexend   / 16;
 80a094a:	ea4f 1318 	mov.w	r3, r8, lsr #4
            if( count < 16) {
 80a094e:	d809      	bhi.n	80a0964 <_ZN9NSFastLED13CRGBPalette16aSEPKh+0x72>
                if( (istart8 <= lastSlotUsed) && (lastSlotUsed < 15)) {
 80a0950:	42a8      	cmp	r0, r5
 80a0952:	dc06      	bgt.n	80a0962 <_ZN9NSFastLED13CRGBPalette16aSEPKh+0x70>
 80a0954:	2d0f      	cmp	r5, #15
 80a0956:	d004      	beq.n	80a0962 <_ZN9NSFastLED13CRGBPalette16aSEPKh+0x70>
                    istart8 = lastSlotUsed + 1;
 80a0958:	1c69      	adds	r1, r5, #1
 80a095a:	b2c9      	uxtb	r1, r1
 80a095c:	428b      	cmp	r3, r1
 80a095e:	bf38      	it	cc
 80a0960:	460b      	movcc	r3, r1
                    if( iend8 < istart8) {
                        iend8 = istart8;
                    }
                }
                lastSlotUsed = iend8;
 80a0962:	b25d      	sxtb	r5, r3
    // allow copy construction
	inline CRGB(const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
        g = rhs.g;
        b = rhs.b;
 80a0964:	f88d 201e 	strb.w	r2, [sp, #30]
            }
            fill_gradient_RGB( &(entries[0]), istart8, rgbstart, iend8, rgbend);
 80a0968:	aa07      	add	r2, sp, #28
 80a096a:	9200      	str	r2, [sp, #0]
 80a096c:	4638      	mov	r0, r7
 80a096e:	aa06      	add	r2, sp, #24
    }

    // allow copy construction
	inline CRGB(const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
 80a0970:	f88d e018 	strb.w	lr, [sp, #24]
        g = rhs.g;
 80a0974:	f88d c019 	strb.w	ip, [sp, #25]
        b = rhs.b;
 80a0978:	f88d 901a 	strb.w	r9, [sp, #26]
    }

    // allow copy construction
	inline CRGB(const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
 80a097c:	f88d b01c 	strb.w	fp, [sp, #28]
        g = rhs.g;
 80a0980:	f88d a01d 	strb.w	sl, [sp, #29]
 80a0984:	f001 fa61 	bl	80a1e4a <_ZN9NSFastLED17fill_gradient_RGBEPNS_4CRGBEtS0_tS0_>
 80a0988:	4640      	mov	r0, r8
        CRGB rgbstart( u.r, u.g, u.b);

        int indexstart = 0;
        uint8_t istart8 = 0;
        uint8_t iend8 = 0;
        while( indexstart < 255) {
 80a098a:	28ff      	cmp	r0, #255	; 0xff
    // allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
        g = rhs.g;
        b = rhs.b;
 80a098c:	f8dd 9014 	ldr.w	r9, [sp, #20]

    // allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
        g = rhs.g;
 80a0990:	f8dd c010 	ldr.w	ip, [sp, #16]
    }

    // allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
 80a0994:	f8dd e00c 	ldr.w	lr, [sp, #12]
 80a0998:	d1c2      	bne.n	80a0920 <_ZN9NSFastLED13CRGBPalette16aSEPKh+0x2e>
            fill_gradient_RGB( &(entries[0]), istart8, rgbstart, iend8, rgbend);
            indexstart = indexend;
            rgbstart = rgbend;
        }
        return *this;
    }
 80a099a:	4638      	mov	r0, r7
 80a099c:	b009      	add	sp, #36	; 0x24
 80a099e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

080a09a2 <_ZN9NSFastLED8CFastLED4showEv>:
	/// Update all our controllers with the current led colors, using the passed in brightness
	/// @param scale temporarily override the scale
	void show(uint8_t scale);

	/// Update all our controllers with the current led colors
	void show() { show(m_Scale); }
 80a09a2:	7801      	ldrb	r1, [r0, #0]
 80a09a4:	f001 b99a 	b.w	80a1cdc <_ZN9NSFastLED8CFastLED4showEh>

080a09a8 <_Z8setPower6String>:

    return -1;
}

int setPower(String args)
{
 80a09a8:	b508      	push	{r3, lr}
    power = args.toInt();
 80a09aa:	f002 f88e 	bl	80a2aca <_ZNK6String5toIntEv>
    if(power < 0)
 80a09ae:	2800      	cmp	r0, #0
 80a09b0:	4b05      	ldr	r3, [pc, #20]	; (80a09c8 <_Z8setPower6String+0x20>)
 80a09b2:	da01      	bge.n	80a09b8 <_Z8setPower6String+0x10>
        power = 0;
 80a09b4:	2200      	movs	r2, #0
 80a09b6:	e004      	b.n	80a09c2 <_Z8setPower6String+0x1a>
    else if (power > 1)
 80a09b8:	2801      	cmp	r0, #1
 80a09ba:	dc01      	bgt.n	80a09c0 <_Z8setPower6String+0x18>
    return -1;
}

int setPower(String args)
{
    power = args.toInt();
 80a09bc:	6018      	str	r0, [r3, #0]
 80a09be:	e001      	b.n	80a09c4 <_Z8setPower6String+0x1c>
    if(power < 0)
        power = 0;
    else if (power > 1)
        power = 1;
 80a09c0:	2201      	movs	r2, #1
 80a09c2:	601a      	str	r2, [r3, #0]

    return power;
}
 80a09c4:	6818      	ldr	r0, [r3, #0]
 80a09c6:	bd08      	pop	{r3, pc}
 80a09c8:	20000314 	.word	0x20000314

080a09cc <_Z13setBrightness6String>:

int setBrightness(String args)
{
 80a09cc:	b510      	push	{r4, lr}
    brightness = args.toInt();
 80a09ce:	f002 f87c 	bl	80a2aca <_ZNK6String5toIntEv>
    if(brightness < 1)
 80a09d2:	2800      	cmp	r0, #0
 80a09d4:	4c0d      	ldr	r4, [pc, #52]	; (80a0a0c <_Z13setBrightness6String+0x40>)
 80a09d6:	dc01      	bgt.n	80a09dc <_Z13setBrightness6String+0x10>
        brightness = 1;
 80a09d8:	2301      	movs	r3, #1
 80a09da:	e004      	b.n	80a09e6 <_Z13setBrightness6String+0x1a>
    else if(brightness > 255)
 80a09dc:	28ff      	cmp	r0, #255	; 0xff
 80a09de:	dc01      	bgt.n	80a09e4 <_Z13setBrightness6String+0x18>
    return power;
}

int setBrightness(String args)
{
    brightness = args.toInt();
 80a09e0:	6020      	str	r0, [r4, #0]
 80a09e2:	e001      	b.n	80a09e8 <_Z13setBrightness6String+0x1c>
    if(brightness < 1)
        brightness = 1;
    else if(brightness > 255)
        brightness = 255;
 80a09e4:	23ff      	movs	r3, #255	; 0xff
 80a09e6:	6023      	str	r3, [r4, #0]

    FastLED.setBrightness(brightness);
 80a09e8:	6821      	ldr	r1, [r4, #0]
	//@}
#endif

	/// Set the global brightness scaling
	/// @param scale a 0-255 value for how much to scale all leds before writing them out
	void setBrightness(uint8_t scale) { m_Scale = scale; }
 80a09ea:	4809      	ldr	r0, [pc, #36]	; (80a0a10 <_Z13setBrightness6String+0x44>)
    FastLED.setDither(brightness < 255);
 80a09ec:	29fe      	cmp	r1, #254	; 0xfe
 80a09ee:	7001      	strb	r1, [r0, #0]
 80a09f0:	bfcc      	ite	gt
 80a09f2:	2100      	movgt	r1, #0
 80a09f4:	2101      	movle	r1, #1
 80a09f6:	f001 f949 	bl	80a1c8c <_ZN9NSFastLED8CFastLED9setDitherEh>

    EEPROM.write(0, brightness);
 80a09fa:	f002 fb5f 	bl	80a30bc <_Z21__fetch_global_EEPROMv>
 80a09fe:	7821      	ldrb	r1, [r4, #0]
 80a0a00:	2000      	movs	r0, #0
 80a0a02:	f7ff fbef 	bl	80a01e4 <_ZN11EEPROMClass5writeEih.isra.3>

    return brightness;
}
 80a0a06:	6820      	ldr	r0, [r4, #0]
 80a0a08:	bd10      	pop	{r4, pc}
 80a0a0a:	bf00      	nop
 80a0a0c:	20000318 	.word	0x20000318
 80a0a10:	20000bc8 	.word	0x20000bc8

080a0a14 <loop>:
int s = 0;
int buttonTime = -1;
boolean buttonPressed = false;

void loop()
{
 80a0a14:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
//   if ((millis() - lastDebounceTime) > debounceDelay) {
//     if (reading != buttonState) {
//       buttonState = reading;


  buttonState = digitalRead(buttonPin);
 80a0a18:	4caf      	ldr	r4, [pc, #700]	; (80a0cd8 <loop+0x2c4>)
int s = 0;
int buttonTime = -1;
boolean buttonPressed = false;

void loop()
{
 80a0a1a:	b091      	sub	sp, #68	; 0x44
//   if ((millis() - lastDebounceTime) > debounceDelay) {
//     if (reading != buttonState) {
//       buttonState = reading;


  buttonState = digitalRead(buttonPin);
 80a0a1c:	8820      	ldrh	r0, [r4, #0]
 80a0a1e:	f002 fb3a 	bl	80a3096 <digitalRead>
 80a0a22:	4eae      	ldr	r6, [pc, #696]	; (80a0cdc <loop+0x2c8>)
 80a0a24:	4680      	mov	r8, r0
 80a0a26:	6030      	str	r0, [r6, #0]
 80a0a28:	9404      	str	r4, [sp, #16]
 80a0a2a:	f8df b320 	ldr.w	fp, [pc, #800]	; 80a0d4c <loop+0x338>
 80a0a2e:	4dac      	ldr	r5, [pc, #688]	; (80a0ce0 <loop+0x2cc>)

  if ((buttonState == LOW) && (lastButtonState == HIGH)) {
 80a0a30:	2800      	cmp	r0, #0
 80a0a32:	f040 8082 	bne.w	80a0b3a <loop+0x126>
 80a0a36:	f8db 3000 	ldr.w	r3, [fp]
 80a0a3a:	2b01      	cmp	r3, #1
 80a0a3c:	d17d      	bne.n	80a0b3a <loop+0x126>
    // double click detected
    if (buttonPressed && ((millis() - buttonTime) < doublePressTime)) {
 80a0a3e:	782b      	ldrb	r3, [r5, #0]
 80a0a40:	4ca8      	ldr	r4, [pc, #672]	; (80a0ce4 <loop+0x2d0>)
 80a0a42:	2b00      	cmp	r3, #0
 80a0a44:	f000 813d 	beq.w	80a0cc2 <loop+0x2ae>
 80a0a48:	f001 fc3e 	bl	80a22c8 <HAL_Timer_Get_Milli_Seconds>
 80a0a4c:	6823      	ldr	r3, [r4, #0]
 80a0a4e:	1ac0      	subs	r0, r0, r3
 80a0a50:	4ba5      	ldr	r3, [pc, #660]	; (80a0ce8 <loop+0x2d4>)
 80a0a52:	681b      	ldr	r3, [r3, #0]
 80a0a54:	4298      	cmp	r0, r3
 80a0a56:	f080 8134 	bcs.w	80a0cc2 <loop+0x2ae>
      brightnessLevel++;
 80a0a5a:	4ca4      	ldr	r4, [pc, #656]	; (80a0cec <loop+0x2d8>)
      if (brightnessLevel >= brightnessLevelsCount) {
 80a0a5c:	4fa4      	ldr	r7, [pc, #656]	; (80a0cf0 <loop+0x2dc>)
  buttonState = digitalRead(buttonPin);

  if ((buttonState == LOW) && (lastButtonState == HIGH)) {
    // double click detected
    if (buttonPressed && ((millis() - buttonTime) < doublePressTime)) {
      brightnessLevel++;
 80a0a5e:	6823      	ldr	r3, [r4, #0]
      if (brightnessLevel >= brightnessLevelsCount) {
 80a0a60:	683a      	ldr	r2, [r7, #0]
  buttonState = digitalRead(buttonPin);

  if ((buttonState == LOW) && (lastButtonState == HIGH)) {
    // double click detected
    if (buttonPressed && ((millis() - buttonTime) < doublePressTime)) {
      brightnessLevel++;
 80a0a62:	3301      	adds	r3, #1
      if (brightnessLevel >= brightnessLevelsCount) {
 80a0a64:	4293      	cmp	r3, r2
  buttonState = digitalRead(buttonPin);

  if ((buttonState == LOW) && (lastButtonState == HIGH)) {
    // double click detected
    if (buttonPressed && ((millis() - buttonTime) < doublePressTime)) {
      brightnessLevel++;
 80a0a66:	6023      	str	r3, [r4, #0]
      if (brightnessLevel >= brightnessLevelsCount) {
 80a0a68:	db01      	blt.n	80a0a6e <loop+0x5a>
        brightnessLevel = 0;
 80a0a6a:	f8c4 8000 	str.w	r8, [r4]
      }
      int newBrightness = brightnessLevelsArr[brightnessLevel];
 80a0a6e:	6823      	ldr	r3, [r4, #0]
 80a0a70:	f8df 82dc 	ldr.w	r8, [pc, #732]	; 80a0d50 <loop+0x33c>
      setBrightness(String(newBrightness));
 80a0a74:	220a      	movs	r2, #10
    if (buttonPressed && ((millis() - buttonTime) < doublePressTime)) {
      brightnessLevel++;
      if (brightnessLevel >= brightnessLevelsCount) {
        brightnessLevel = 0;
      }
      int newBrightness = brightnessLevelsArr[brightnessLevel];
 80a0a76:	f858 9023 	ldr.w	r9, [r8, r3, lsl #2]
      setBrightness(String(newBrightness));
 80a0a7a:	a80c      	add	r0, sp, #48	; 0x30
 80a0a7c:	4649      	mov	r1, r9
 80a0a7e:	f001 ff75 	bl	80a296c <_ZN6StringC1Eih>
 80a0a82:	a80c      	add	r0, sp, #48	; 0x30
 80a0a84:	f7ff ffa2 	bl	80a09cc <_Z13setBrightness6String>
 80a0a88:	a80c      	add	r0, sp, #48	; 0x30
 80a0a8a:	f001 feea 	bl	80a2862 <_ZN6StringD1Ev>
      Serial.println("Set brightness to "+String(newBrightness));
 80a0a8e:	f002 f969 	bl	80a2d64 <_Z16_fetch_usbserialv>

class StringSumHelper : public String
{
public:
	StringSumHelper(const String &s) : String(s) {}
	StringSumHelper(const char *p) : String(p) {}
 80a0a92:	4998      	ldr	r1, [pc, #608]	; (80a0cf4 <loop+0x2e0>)
 80a0a94:	9005      	str	r0, [sp, #20]
 80a0a96:	a80c      	add	r0, sp, #48	; 0x30
 80a0a98:	f001 ff2a 	bl	80a28f0 <_ZN6StringC1EPK19__FlashStringHelper>
 80a0a9c:	220a      	movs	r2, #10
 80a0a9e:	4649      	mov	r1, r9
 80a0aa0:	a808      	add	r0, sp, #32
 80a0aa2:	f001 ff63 	bl	80a296c <_ZN6StringC1Eih>
 80a0aa6:	a908      	add	r1, sp, #32
 80a0aa8:	a80c      	add	r0, sp, #48	; 0x30
 80a0aaa:	f001 ff9c 	bl	80a29e6 <_ZplRK15StringSumHelperRK6String>
 80a0aae:	9b05      	ldr	r3, [sp, #20]
 80a0ab0:	6801      	ldr	r1, [r0, #0]
 80a0ab2:	4618      	mov	r0, r3
 80a0ab4:	f001 fe61 	bl	80a277a <_ZN5Print7printlnEPKc>
 80a0ab8:	a808      	add	r0, sp, #32
 80a0aba:	f001 fed2 	bl	80a2862 <_ZN6StringD1Ev>

        friend class StringPrintableHelper;

};

class StringSumHelper : public String
 80a0abe:	a80c      	add	r0, sp, #48	; 0x30
 80a0ac0:	f001 fecf 	bl	80a2862 <_ZN6StringD1Ev>
      buttonPressed = false;
 80a0ac4:	2300      	movs	r3, #0
    if (buttonPressed && ((millis() - buttonTime) < doublePressTime)) {
      brightnessLevel++;
      if (brightnessLevel >= brightnessLevelsCount) {
        brightnessLevel = 0;
      }
      int newBrightness = brightnessLevelsArr[brightnessLevel];
 80a0ac6:	f8df a224 	ldr.w	sl, [pc, #548]	; 80a0cec <loop+0x2d8>
      setBrightness(String(newBrightness));
      Serial.println("Set brightness to "+String(newBrightness));
      buttonPressed = false;
 80a0aca:	702b      	strb	r3, [r5, #0]

      if (newBrightness == 0) {
 80a0acc:	f1b9 0f00 	cmp.w	r9, #0
 80a0ad0:	d167      	bne.n	80a0ba2 <loop+0x18e>
        Serial.println("Sleep");
 80a0ad2:	f002 f947 	bl	80a2d64 <_Z16_fetch_usbserialv>
 80a0ad6:	4988      	ldr	r1, [pc, #544]	; (80a0cf8 <loop+0x2e4>)
 80a0ad8:	f001 fe4f 	bl	80a277a <_ZN5Print7printlnEPKc>
        // turn off the LEDs
        FastLED.show();
 80a0adc:	4887      	ldr	r0, [pc, #540]	; (80a0cfc <loop+0x2e8>)
 80a0ade:	f7ff ff60 	bl	80a09a2 <_ZN9NSFastLED8CFastLED4showEv>
        // set wake up brightness
        brightnessLevel++;
 80a0ae2:	f8da 3000 	ldr.w	r3, [sl]
        if (brightnessLevel >= brightnessLevelsCount) {
 80a0ae6:	683a      	ldr	r2, [r7, #0]
      if (newBrightness == 0) {
        Serial.println("Sleep");
        // turn off the LEDs
        FastLED.show();
        // set wake up brightness
        brightnessLevel++;
 80a0ae8:	3301      	adds	r3, #1
        if (brightnessLevel >= brightnessLevelsCount) {
 80a0aea:	4293      	cmp	r3, r2
      if (newBrightness == 0) {
        Serial.println("Sleep");
        // turn off the LEDs
        FastLED.show();
        // set wake up brightness
        brightnessLevel++;
 80a0aec:	f8ca 3000 	str.w	r3, [sl]
        if (brightnessLevel >= brightnessLevelsCount) {
          brightnessLevel = 0;
 80a0af0:	bfa8      	it	ge
 80a0af2:	f8ca 9000 	strge.w	r9, [sl]
        }
        newBrightness = brightnessLevelsArr[brightnessLevel];
 80a0af6:	6823      	ldr	r3, [r4, #0]
        setBrightness(String(newBrightness));
 80a0af8:	220a      	movs	r2, #10
 80a0afa:	f858 1023 	ldr.w	r1, [r8, r3, lsl #2]
 80a0afe:	a80c      	add	r0, sp, #48	; 0x30
 80a0b00:	f001 ff34 	bl	80a296c <_ZN6StringC1Eih>
 80a0b04:	a80c      	add	r0, sp, #48	; 0x30
 80a0b06:	f7ff ff61 	bl	80a09cc <_Z13setBrightness6String>
 80a0b0a:	a80c      	add	r0, sp, #48	; 0x30
 80a0b0c:	f001 fea9 	bl	80a2862 <_ZN6StringD1Ev>
        delay(100);
 80a0b10:	2064      	movs	r0, #100	; 0x64
 80a0b12:	f001 fd41 	bl	80a2598 <delay>
 80a0b16:	4b7a      	ldr	r3, [pc, #488]	; (80a0d00 <loop+0x2ec>)
 80a0b18:	2201      	movs	r2, #1
 80a0b1a:	6819      	ldr	r1, [r3, #0]
 80a0b1c:	9b04      	ldr	r3, [sp, #16]
        return sleep(sleepMode, seconds, flag);
    }

    inline static SleepResult sleep(long seconds) { return sleep(SLEEP_MODE_WLAN, seconds); }
    inline static SleepResult sleep(uint16_t wakeUpPin, InterruptMode edgeTriggerMode, long seconds=0, SleepOptionFlags flag=SLEEP_NETWORK_OFF) {
        return sleepPinImpl(&wakeUpPin, 1, &edgeTriggerMode, 1, seconds, flag);
 80a0b1e:	a80c      	add	r0, sp, #48	; 0x30
 80a0b20:	681b      	ldr	r3, [r3, #0]
 80a0b22:	f8ad 3020 	strh.w	r3, [sp, #32]
 80a0b26:	ab10      	add	r3, sp, #64	; 0x40
 80a0b28:	f803 2d21 	strb.w	r2, [r3, #-33]!
 80a0b2c:	9102      	str	r1, [sp, #8]
 80a0b2e:	2100      	movs	r1, #0
 80a0b30:	9101      	str	r1, [sp, #4]
 80a0b32:	9200      	str	r2, [sp, #0]
 80a0b34:	a908      	add	r1, sp, #32
 80a0b36:	f001 ffe7 	bl	80a2b08 <_ZN11SystemClass12sleepPinImplEPKtjPK13InterruptModejlN8particle5FlagsI19SleepOptionFlagTypemEE>
      // start timer and cancel it if second press detected
      buttonTime = millis();
    }
  }

  if (buttonPressed && ((millis() - buttonTime) > doublePressTime)) {
 80a0b3a:	782b      	ldrb	r3, [r5, #0]
 80a0b3c:	2b00      	cmp	r3, #0
 80a0b3e:	d030      	beq.n	80a0ba2 <loop+0x18e>
 80a0b40:	f001 fbc2 	bl	80a22c8 <HAL_Timer_Get_Milli_Seconds>
 80a0b44:	4b67      	ldr	r3, [pc, #412]	; (80a0ce4 <loop+0x2d0>)
 80a0b46:	681b      	ldr	r3, [r3, #0]
 80a0b48:	1ac0      	subs	r0, r0, r3
 80a0b4a:	4b67      	ldr	r3, [pc, #412]	; (80a0ce8 <loop+0x2d4>)
 80a0b4c:	681b      	ldr	r3, [r3, #0]
 80a0b4e:	4298      	cmp	r0, r3
 80a0b50:	d927      	bls.n	80a0ba2 <loop+0x18e>
    // that's a single press 
    buttonPressed = false;
    patternIndex++;
 80a0b52:	4c6c      	ldr	r4, [pc, #432]	; (80a0d04 <loop+0x2f0>)
    if (patternIndex >= patternCount) {
 80a0b54:	496c      	ldr	r1, [pc, #432]	; (80a0d08 <loop+0x2f4>)
  }

  if (buttonPressed && ((millis() - buttonTime) > doublePressTime)) {
    // that's a single press 
    buttonPressed = false;
    patternIndex++;
 80a0b56:	6823      	ldr	r3, [r4, #0]
    if (patternIndex >= patternCount) {
 80a0b58:	6809      	ldr	r1, [r1, #0]
  }

  if (buttonPressed && ((millis() - buttonTime) > doublePressTime)) {
    // that's a single press 
    buttonPressed = false;
    patternIndex++;
 80a0b5a:	3301      	adds	r3, #1
    }
  }

  if (buttonPressed && ((millis() - buttonTime) > doublePressTime)) {
    // that's a single press 
    buttonPressed = false;
 80a0b5c:	2200      	movs	r2, #0
    patternIndex++;
    if (patternIndex >= patternCount) {
 80a0b5e:	428b      	cmp	r3, r1
    }
  }

  if (buttonPressed && ((millis() - buttonTime) > doublePressTime)) {
    // that's a single press 
    buttonPressed = false;
 80a0b60:	702a      	strb	r2, [r5, #0]
    patternIndex++;
 80a0b62:	6023      	str	r3, [r4, #0]
    if (patternIndex >= patternCount) {
 80a0b64:	db00      	blt.n	80a0b68 <loop+0x154>
        patternIndex = 0;
 80a0b66:	6022      	str	r2, [r4, #0]
    }
    EEPROM.write(1, patternIndex);
 80a0b68:	f002 faa8 	bl	80a30bc <_Z21__fetch_global_EEPROMv>
 80a0b6c:	7821      	ldrb	r1, [r4, #0]
 80a0b6e:	2001      	movs	r0, #1
 80a0b70:	f7ff fb38 	bl	80a01e4 <_ZN11EEPROMClass5writeEih.isra.3>
    Serial.println("Set Pattern to "+patterns[patternIndex].name);
 80a0b74:	f002 f8f6 	bl	80a2d64 <_Z16_fetch_usbserialv>
{
public:
	StringSumHelper(const String &s) : String(s) {}
	StringSumHelper(const char *p) : String(p) {}
 80a0b78:	4964      	ldr	r1, [pc, #400]	; (80a0d0c <loop+0x2f8>)
 80a0b7a:	4605      	mov	r5, r0
 80a0b7c:	a80c      	add	r0, sp, #48	; 0x30
 80a0b7e:	f001 feb7 	bl	80a28f0 <_ZN6StringC1EPK19__FlashStringHelper>
 80a0b82:	6823      	ldr	r3, [r4, #0]
 80a0b84:	4a62      	ldr	r2, [pc, #392]	; (80a0d10 <loop+0x2fc>)
 80a0b86:	2114      	movs	r1, #20
 80a0b88:	fb01 2103 	mla	r1, r1, r3, r2
 80a0b8c:	a80c      	add	r0, sp, #48	; 0x30
 80a0b8e:	3104      	adds	r1, #4
 80a0b90:	f001 ff29 	bl	80a29e6 <_ZplRK15StringSumHelperRK6String>
 80a0b94:	6801      	ldr	r1, [r0, #0]
 80a0b96:	4628      	mov	r0, r5
 80a0b98:	f001 fdef 	bl	80a277a <_ZN5Print7printlnEPKc>

        friend class StringPrintableHelper;

};

class StringSumHelper : public String
 80a0b9c:	a80c      	add	r0, sp, #48	; 0x30
 80a0b9e:	f001 fe60 	bl	80a2862 <_ZN6StringD1Ev>
  }

  lastButtonState = buttonState;
 80a0ba2:	6833      	ldr	r3, [r6, #0]
 80a0ba4:	f8cb 3000 	str.w	r3, [fp]

  if(power < 1) {
 80a0ba8:	4b5a      	ldr	r3, [pc, #360]	; (80a0d14 <loop+0x300>)
 80a0baa:	681b      	ldr	r3, [r3, #0]
 80a0bac:	2b00      	cmp	r3, #0
 80a0bae:	dc13      	bgt.n	80a0bd8 <loop+0x1c4>
    {
    }

    // allow construction from 32-bit (really 24-bit) bit 0xRRGGBB color code
    inline CRGB( uint32_t colorcode)  __attribute__((always_inline))
    : r((colorcode >> 16) & 0xFF), g((colorcode >> 8) & 0xFF), b((colorcode >> 0) & 0xFF)
 80a0bb0:	2300      	movs	r3, #0
    fill_solid(leds, NUM_LEDS, CRGB::Black);
 80a0bb2:	aa0c      	add	r2, sp, #48	; 0x30
 80a0bb4:	2196      	movs	r1, #150	; 0x96
 80a0bb6:	4858      	ldr	r0, [pc, #352]	; (80a0d18 <loop+0x304>)
 80a0bb8:	f88d 3030 	strb.w	r3, [sp, #48]	; 0x30
 80a0bbc:	f88d 3031 	strb.w	r3, [sp, #49]	; 0x31
 80a0bc0:	f88d 3032 	strb.w	r3, [sp, #50]	; 0x32
 80a0bc4:	f001 f911 	bl	80a1dea <_ZN9NSFastLED10fill_solidEPNS_4CRGBEiRKS0_>
    FastLED.show();
 80a0bc8:	484c      	ldr	r0, [pc, #304]	; (80a0cfc <loop+0x2e8>)
 80a0bca:	f7ff feea 	bl	80a09a2 <_ZN9NSFastLED8CFastLED4showEv>
    FastLED.delay(15);
 80a0bce:	210f      	movs	r1, #15
 80a0bd0:	484a      	ldr	r0, [pc, #296]	; (80a0cfc <loop+0x2e8>)
 80a0bd2:	f001 f8bf 	bl	80a1d54 <_ZN9NSFastLED8CFastLED5delayEm>
    return;
 80a0bd6:	e0bd      	b.n	80a0d54 <loop+0x340>
  }

  uint8_t delay = patterns[patternIndex].drawFrame();
 80a0bd8:	4b4a      	ldr	r3, [pc, #296]	; (80a0d04 <loop+0x2f0>)
 80a0bda:	681a      	ldr	r2, [r3, #0]
 80a0bdc:	2314      	movs	r3, #20
 80a0bde:	4353      	muls	r3, r2
 80a0be0:	4a4b      	ldr	r2, [pc, #300]	; (80a0d10 <loop+0x2fc>)
 80a0be2:	58d3      	ldr	r3, [r2, r3]
 80a0be4:	4798      	blx	r3
 80a0be6:	4604      	mov	r4, r0

  // send the 'leds' array out to the actual LED strip
  FastLED.show();
 80a0be8:	4844      	ldr	r0, [pc, #272]	; (80a0cfc <loop+0x2e8>)
 80a0bea:	f7ff feda 	bl	80a09a2 <_ZN9NSFastLED8CFastLED4showEv>

  // insert a delay to keep the framerate modest
  FastLED.delay(delay);
 80a0bee:	4621      	mov	r1, r4

  // blend the current palette to the next
  EVERY_N_MILLISECONDS(40) {
 80a0bf0:	4c4a      	ldr	r4, [pc, #296]	; (80a0d1c <loop+0x308>)

  // send the 'leds' array out to the actual LED strip
  FastLED.show();

  // insert a delay to keep the framerate modest
  FastLED.delay(delay);
 80a0bf2:	4842      	ldr	r0, [pc, #264]	; (80a0cfc <loop+0x2e8>)
 80a0bf4:	f001 f8ae 	bl	80a1d54 <_ZN9NSFastLED8CFastLED5delayEm>

  // blend the current palette to the next
  EVERY_N_MILLISECONDS(40) {
 80a0bf8:	6823      	ldr	r3, [r4, #0]
 80a0bfa:	07d9      	lsls	r1, r3, #31
 80a0bfc:	d40c      	bmi.n	80a0c18 <loop+0x204>
 80a0bfe:	4620      	mov	r0, r4
 80a0c00:	f7ff fa4d 	bl	80a009e <__cxa_guard_acquire>
 80a0c04:	b140      	cbz	r0, 80a0c18 <loop+0x204>
 80a0c06:	f001 fb5f 	bl	80a22c8 <HAL_Timer_Get_Milli_Seconds>
    void reset() { mPrevTrigger = getTime(); }; \
    void trigger() { mPrevTrigger = getTime() - mPeriod; }; \
        \
    operator bool() { return ready(); } \
};
INSTANTIATE_EVERY_N_TIME_PERIODS(CEveryNMillis,uint32_t,GET_MILLIS);
 80a0c0a:	4b45      	ldr	r3, [pc, #276]	; (80a0d20 <loop+0x30c>)
 80a0c0c:	2228      	movs	r2, #40	; 0x28
 80a0c0e:	6018      	str	r0, [r3, #0]
 80a0c10:	605a      	str	r2, [r3, #4]
 80a0c12:	4620      	mov	r0, r4
 80a0c14:	f7ff fa48 	bl	80a00a8 <__cxa_guard_release>
 80a0c18:	4841      	ldr	r0, [pc, #260]	; (80a0d20 <loop+0x30c>)
 80a0c1a:	f7ff fd33 	bl	80a0684 <_ZN9NSFastLED13CEveryNMillis5readyEv>
 80a0c1e:	b120      	cbz	r0, 80a0c2a <loop+0x216>
    nblendPaletteTowardPalette(currentPalette, targetPalette, 16);
 80a0c20:	2210      	movs	r2, #16
 80a0c22:	4940      	ldr	r1, [pc, #256]	; (80a0d24 <loop+0x310>)
 80a0c24:	4840      	ldr	r0, [pc, #256]	; (80a0d28 <loop+0x314>)
 80a0c26:	f001 fa3c 	bl	80a20a2 <_ZN9NSFastLED26nblendPaletteTowardPaletteERNS_13CRGBPalette16ES1_h>
  }

  EVERY_N_MILLISECONDS( 40 ) { gHue++; } // slowly cycle the "base color" through the rainbow
 80a0c2a:	4c40      	ldr	r4, [pc, #256]	; (80a0d2c <loop+0x318>)
 80a0c2c:	6823      	ldr	r3, [r4, #0]
 80a0c2e:	07da      	lsls	r2, r3, #31
 80a0c30:	d40c      	bmi.n	80a0c4c <loop+0x238>
 80a0c32:	4620      	mov	r0, r4
 80a0c34:	f7ff fa33 	bl	80a009e <__cxa_guard_acquire>
 80a0c38:	b140      	cbz	r0, 80a0c4c <loop+0x238>
 80a0c3a:	f001 fb45 	bl	80a22c8 <HAL_Timer_Get_Milli_Seconds>
 80a0c3e:	4b3c      	ldr	r3, [pc, #240]	; (80a0d30 <loop+0x31c>)
 80a0c40:	2228      	movs	r2, #40	; 0x28
 80a0c42:	6018      	str	r0, [r3, #0]
 80a0c44:	605a      	str	r2, [r3, #4]
 80a0c46:	4620      	mov	r0, r4
 80a0c48:	f7ff fa2e 	bl	80a00a8 <__cxa_guard_release>
 80a0c4c:	4838      	ldr	r0, [pc, #224]	; (80a0d30 <loop+0x31c>)
 80a0c4e:	f7ff fd19 	bl	80a0684 <_ZN9NSFastLED13CEveryNMillis5readyEv>
 80a0c52:	b118      	cbz	r0, 80a0c5c <loop+0x248>
 80a0c54:	4a37      	ldr	r2, [pc, #220]	; (80a0d34 <loop+0x320>)
 80a0c56:	7813      	ldrb	r3, [r2, #0]
 80a0c58:	3301      	adds	r3, #1
 80a0c5a:	7013      	strb	r3, [r2, #0]

  // slowly change to a new palette
  EVERY_N_SECONDS(SECONDS_PER_PALETTE) {
 80a0c5c:	4c36      	ldr	r4, [pc, #216]	; (80a0d38 <loop+0x324>)
 80a0c5e:	6823      	ldr	r3, [r4, #0]
 80a0c60:	07db      	lsls	r3, r3, #31
 80a0c62:	d410      	bmi.n	80a0c86 <loop+0x272>
 80a0c64:	4620      	mov	r0, r4
 80a0c66:	f7ff fa1a 	bl	80a009e <__cxa_guard_acquire>
 80a0c6a:	b160      	cbz	r0, 80a0c86 <loop+0x272>
 80a0c6c:	f001 fb2c 	bl	80a22c8 <HAL_Timer_Get_Milli_Seconds>
INSTANTIATE_EVERY_N_TIME_PERIODS(CEveryNSeconds,uint16_t,seconds16);
 80a0c70:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 80a0c74:	fbb0 f0f3 	udiv	r0, r0, r3
 80a0c78:	4a30      	ldr	r2, [pc, #192]	; (80a0d3c <loop+0x328>)
 80a0c7a:	2314      	movs	r3, #20
 80a0c7c:	8010      	strh	r0, [r2, #0]
 80a0c7e:	4620      	mov	r0, r4
 80a0c80:	8053      	strh	r3, [r2, #2]
 80a0c82:	f7ff fa11 	bl	80a00a8 <__cxa_guard_release>
 80a0c86:	482d      	ldr	r0, [pc, #180]	; (80a0d3c <loop+0x328>)
 80a0c88:	f7ff fd0d 	bl	80a06a6 <_ZN9NSFastLED14CEveryNSeconds5readyEv>
 80a0c8c:	2800      	cmp	r0, #0
 80a0c8e:	d061      	beq.n	80a0d54 <loop+0x340>
    paletteIndex++;
 80a0c90:	4b2b      	ldr	r3, [pc, #172]	; (80a0d40 <loop+0x32c>)
    if (paletteIndex >= paletteCount) paletteIndex = 0;
 80a0c92:	492c      	ldr	r1, [pc, #176]	; (80a0d44 <loop+0x330>)

  EVERY_N_MILLISECONDS( 40 ) { gHue++; } // slowly cycle the "base color" through the rainbow

  // slowly change to a new palette
  EVERY_N_SECONDS(SECONDS_PER_PALETTE) {
    paletteIndex++;
 80a0c94:	781a      	ldrb	r2, [r3, #0]
    if (paletteIndex >= paletteCount) paletteIndex = 0;
 80a0c96:	7809      	ldrb	r1, [r1, #0]

  EVERY_N_MILLISECONDS( 40 ) { gHue++; } // slowly cycle the "base color" through the rainbow

  // slowly change to a new palette
  EVERY_N_SECONDS(SECONDS_PER_PALETTE) {
    paletteIndex++;
 80a0c98:	3201      	adds	r2, #1
 80a0c9a:	b2d2      	uxtb	r2, r2
    if (paletteIndex >= paletteCount) paletteIndex = 0;
 80a0c9c:	4291      	cmp	r1, r2

  EVERY_N_MILLISECONDS( 40 ) { gHue++; } // slowly cycle the "base color" through the rainbow

  // slowly change to a new palette
  EVERY_N_SECONDS(SECONDS_PER_PALETTE) {
    paletteIndex++;
 80a0c9e:	701a      	strb	r2, [r3, #0]
    if (paletteIndex >= paletteCount) paletteIndex = 0;
 80a0ca0:	bf9c      	itt	ls
 80a0ca2:	2200      	movls	r2, #0
 80a0ca4:	701a      	strbls	r2, [r3, #0]
    {
        memmove8( &(entries[0]), &(rhs.entries[0]), sizeof( entries));
    }
    CRGBPalette16& operator=( const CRGBPalette16& rhs)
    {
        memmove8( &(entries[0]), &(rhs.entries[0]), sizeof( entries));
 80a0ca6:	781a      	ldrb	r2, [r3, #0]
 80a0ca8:	4b27      	ldr	r3, [pc, #156]	; (80a0d48 <loop+0x334>)
 80a0caa:	2130      	movs	r1, #48	; 0x30
 80a0cac:	fb01 3302 	mla	r3, r1, r2, r3
 80a0cb0:	4a1c      	ldr	r2, [pc, #112]	; (80a0d24 <loop+0x310>)
 80a0cb2:	1859      	adds	r1, r3, r1
 80a0cb4:	f853 0b04 	ldr.w	r0, [r3], #4
 80a0cb8:	428b      	cmp	r3, r1
 80a0cba:	f842 0b04 	str.w	r0, [r2], #4
 80a0cbe:	d1f9      	bne.n	80a0cb4 <loop+0x2a0>
 80a0cc0:	e048      	b.n	80a0d54 <loop+0x340>
        delay(100);
        // sleep and set to wake up with the button
        System.sleep(buttonPin,RISING); // TODO: change button to a pin that wakes up (D1, D2, D3, D4, A0, A1, A3, A4, A6, A7)
      }
      
    } else if (!buttonPressed) {
 80a0cc2:	782b      	ldrb	r3, [r5, #0]
 80a0cc4:	2b00      	cmp	r3, #0
 80a0cc6:	f47f af3b 	bne.w	80a0b40 <loop+0x12c>
      buttonPressed = true;
 80a0cca:	4b05      	ldr	r3, [pc, #20]	; (80a0ce0 <loop+0x2cc>)
 80a0ccc:	2201      	movs	r2, #1
 80a0cce:	701a      	strb	r2, [r3, #0]
 80a0cd0:	f001 fafa 	bl	80a22c8 <HAL_Timer_Get_Milli_Seconds>
      // start timer and cancel it if second press detected
      buttonTime = millis();
 80a0cd4:	6020      	str	r0, [r4, #0]
 80a0cd6:	e730      	b.n	80a0b3a <loop+0x126>
 80a0cd8:	20000334 	.word	0x20000334
 80a0cdc:	20000808 	.word	0x20000808
 80a0ce0:	200007d5 	.word	0x200007d5
 80a0ce4:	2000032c 	.word	0x2000032c
 80a0ce8:	2000030c 	.word	0x2000030c
 80a0cec:	20000798 	.word	0x20000798
 80a0cf0:	20000328 	.word	0x20000328
 80a0cf4:	080a3dec 	.word	0x080a3dec
 80a0cf8:	080a3dff 	.word	0x080a3dff
 80a0cfc:	20000bc8 	.word	0x20000bc8
 80a0d00:	20000bc0 	.word	0x20000bc0
 80a0d04:	20000790 	.word	0x20000790
 80a0d08:	20000338 	.word	0x20000338
 80a0d0c:	080a3e05 	.word	0x080a3e05
 80a0d10:	20000858 	.word	0x20000858
 80a0d14:	20000314 	.word	0x20000314
 80a0d18:	200005b7 	.word	0x200005b7
 80a0d1c:	20000784 	.word	0x20000784
 80a0d20:	2000080c 	.word	0x2000080c
 80a0d24:	20000814 	.word	0x20000814
 80a0d28:	20000942 	.word	0x20000942
 80a0d2c:	20000788 	.word	0x20000788
 80a0d30:	20000a08 	.word	0x20000a08
 80a0d34:	200005a9 	.word	0x200005a9
 80a0d38:	2000078c 	.word	0x2000078c
 80a0d3c:	200005b2 	.word	0x200005b2
 80a0d40:	20000794 	.word	0x20000794
 80a0d44:	20000301 	.word	0x20000301
 80a0d48:	20000a10 	.word	0x20000a10
 80a0d4c:	20000320 	.word	0x20000320
 80a0d50:	080a3dc0 	.word	0x080a3dc0
  EVERY_N_SECONDS(SECONDS_PER_PALETTE) {
    paletteIndex++;
    if (paletteIndex >= paletteCount) paletteIndex = 0;
    targetPalette = palettes[paletteIndex];
  };
}
 80a0d54:	b011      	add	sp, #68	; 0x44
 80a0d56:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80a0d5a:	bf00      	nop

080a0d5c <_Z8setColor6String>:

    return brightness;
}

int setColor(String args)
{
 80a0d5c:	b5f0      	push	{r4, r5, r6, r7, lr}
  char inputStr[12];
  args.toCharArray(inputStr, 12);

  char *p = strtok(inputStr, ",");
 80a0d5e:	4c22      	ldr	r4, [pc, #136]	; (80a0de8 <_Z8setColor6String+0x8c>)

    return brightness;
}

int setColor(String args)
{
 80a0d60:	b085      	sub	sp, #20
	void setCharAt(unsigned int index, char c);
	char operator [] (unsigned int index) const;
	char& operator [] (unsigned int index);
	void getBytes(unsigned char *buf, unsigned int bufsize, unsigned int index=0) const;
	void toCharArray(char *buf, unsigned int bufsize, unsigned int index=0) const
		{getBytes((unsigned char *)buf, bufsize, index);}
 80a0d62:	2300      	movs	r3, #0
 80a0d64:	220c      	movs	r2, #12
 80a0d66:	a901      	add	r1, sp, #4
 80a0d68:	f001 fe68 	bl	80a2a3c <_ZNK6String8getBytesEPhjj>
  char inputStr[12];
  args.toCharArray(inputStr, 12);

  char *p = strtok(inputStr, ",");
 80a0d6c:	4621      	mov	r1, r4
 80a0d6e:	a801      	add	r0, sp, #4
 80a0d70:	f002 ff1e 	bl	80a3bb0 <strtok>
  r = atoi(p);
 80a0d74:	f002 fe58 	bl	80a3a28 <atoi>
 80a0d78:	4f1c      	ldr	r7, [pc, #112]	; (80a0dec <_Z8setColor6String+0x90>)

  p = strtok(NULL,",");
 80a0d7a:	4621      	mov	r1, r4
{
  char inputStr[12];
  args.toCharArray(inputStr, 12);

  char *p = strtok(inputStr, ",");
  r = atoi(p);
 80a0d7c:	6038      	str	r0, [r7, #0]

  p = strtok(NULL,",");
 80a0d7e:	2000      	movs	r0, #0
 80a0d80:	f002 ff16 	bl	80a3bb0 <strtok>
  g = atoi(p);
 80a0d84:	f002 fe50 	bl	80a3a28 <atoi>
 80a0d88:	4e19      	ldr	r6, [pc, #100]	; (80a0df0 <_Z8setColor6String+0x94>)

  p = strtok(NULL,",");
 80a0d8a:	4621      	mov	r1, r4

  char *p = strtok(inputStr, ",");
  r = atoi(p);

  p = strtok(NULL,",");
  g = atoi(p);
 80a0d8c:	6030      	str	r0, [r6, #0]

  p = strtok(NULL,",");
 80a0d8e:	2000      	movs	r0, #0
 80a0d90:	f002 ff0e 	bl	80a3bb0 <strtok>
  b = atoi(p);
 80a0d94:	f002 fe48 	bl	80a3a28 <atoi>
 80a0d98:	4d16      	ldr	r5, [pc, #88]	; (80a0df4 <_Z8setColor6String+0x98>)

  p = strtok(NULL,",");
 80a0d9a:	4621      	mov	r1, r4

  p = strtok(NULL,",");
  g = atoi(p);

  p = strtok(NULL,",");
  b = atoi(p);
 80a0d9c:	6028      	str	r0, [r5, #0]

  p = strtok(NULL,",");
 80a0d9e:	2000      	movs	r0, #0
 80a0da0:	f002 ff06 	bl	80a3bb0 <strtok>

  solidColor.r = r;
 80a0da4:	4b14      	ldr	r3, [pc, #80]	; (80a0df8 <_Z8setColor6String+0x9c>)
 80a0da6:	683a      	ldr	r2, [r7, #0]
 80a0da8:	701a      	strb	r2, [r3, #0]
  solidColor.g = g;
 80a0daa:	6832      	ldr	r2, [r6, #0]
 80a0dac:	705a      	strb	r2, [r3, #1]
  solidColor.b = b;
 80a0dae:	682a      	ldr	r2, [r5, #0]
 80a0db0:	709a      	strb	r2, [r3, #2]

  patternIndex = patternCount - 1;
 80a0db2:	4b12      	ldr	r3, [pc, #72]	; (80a0dfc <_Z8setColor6String+0xa0>)
 80a0db4:	4a12      	ldr	r2, [pc, #72]	; (80a0e00 <_Z8setColor6String+0xa4>)
 80a0db6:	681b      	ldr	r3, [r3, #0]
 80a0db8:	3b01      	subs	r3, #1
 80a0dba:	6013      	str	r3, [r2, #0]

  EEPROM.write(2, r);
 80a0dbc:	f002 f97e 	bl	80a30bc <_Z21__fetch_global_EEPROMv>
 80a0dc0:	7839      	ldrb	r1, [r7, #0]
 80a0dc2:	2002      	movs	r0, #2
 80a0dc4:	f7ff fa0e 	bl	80a01e4 <_ZN11EEPROMClass5writeEih.isra.3>
  EEPROM.write(3, g);
 80a0dc8:	f002 f978 	bl	80a30bc <_Z21__fetch_global_EEPROMv>
 80a0dcc:	7831      	ldrb	r1, [r6, #0]
 80a0dce:	2003      	movs	r0, #3
 80a0dd0:	f7ff fa08 	bl	80a01e4 <_ZN11EEPROMClass5writeEih.isra.3>
  EEPROM.write(4, b);
 80a0dd4:	f002 f972 	bl	80a30bc <_Z21__fetch_global_EEPROMv>
 80a0dd8:	7829      	ldrb	r1, [r5, #0]
 80a0dda:	2004      	movs	r0, #4
 80a0ddc:	f7ff fa02 	bl	80a01e4 <_ZN11EEPROMClass5writeEih.isra.3>

  return 0;
}
 80a0de0:	2000      	movs	r0, #0
 80a0de2:	b005      	add	sp, #20
 80a0de4:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80a0de6:	bf00      	nop
 80a0de8:	080a3e15 	.word	0x080a3e15
 80a0dec:	200005a4 	.word	0x200005a4
 80a0df0:	200003dc 	.word	0x200003dc
 80a0df4:	20000330 	.word	0x20000330
 80a0df8:	20000780 	.word	0x20000780
 80a0dfc:	20000338 	.word	0x20000338
 80a0e00:	20000790 	.word	0x20000790

080a0e04 <_Z11setTimezone6String>:

int setTimezone(String args)
{
 80a0e04:	b510      	push	{r4, lr}
    timezone = args.toInt();
 80a0e06:	f001 fe60 	bl	80a2aca <_ZNK6String5toIntEv>
 80a0e0a:	4c15      	ldr	r4, [pc, #84]	; (80a0e60 <_Z11setTimezone6String+0x5c>)
    if(timezone < -12)
 80a0e0c:	f110 0f0c 	cmn.w	r0, #12
  return 0;
}

int setTimezone(String args)
{
    timezone = args.toInt();
 80a0e10:	6020      	str	r0, [r4, #0]
 80a0e12:	4b14      	ldr	r3, [pc, #80]	; (80a0e64 <_Z11setTimezone6String+0x60>)
    if(timezone < -12)
 80a0e14:	da02      	bge.n	80a0e1c <_Z11setTimezone6String+0x18>
        power = -12;
 80a0e16:	f06f 020b 	mvn.w	r2, #11
 80a0e1a:	e003      	b.n	80a0e24 <_Z11setTimezone6String+0x20>
    else if (power > 13)
 80a0e1c:	681a      	ldr	r2, [r3, #0]
 80a0e1e:	2a0d      	cmp	r2, #13
 80a0e20:	dd01      	ble.n	80a0e26 <_Z11setTimezone6String+0x22>
        power = 13;
 80a0e22:	220d      	movs	r2, #13
 80a0e24:	601a      	str	r2, [r3, #0]

    Time.zone(timezone);
 80a0e26:	f002 fbbf 	bl	80a35a8 <__aeabi_i2f>
 80a0e2a:	f001 feb3 	bl	80a2b94 <_ZN9TimeClass4zoneEf>

    if(timezone < 0)
 80a0e2e:	6823      	ldr	r3, [r4, #0]
 80a0e30:	2b00      	cmp	r3, #0
 80a0e32:	da03      	bge.n	80a0e3c <_Z11setTimezone6String+0x38>
        EEPROM.write(5, 0);
 80a0e34:	f002 f942 	bl	80a30bc <_Z21__fetch_global_EEPROMv>
 80a0e38:	2100      	movs	r1, #0
 80a0e3a:	e002      	b.n	80a0e42 <_Z11setTimezone6String+0x3e>
    else
        EEPROM.write(5, 1);
 80a0e3c:	f002 f93e 	bl	80a30bc <_Z21__fetch_global_EEPROMv>
 80a0e40:	2101      	movs	r1, #1
 80a0e42:	2005      	movs	r0, #5
 80a0e44:	f7ff f9ce 	bl	80a01e4 <_ZN11EEPROMClass5writeEih.isra.3>

    EEPROM.write(6, abs(timezone));
 80a0e48:	f002 f938 	bl	80a30bc <_Z21__fetch_global_EEPROMv>
 80a0e4c:	6821      	ldr	r1, [r4, #0]
 80a0e4e:	2006      	movs	r0, #6
 80a0e50:	2900      	cmp	r1, #0
 80a0e52:	bfb8      	it	lt
 80a0e54:	4249      	neglt	r1, r1
 80a0e56:	b2c9      	uxtb	r1, r1
 80a0e58:	f7ff f9c4 	bl	80a01e4 <_ZN11EEPROMClass5writeEih.isra.3>

    return timezone;
}
 80a0e5c:	6820      	ldr	r0, [r4, #0]
 80a0e5e:	bd10      	pop	{r4, pc}
 80a0e60:	2000031c 	.word	0x2000031c
 80a0e64:	20000314 	.word	0x20000314

080a0e68 <_Z12setFlipClock6String>:

int setFlipClock(String args) {
 80a0e68:	b510      	push	{r4, lr}
    flipClock = args.toInt();
 80a0e6a:	f001 fe2e 	bl	80a2aca <_ZNK6String5toIntEv>
    if(flipClock < 0)
 80a0e6e:	2800      	cmp	r0, #0
 80a0e70:	4c08      	ldr	r4, [pc, #32]	; (80a0e94 <_Z12setFlipClock6String+0x2c>)
 80a0e72:	da01      	bge.n	80a0e78 <_Z12setFlipClock6String+0x10>
        flipClock = 0;
 80a0e74:	2300      	movs	r3, #0
 80a0e76:	e004      	b.n	80a0e82 <_Z12setFlipClock6String+0x1a>
    else if (flipClock > 1)
 80a0e78:	2801      	cmp	r0, #1
 80a0e7a:	dc01      	bgt.n	80a0e80 <_Z12setFlipClock6String+0x18>

    return timezone;
}

int setFlipClock(String args) {
    flipClock = args.toInt();
 80a0e7c:	6020      	str	r0, [r4, #0]
 80a0e7e:	e001      	b.n	80a0e84 <_Z12setFlipClock6String+0x1c>
    if(flipClock < 0)
        flipClock = 0;
    else if (flipClock > 1)
        flipClock = 1;
 80a0e80:	2301      	movs	r3, #1
 80a0e82:	6023      	str	r3, [r4, #0]

    EEPROM.write(7, flipClock);
 80a0e84:	f002 f91a 	bl	80a30bc <_Z21__fetch_global_EEPROMv>
 80a0e88:	7821      	ldrb	r1, [r4, #0]
 80a0e8a:	2007      	movs	r0, #7
 80a0e8c:	f7ff f9aa 	bl	80a01e4 <_ZN11EEPROMClass5writeEih.isra.3>

    return flipClock;
}
 80a0e90:	6820      	ldr	r0, [r4, #0]
 80a0e92:	bd10      	pop	{r4, pc}
 80a0e94:	200005ac 	.word	0x200005ac

080a0e98 <_Z9parseByte6String>:

byte parseByte(String args) {
 80a0e98:	b508      	push	{r3, lr}
    int c = args.toInt();
 80a0e9a:	f001 fe16 	bl	80a2aca <_ZNK6String5toIntEv>
    if(c < 0)
        c = 0;
    else if (c > 255)
        c = 255;

    return c;
 80a0e9e:	f380 0008 	usat	r0, #8, r0
}
 80a0ea2:	b2c0      	uxtb	r0, r0
 80a0ea4:	bd08      	pop	{r3, pc}
	...

080a0ea8 <_Z11setVariable6String>:
    targetPalette = palettes[paletteIndex];
  };
}

int setVariable(String args)
{
 80a0ea8:	b530      	push	{r4, r5, lr}
 80a0eaa:	4604      	mov	r4, r0
 80a0eac:	b085      	sub	sp, #20
    if(args.startsWith("pwr:")) {
 80a0eae:	4972      	ldr	r1, [pc, #456]	; (80a1078 <_Z11setVariable6String+0x1d0>)
 80a0eb0:	4668      	mov	r0, sp
 80a0eb2:	f001 fd1d 	bl	80a28f0 <_ZN6StringC1EPK19__FlashStringHelper>
 80a0eb6:	4669      	mov	r1, sp
 80a0eb8:	4620      	mov	r0, r4
 80a0eba:	f001 fdb6 	bl	80a2a2a <_ZNK6String10startsWithERKS_>
 80a0ebe:	4605      	mov	r5, r0
 80a0ec0:	4668      	mov	r0, sp
 80a0ec2:	f001 fcce 	bl	80a2862 <_ZN6StringD1Ev>
 80a0ec6:	b145      	cbz	r5, 80a0eda <_Z11setVariable6String+0x32>
        return setPower(args.substring(4));
 80a0ec8:	4668      	mov	r0, sp
 80a0eca:	2204      	movs	r2, #4
 80a0ecc:	4621      	mov	r1, r4
 80a0ece:	f001 fdf5 	bl	80a2abc <_ZNK6String9substringEj>
 80a0ed2:	4668      	mov	r0, sp
 80a0ed4:	f7ff fd68 	bl	80a09a8 <_Z8setPower6String>
 80a0ed8:	e0c4      	b.n	80a1064 <_Z11setVariable6String+0x1bc>
    }
    else if (args.startsWith("brt:")) {
 80a0eda:	4968      	ldr	r1, [pc, #416]	; (80a107c <_Z11setVariable6String+0x1d4>)
 80a0edc:	4668      	mov	r0, sp
 80a0ede:	f001 fd07 	bl	80a28f0 <_ZN6StringC1EPK19__FlashStringHelper>
 80a0ee2:	4669      	mov	r1, sp
 80a0ee4:	4620      	mov	r0, r4
 80a0ee6:	f001 fda0 	bl	80a2a2a <_ZNK6String10startsWithERKS_>
 80a0eea:	4605      	mov	r5, r0
 80a0eec:	4668      	mov	r0, sp
 80a0eee:	f001 fcb8 	bl	80a2862 <_ZN6StringD1Ev>
 80a0ef2:	b145      	cbz	r5, 80a0f06 <_Z11setVariable6String+0x5e>
        return setBrightness(args.substring(4));
 80a0ef4:	4668      	mov	r0, sp
 80a0ef6:	2204      	movs	r2, #4
 80a0ef8:	4621      	mov	r1, r4
 80a0efa:	f001 fddf 	bl	80a2abc <_ZNK6String9substringEj>
 80a0efe:	4668      	mov	r0, sp
 80a0f00:	f7ff fd64 	bl	80a09cc <_Z13setBrightness6String>
 80a0f04:	e0ae      	b.n	80a1064 <_Z11setVariable6String+0x1bc>
    }
    else if (args.startsWith("r:")) {
 80a0f06:	495e      	ldr	r1, [pc, #376]	; (80a1080 <_Z11setVariable6String+0x1d8>)
 80a0f08:	4668      	mov	r0, sp
 80a0f0a:	f001 fcf1 	bl	80a28f0 <_ZN6StringC1EPK19__FlashStringHelper>
 80a0f0e:	4669      	mov	r1, sp
 80a0f10:	4620      	mov	r0, r4
 80a0f12:	f001 fd8a 	bl	80a2a2a <_ZNK6String10startsWithERKS_>
 80a0f16:	4605      	mov	r5, r0
 80a0f18:	4668      	mov	r0, sp
 80a0f1a:	f001 fca2 	bl	80a2862 <_ZN6StringD1Ev>
 80a0f1e:	b1a5      	cbz	r5, 80a0f4a <_Z11setVariable6String+0xa2>
        r = parseByte(args.substring(2));
 80a0f20:	4621      	mov	r1, r4
 80a0f22:	2202      	movs	r2, #2
 80a0f24:	4668      	mov	r0, sp
 80a0f26:	f001 fdc9 	bl	80a2abc <_ZNK6String9substringEj>
 80a0f2a:	4668      	mov	r0, sp
 80a0f2c:	f7ff ffb4 	bl	80a0e98 <_Z9parseByte6String>
 80a0f30:	4c54      	ldr	r4, [pc, #336]	; (80a1084 <_Z11setVariable6String+0x1dc>)
 80a0f32:	6020      	str	r0, [r4, #0]
 80a0f34:	4668      	mov	r0, sp
 80a0f36:	f001 fc94 	bl	80a2862 <_ZN6StringD1Ev>
        solidColor.r = r;
 80a0f3a:	6822      	ldr	r2, [r4, #0]
 80a0f3c:	4b52      	ldr	r3, [pc, #328]	; (80a1088 <_Z11setVariable6String+0x1e0>)
 80a0f3e:	701a      	strb	r2, [r3, #0]
        EEPROM.write(2, r);
 80a0f40:	f002 f8bc 	bl	80a30bc <_Z21__fetch_global_EEPROMv>
 80a0f44:	7821      	ldrb	r1, [r4, #0]
 80a0f46:	2002      	movs	r0, #2
 80a0f48:	e042      	b.n	80a0fd0 <_Z11setVariable6String+0x128>
        patternIndex = patternCount - 1;
        return r;
    }
    else if (args.startsWith("g:")) {
 80a0f4a:	4950      	ldr	r1, [pc, #320]	; (80a108c <_Z11setVariable6String+0x1e4>)
 80a0f4c:	4668      	mov	r0, sp
 80a0f4e:	f001 fccf 	bl	80a28f0 <_ZN6StringC1EPK19__FlashStringHelper>
 80a0f52:	4669      	mov	r1, sp
 80a0f54:	4620      	mov	r0, r4
 80a0f56:	f001 fd68 	bl	80a2a2a <_ZNK6String10startsWithERKS_>
 80a0f5a:	4605      	mov	r5, r0
 80a0f5c:	4668      	mov	r0, sp
 80a0f5e:	f001 fc80 	bl	80a2862 <_ZN6StringD1Ev>
 80a0f62:	b1a5      	cbz	r5, 80a0f8e <_Z11setVariable6String+0xe6>
        g = parseByte(args.substring(2));
 80a0f64:	4621      	mov	r1, r4
 80a0f66:	2202      	movs	r2, #2
 80a0f68:	4668      	mov	r0, sp
 80a0f6a:	f001 fda7 	bl	80a2abc <_ZNK6String9substringEj>
 80a0f6e:	4668      	mov	r0, sp
 80a0f70:	f7ff ff92 	bl	80a0e98 <_Z9parseByte6String>
 80a0f74:	4c46      	ldr	r4, [pc, #280]	; (80a1090 <_Z11setVariable6String+0x1e8>)
 80a0f76:	6020      	str	r0, [r4, #0]
 80a0f78:	4668      	mov	r0, sp
 80a0f7a:	f001 fc72 	bl	80a2862 <_ZN6StringD1Ev>
        solidColor.g = g;
 80a0f7e:	6822      	ldr	r2, [r4, #0]
 80a0f80:	4b41      	ldr	r3, [pc, #260]	; (80a1088 <_Z11setVariable6String+0x1e0>)
 80a0f82:	705a      	strb	r2, [r3, #1]
        EEPROM.write(3, g);
 80a0f84:	f002 f89a 	bl	80a30bc <_Z21__fetch_global_EEPROMv>
 80a0f88:	7821      	ldrb	r1, [r4, #0]
 80a0f8a:	2003      	movs	r0, #3
 80a0f8c:	e020      	b.n	80a0fd0 <_Z11setVariable6String+0x128>
        patternIndex = patternCount - 1;
        return g;
    }
    else if (args.startsWith("b:")) {
 80a0f8e:	4941      	ldr	r1, [pc, #260]	; (80a1094 <_Z11setVariable6String+0x1ec>)
 80a0f90:	4668      	mov	r0, sp
 80a0f92:	f001 fcad 	bl	80a28f0 <_ZN6StringC1EPK19__FlashStringHelper>
 80a0f96:	4669      	mov	r1, sp
 80a0f98:	4620      	mov	r0, r4
 80a0f9a:	f001 fd46 	bl	80a2a2a <_ZNK6String10startsWithERKS_>
 80a0f9e:	4605      	mov	r5, r0
 80a0fa0:	4668      	mov	r0, sp
 80a0fa2:	f001 fc5e 	bl	80a2862 <_ZN6StringD1Ev>
 80a0fa6:	b1e5      	cbz	r5, 80a0fe2 <_Z11setVariable6String+0x13a>
        b = parseByte(args.substring(2));
 80a0fa8:	4621      	mov	r1, r4
 80a0faa:	2202      	movs	r2, #2
 80a0fac:	4668      	mov	r0, sp
 80a0fae:	f001 fd85 	bl	80a2abc <_ZNK6String9substringEj>
 80a0fb2:	4668      	mov	r0, sp
 80a0fb4:	f7ff ff70 	bl	80a0e98 <_Z9parseByte6String>
 80a0fb8:	4c37      	ldr	r4, [pc, #220]	; (80a1098 <_Z11setVariable6String+0x1f0>)
 80a0fba:	6020      	str	r0, [r4, #0]
 80a0fbc:	4668      	mov	r0, sp
 80a0fbe:	f001 fc50 	bl	80a2862 <_ZN6StringD1Ev>
        solidColor.b = b;
 80a0fc2:	6822      	ldr	r2, [r4, #0]
 80a0fc4:	4b30      	ldr	r3, [pc, #192]	; (80a1088 <_Z11setVariable6String+0x1e0>)
 80a0fc6:	709a      	strb	r2, [r3, #2]
        EEPROM.write(4, b);
 80a0fc8:	f002 f878 	bl	80a30bc <_Z21__fetch_global_EEPROMv>
 80a0fcc:	7821      	ldrb	r1, [r4, #0]
 80a0fce:	2004      	movs	r0, #4
 80a0fd0:	f7ff f908 	bl	80a01e4 <_ZN11EEPROMClass5writeEih.isra.3>
        patternIndex = patternCount - 1;
 80a0fd4:	4b31      	ldr	r3, [pc, #196]	; (80a109c <_Z11setVariable6String+0x1f4>)
 80a0fd6:	4a32      	ldr	r2, [pc, #200]	; (80a10a0 <_Z11setVariable6String+0x1f8>)
 80a0fd8:	681b      	ldr	r3, [r3, #0]
 80a0fda:	3b01      	subs	r3, #1
 80a0fdc:	6013      	str	r3, [r2, #0]
        return b;
 80a0fde:	6824      	ldr	r4, [r4, #0]
 80a0fe0:	e047      	b.n	80a1072 <_Z11setVariable6String+0x1ca>
    }
    else if (args.startsWith("c:")) { // c:255,255,255
 80a0fe2:	4930      	ldr	r1, [pc, #192]	; (80a10a4 <_Z11setVariable6String+0x1fc>)
 80a0fe4:	4668      	mov	r0, sp
 80a0fe6:	f001 fc83 	bl	80a28f0 <_ZN6StringC1EPK19__FlashStringHelper>
 80a0fea:	4669      	mov	r1, sp
 80a0fec:	4620      	mov	r0, r4
 80a0fee:	f001 fd1c 	bl	80a2a2a <_ZNK6String10startsWithERKS_>
 80a0ff2:	4605      	mov	r5, r0
 80a0ff4:	4668      	mov	r0, sp
 80a0ff6:	f001 fc34 	bl	80a2862 <_ZN6StringD1Ev>
 80a0ffa:	b145      	cbz	r5, 80a100e <_Z11setVariable6String+0x166>
      return setColor(args.substring(2));
 80a0ffc:	4668      	mov	r0, sp
 80a0ffe:	2202      	movs	r2, #2
 80a1000:	4621      	mov	r1, r4
 80a1002:	f001 fd5b 	bl	80a2abc <_ZNK6String9substringEj>
 80a1006:	4668      	mov	r0, sp
 80a1008:	f7ff fea8 	bl	80a0d5c <_Z8setColor6String>
 80a100c:	e02a      	b.n	80a1064 <_Z11setVariable6String+0x1bc>
    }
    else if (args.startsWith("tz:")) {
 80a100e:	4926      	ldr	r1, [pc, #152]	; (80a10a8 <_Z11setVariable6String+0x200>)
 80a1010:	4668      	mov	r0, sp
 80a1012:	f001 fc6d 	bl	80a28f0 <_ZN6StringC1EPK19__FlashStringHelper>
 80a1016:	4669      	mov	r1, sp
 80a1018:	4620      	mov	r0, r4
 80a101a:	f001 fd06 	bl	80a2a2a <_ZNK6String10startsWithERKS_>
 80a101e:	4605      	mov	r5, r0
 80a1020:	4668      	mov	r0, sp
 80a1022:	f001 fc1e 	bl	80a2862 <_ZN6StringD1Ev>
 80a1026:	b145      	cbz	r5, 80a103a <_Z11setVariable6String+0x192>
        return setTimezone(args.substring(3));
 80a1028:	4668      	mov	r0, sp
 80a102a:	2203      	movs	r2, #3
 80a102c:	4621      	mov	r1, r4
 80a102e:	f001 fd45 	bl	80a2abc <_ZNK6String9substringEj>
 80a1032:	4668      	mov	r0, sp
 80a1034:	f7ff fee6 	bl	80a0e04 <_Z11setTimezone6String>
 80a1038:	e014      	b.n	80a1064 <_Z11setVariable6String+0x1bc>
    }
    else if (args.startsWith("flpclk:")) {
 80a103a:	491c      	ldr	r1, [pc, #112]	; (80a10ac <_Z11setVariable6String+0x204>)
 80a103c:	4668      	mov	r0, sp
 80a103e:	f001 fc57 	bl	80a28f0 <_ZN6StringC1EPK19__FlashStringHelper>
 80a1042:	4669      	mov	r1, sp
 80a1044:	4620      	mov	r0, r4
 80a1046:	f001 fcf0 	bl	80a2a2a <_ZNK6String10startsWithERKS_>
 80a104a:	4605      	mov	r5, r0
 80a104c:	4668      	mov	r0, sp
 80a104e:	f001 fc08 	bl	80a2862 <_ZN6StringD1Ev>
 80a1052:	b165      	cbz	r5, 80a106e <_Z11setVariable6String+0x1c6>
        return setFlipClock(args.substring(7));
 80a1054:	4668      	mov	r0, sp
 80a1056:	2207      	movs	r2, #7
 80a1058:	4621      	mov	r1, r4
 80a105a:	f001 fd2f 	bl	80a2abc <_ZNK6String9substringEj>
 80a105e:	4668      	mov	r0, sp
 80a1060:	f7ff ff02 	bl	80a0e68 <_Z12setFlipClock6String>
 80a1064:	4604      	mov	r4, r0
 80a1066:	4668      	mov	r0, sp
 80a1068:	f001 fbfb 	bl	80a2862 <_ZN6StringD1Ev>
 80a106c:	e001      	b.n	80a1072 <_Z11setVariable6String+0x1ca>
    }

    return -1;
 80a106e:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
}
 80a1072:	4620      	mov	r0, r4
 80a1074:	b005      	add	sp, #20
 80a1076:	bd30      	pop	{r4, r5, pc}
 80a1078:	080a3e17 	.word	0x080a3e17
 80a107c:	080a3e1c 	.word	0x080a3e1c
 80a1080:	080a3e19 	.word	0x080a3e19
 80a1084:	200005a4 	.word	0x200005a4
 80a1088:	20000780 	.word	0x20000780
 80a108c:	080a3e21 	.word	0x080a3e21
 80a1090:	200003dc 	.word	0x200003dc
 80a1094:	080a3e24 	.word	0x080a3e24
 80a1098:	20000330 	.word	0x20000330
 80a109c:	20000338 	.word	0x20000338
 80a10a0:	20000790 	.word	0x20000790
 80a10a4:	080a3e27 	.word	0x080a3e27
 80a10a8:	080a3e2a 	.word	0x080a3e2a
 80a10ac:	080a3e2e 	.word	0x080a3e2e

080a10b0 <_Z7heatMapN9NSFastLED13CRGBPalette16Eb>:

  return 8;
}

void heatMap(CRGBPalette16 palette, bool up)
{
 80a10b0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80a10b4:	b087      	sub	sp, #28
 80a10b6:	2400      	movs	r4, #0
    fill_solid(leds, NUM_LEDS, CRGB::Black);
 80a10b8:	aa05      	add	r2, sp, #20

  return 8;
}

void heatMap(CRGBPalette16 palette, bool up)
{
 80a10ba:	9103      	str	r1, [sp, #12]
 80a10bc:	4683      	mov	fp, r0
    fill_solid(leds, NUM_LEDS, CRGB::Black);
 80a10be:	2196      	movs	r1, #150	; 0x96
 80a10c0:	4846      	ldr	r0, [pc, #280]	; (80a11dc <_Z7heatMapN9NSFastLED13CRGBPalette16Eb+0x12c>)
 80a10c2:	f88d 4014 	strb.w	r4, [sp, #20]
 80a10c6:	f88d 4015 	strb.w	r4, [sp, #21]
 80a10ca:	f88d 4016 	strb.w	r4, [sp, #22]
 80a10ce:	f000 fe8c 	bl	80a1dea <_ZN9NSFastLED10fill_solidEPNS_4CRGBEiRKS0_>

    // Add entropy to random number generator; we use a lot of it.
    random16_add_entropy(random(256));
 80a10d2:	f44f 7080 	mov.w	r0, #256	; 0x100
 80a10d6:	f001 fb86 	bl	80a27e6 <_Z6randomi>
    return rand16seed;
}

LIB8STATIC void random16_add_entropy( uint16_t entropy)
{
    rand16seed += entropy;
 80a10da:	4a41      	ldr	r2, [pc, #260]	; (80a11e0 <_Z7heatMapN9NSFastLED13CRGBPalette16Eb+0x130>)
 80a10dc:	4f41      	ldr	r7, [pc, #260]	; (80a11e4 <_Z7heatMapN9NSFastLED13CRGBPalette16Eb+0x134>)
 80a10de:	8813      	ldrh	r3, [r2, #0]
 80a10e0:	f04f 094b 	mov.w	r9, #75	; 0x4b
 80a10e4:	4418      	add	r0, r3
 80a10e6:	8010      	strh	r0, [r2, #0]
        for( int i = 0; i < halfLedCount; i++) {
          heat[x][i] = qsub8( heat[x][i],  random8(0, ((cooling * 10) / halfLedCount) + 2));
        }

        // Step 2.  Heat from each cell drifts 'up' and diffuses a little
        for( int k= halfLedCount - 1; k >= 2; k--) {
 80a10e8:	f107 0a01 	add.w	sl, r7, #1
 80a10ec:	463d      	mov	r5, r7
 80a10ee:	f107 084b 	add.w	r8, r7, #75	; 0x4b
    byte colorindex;

    for(uint8_t x = 0; x < 2; x++) {
        // Step 1.  Cool down every cell a little
        for( int i = 0; i < halfLedCount; i++) {
          heat[x][i] = qsub8( heat[x][i],  random8(0, ((cooling * 10) / halfLedCount) + 2));
 80a10f2:	f815 1f01 	ldrb.w	r1, [r5, #1]!
}


LIB8STATIC uint8_t random8(uint8_t lim)
{
    uint8_t r = random8();
 80a10f6:	f7fe ffdd 	bl	80a00b4 <_ZN9NSFastLEDL7random8Ev>

// qsub8: subtract one byte from another, saturating at 0x00
LIB8STATIC uint8_t qsub8( uint8_t i, uint8_t j)
{
#if QSUB8_C == 1
    int t = i - j;
 80a10fa:	eb00 00c0 	add.w	r0, r0, r0, lsl #3
 80a10fe:	eba1 2120 	sub.w	r1, r1, r0, asr #8
 80a1102:	ea21 71e1 	bic.w	r1, r1, r1, asr #31

    byte colorindex;

    for(uint8_t x = 0; x < 2; x++) {
        // Step 1.  Cool down every cell a little
        for( int i = 0; i < halfLedCount; i++) {
 80a1106:	4545      	cmp	r5, r8
          heat[x][i] = qsub8( heat[x][i],  random8(0, ((cooling * 10) / halfLedCount) + 2));
 80a1108:	7029      	strb	r1, [r5, #0]

    byte colorindex;

    for(uint8_t x = 0; x < 2; x++) {
        // Step 1.  Cool down every cell a little
        for( int i = 0; i < halfLedCount; i++) {
 80a110a:	d1f2      	bne.n	80a10f2 <_Z7heatMapN9NSFastLED13CRGBPalette16Eb+0x42>
          heat[x][i] = qsub8( heat[x][i],  random8(0, ((cooling * 10) / halfLedCount) + 2));
        }

        // Step 2.  Heat from each cell drifts 'up' and diffuses a little
        for( int k= halfLedCount - 1; k >= 2; k--) {
 80a110c:	fb09 a104 	mla	r1, r9, r4, sl
 80a1110:	f107 034a 	add.w	r3, r7, #74	; 0x4a
          heat[x][k] = (heat[x][k - 1] + heat[x][k - 2] + heat[x][k - 2] ) / 3;
 80a1114:	2003      	movs	r0, #3
 80a1116:	781a      	ldrb	r2, [r3, #0]
 80a1118:	f813 5d01 	ldrb.w	r5, [r3, #-1]!
 80a111c:	eb02 0245 	add.w	r2, r2, r5, lsl #1
 80a1120:	fb92 f2f0 	sdiv	r2, r2, r0
        for( int i = 0; i < halfLedCount; i++) {
          heat[x][i] = qsub8( heat[x][i],  random8(0, ((cooling * 10) / halfLedCount) + 2));
        }

        // Step 2.  Heat from each cell drifts 'up' and diffuses a little
        for( int k= halfLedCount - 1; k >= 2; k--) {
 80a1124:	428b      	cmp	r3, r1
          heat[x][k] = (heat[x][k - 1] + heat[x][k - 2] + heat[x][k - 2] ) / 3;
 80a1126:	709a      	strb	r2, [r3, #2]
        for( int i = 0; i < halfLedCount; i++) {
          heat[x][i] = qsub8( heat[x][i],  random8(0, ((cooling * 10) / halfLedCount) + 2));
        }

        // Step 2.  Heat from each cell drifts 'up' and diffuses a little
        for( int k= halfLedCount - 1; k >= 2; k--) {
 80a1128:	d1f5      	bne.n	80a1116 <_Z7heatMapN9NSFastLED13CRGBPalette16Eb+0x66>
          heat[x][k] = (heat[x][k - 1] + heat[x][k - 2] + heat[x][k - 2] ) / 3;
        }

        // Step 3.  Randomly ignite new 'sparks' of heat near the bottom
        if( random8() < sparking ) {
 80a112a:	f7fe ffc3 	bl	80a00b4 <_ZN9NSFastLEDL7random8Ev>
 80a112e:	2877      	cmp	r0, #119	; 0x77
 80a1130:	d814      	bhi.n	80a115c <_Z7heatMapN9NSFastLED13CRGBPalette16Eb+0xac>
}


LIB8STATIC uint8_t random8(uint8_t lim)
{
    uint8_t r = random8();
 80a1132:	f7fe ffbf 	bl	80a00b4 <_ZN9NSFastLEDL7random8Ev>
          int y = random8(7);
          heat[x][y] = qadd8( heat[x][y], random8(160,255) );
 80a1136:	4b2c      	ldr	r3, [pc, #176]	; (80a11e8 <_Z7heatMapN9NSFastLED13CRGBPalette16Eb+0x138>)
//         In other words, it computes i * (scale / 256)
//         4 clocks AVR with MUL, 2 clocks ARM
LIB8STATIC uint8_t scale8( uint8_t i, fract8 scale)
{
#if SCALE8_C == 1
    return ((uint16_t)i * (uint16_t)(scale) ) >> 8;
 80a1138:	ebc0 00c0 	rsb	r0, r0, r0, lsl #3
 80a113c:	fb09 3604 	mla	r6, r9, r4, r3
 80a1140:	1205      	asrs	r5, r0, #8
 80a1142:	5d71      	ldrb	r1, [r6, r5]
}


LIB8STATIC uint8_t random8(uint8_t lim)
{
    uint8_t r = random8();
 80a1144:	f7fe ffb6 	bl	80a00b4 <_ZN9NSFastLEDL7random8Ev>

// qadd8: add one byte to another, saturating at 0xFF
LIB8STATIC uint8_t qadd8( uint8_t i, uint8_t j)
{
#if QADD8_C == 1
    unsigned int t = i + j;
 80a1148:	235f      	movs	r3, #95	; 0x5f
 80a114a:	4358      	muls	r0, r3
 80a114c:	1203      	asrs	r3, r0, #8
 80a114e:	3b60      	subs	r3, #96	; 0x60
 80a1150:	b2db      	uxtb	r3, r3
 80a1152:	4419      	add	r1, r3
 80a1154:	29ff      	cmp	r1, #255	; 0xff
 80a1156:	bfa8      	it	ge
 80a1158:	21ff      	movge	r1, #255	; 0xff
 80a115a:	5571      	strb	r1, [r6, r5]
 80a115c:	4d23      	ldr	r5, [pc, #140]	; (80a11ec <_Z7heatMapN9NSFastLED13CRGBPalette16Eb+0x13c>)
 80a115e:	1e6e      	subs	r6, r5, #1
        for( int j = 0; j < halfLedCount; j++) {
            // Scale the heat value from 0-255 down to 0-240
            // for best results with color palettes.
            colorindex = scale8(heat[x][j], 240);

            CRGB color = ColorFromPalette(palette, colorindex);
 80a1160:	f817 2f01 	ldrb.w	r2, [r7, #1]!
 80a1164:	23f0      	movs	r3, #240	; 0xf0
 80a1166:	435a      	muls	r2, r3
 80a1168:	2301      	movs	r3, #1
 80a116a:	9300      	str	r3, [sp, #0]
 80a116c:	f3c2 2207 	ubfx	r2, r2, #8, #8
 80a1170:	23ff      	movs	r3, #255	; 0xff
 80a1172:	4659      	mov	r1, fp
 80a1174:	a805      	add	r0, sp, #20
 80a1176:	f000 ff43 	bl	80a2000 <_ZN9NSFastLED16ColorFromPaletteERKNS_13CRGBPalette16EhhNS_10TBlendTypeE>

            if(up) {
 80a117a:	9803      	ldr	r0, [sp, #12]
 80a117c:	f89d 1014 	ldrb.w	r1, [sp, #20]
 80a1180:	f89d 2015 	ldrb.w	r2, [sp, #21]
 80a1184:	f89d 3016 	ldrb.w	r3, [sp, #22]
 80a1188:	b170      	cbz	r0, 80a11a8 <_Z7heatMapN9NSFastLED13CRGBPalette16Eb+0xf8>
                if(x == 0) {
 80a118a:	b934      	cbnz	r4, 80a119a <_Z7heatMapN9NSFastLED13CRGBPalette16Eb+0xea>
    }

    // allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
 80a118c:	f886 10de 	strb.w	r1, [r6, #222]	; 0xde
        g = rhs.g;
 80a1190:	f886 20df 	strb.w	r2, [r6, #223]	; 0xdf
        b = rhs.b;
 80a1194:	f886 30e0 	strb.w	r3, [r6, #224]	; 0xe0
 80a1198:	e012      	b.n	80a11c0 <_Z7heatMapN9NSFastLED13CRGBPalette16Eb+0x110>
    }

    // allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
 80a119a:	f885 10e0 	strb.w	r1, [r5, #224]	; 0xe0
        g = rhs.g;
 80a119e:	f885 20e1 	strb.w	r2, [r5, #225]	; 0xe1
        b = rhs.b;
 80a11a2:	f885 30e2 	strb.w	r3, [r5, #226]	; 0xe2
 80a11a6:	e00b      	b.n	80a11c0 <_Z7heatMapN9NSFastLED13CRGBPalette16Eb+0x110>
                else {
                    leds[halfLedCount + j] = color;
                }
            }
            else {
                if(x == 0) {
 80a11a8:	b924      	cbnz	r4, 80a11b4 <_Z7heatMapN9NSFastLED13CRGBPalette16Eb+0x104>
    }

    // allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
 80a11aa:	f805 1c01 	strb.w	r1, [r5, #-1]
        g = rhs.g;
 80a11ae:	702a      	strb	r2, [r5, #0]
        b = rhs.b;
 80a11b0:	706b      	strb	r3, [r5, #1]
 80a11b2:	e005      	b.n	80a11c0 <_Z7heatMapN9NSFastLED13CRGBPalette16Eb+0x110>
    }

    // allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
 80a11b4:	f886 11bf 	strb.w	r1, [r6, #447]	; 0x1bf
        g = rhs.g;
 80a11b8:	f886 21c0 	strb.w	r2, [r6, #448]	; 0x1c0
        b = rhs.b;
 80a11bc:	f886 31c1 	strb.w	r3, [r6, #449]	; 0x1c1
          int y = random8(7);
          heat[x][y] = qadd8( heat[x][y], random8(160,255) );
        }

        // Step 4.  Map from heat cells to LED colors
        for( int j = 0; j < halfLedCount; j++) {
 80a11c0:	4b0b      	ldr	r3, [pc, #44]	; (80a11f0 <_Z7heatMapN9NSFastLED13CRGBPalette16Eb+0x140>)
 80a11c2:	3503      	adds	r5, #3
 80a11c4:	42ab      	cmp	r3, r5
 80a11c6:	f1a6 0603 	sub.w	r6, r6, #3
 80a11ca:	d1c9      	bne.n	80a1160 <_Z7heatMapN9NSFastLED13CRGBPalette16Eb+0xb0>
 80a11cc:	3401      	adds	r4, #1
    static const uint8_t halfLedCount = NUM_LEDS / 2;
    static byte heat[2][halfLedCount];

    byte colorindex;

    for(uint8_t x = 0; x < 2; x++) {
 80a11ce:	2c02      	cmp	r4, #2
 80a11d0:	4647      	mov	r7, r8
 80a11d2:	d18b      	bne.n	80a10ec <_Z7heatMapN9NSFastLED13CRGBPalette16Eb+0x3c>
                    leds[(NUM_LEDS - 1) - j] = color;
                }
            }
        }
    }
}
 80a11d4:	b007      	add	sp, #28
 80a11d6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80a11da:	bf00      	nop
 80a11dc:	200005b7 	.word	0x200005b7
 80a11e0:	2000033c 	.word	0x2000033c
 80a11e4:	20000971 	.word	0x20000971
 80a11e8:	20000972 	.word	0x20000972
 80a11ec:	200005b8 	.word	0x200005b8
 80a11f0:	20000699 	.word	0x20000699

080a11f4 <_Z4firev>:

  return 0;
}

uint8_t fire()
{
 80a11f4:	b500      	push	{lr}
 80a11f6:	b08d      	sub	sp, #52	; 0x34
    heatMap(HeatColors_p, true);
 80a11f8:	4905      	ldr	r1, [pc, #20]	; (80a1210 <_Z4firev+0x1c>)
 80a11fa:	4668      	mov	r0, sp
 80a11fc:	f7ff fb66 	bl	80a08cc <_ZN9NSFastLED13CRGBPalette16C1ERA16_Km>
 80a1200:	4668      	mov	r0, sp
 80a1202:	2101      	movs	r1, #1
 80a1204:	f7ff ff54 	bl	80a10b0 <_Z7heatMapN9NSFastLED13CRGBPalette16Eb>

    return 30;
}
 80a1208:	201e      	movs	r0, #30
 80a120a:	b00d      	add	sp, #52	; 0x34
 80a120c:	f85d fb04 	ldr.w	pc, [sp], #4
 80a1210:	080a4008 	.word	0x080a4008

080a1214 <_Z5waterv>:

uint8_t water()
{
 80a1214:	b530      	push	{r4, r5, lr}
 80a1216:	b08d      	sub	sp, #52	; 0x34
        entries[12]=c12; entries[13]=c13; entries[14]=c14; entries[15]=c15;
    };

    CRGBPalette16( const CRGBPalette16& rhs)
    {
        memmove8( &(entries[0]), &(rhs.entries[0]), sizeof( entries));
 80a1218:	466c      	mov	r4, sp
 80a121a:	4b09      	ldr	r3, [pc, #36]	; (80a1240 <_Z5waterv+0x2c>)
 80a121c:	f103 0530 	add.w	r5, r3, #48	; 0x30
 80a1220:	4622      	mov	r2, r4
 80a1222:	6818      	ldr	r0, [r3, #0]
 80a1224:	6859      	ldr	r1, [r3, #4]
 80a1226:	3308      	adds	r3, #8
 80a1228:	c203      	stmia	r2!, {r0, r1}
 80a122a:	42ab      	cmp	r3, r5
 80a122c:	4614      	mov	r4, r2
 80a122e:	d1f7      	bne.n	80a1220 <_Z5waterv+0xc>
    heatMap(IceColors_p, false);
 80a1230:	4668      	mov	r0, sp
 80a1232:	2100      	movs	r1, #0
 80a1234:	f7ff ff3c 	bl	80a10b0 <_Z7heatMapN9NSFastLED13CRGBPalette16Eb>

    return 30;
}
 80a1238:	201e      	movs	r0, #30
 80a123a:	b00d      	add	sp, #52	; 0x34
 80a123c:	bd30      	pop	{r4, r5, pc}
 80a123e:	bf00      	nop
 80a1240:	200007d6 	.word	0x200007d6

080a1244 <_Z10addGlitterh>:
    leds[i].nscale8(value);
  }
}

void addGlitter( uint8_t chanceOfGlitter)
{
 80a1244:	b507      	push	{r0, r1, r2, lr}
 80a1246:	4601      	mov	r1, r0
  if( random8() < chanceOfGlitter) {
 80a1248:	f7fe ff34 	bl	80a00b4 <_ZN9NSFastLEDL7random8Ev>
 80a124c:	4288      	cmp	r0, r1
 80a124e:	d21b      	bcs.n	80a1288 <_Z10addGlitterh+0x44>
                     ((uint8_t)(rand16seed >> 8)));
}

LIB8STATIC uint16_t random16()
{
    rand16seed = (rand16seed * RAND16_2053) + RAND16_13849;
 80a1250:	4a0f      	ldr	r2, [pc, #60]	; (80a1290 <_Z10addGlitterh+0x4c>)
    leds[ random16(NUM_LEDS) ] += CRGB::White;
 80a1252:	2096      	movs	r0, #150	; 0x96
 80a1254:	8813      	ldrh	r3, [r2, #0]
 80a1256:	eb03 2143 	add.w	r1, r3, r3, lsl #9
 80a125a:	eb03 0381 	add.w	r3, r3, r1, lsl #2
 80a125e:	f503 5358 	add.w	r3, r3, #13824	; 0x3600
 80a1262:	3319      	adds	r3, #25
 80a1264:	b29b      	uxth	r3, r3
 80a1266:	8013      	strh	r3, [r2, #0]
 80a1268:	4343      	muls	r3, r0
 80a126a:	480a      	ldr	r0, [pc, #40]	; (80a1294 <_Z10addGlitterh+0x50>)
 80a126c:	0c1b      	lsrs	r3, r3, #16
 80a126e:	eb03 0343 	add.w	r3, r3, r3, lsl #1
    {
    }

    // allow construction from 32-bit (really 24-bit) bit 0xRRGGBB color code
    inline CRGB( uint32_t colorcode)  __attribute__((always_inline))
    : r((colorcode >> 16) & 0xFF), g((colorcode >> 8) & 0xFF), b((colorcode >> 0) & 0xFF)
 80a1272:	22ff      	movs	r2, #255	; 0xff
 80a1274:	a901      	add	r1, sp, #4
 80a1276:	4418      	add	r0, r3
 80a1278:	f88d 2004 	strb.w	r2, [sp, #4]
 80a127c:	f88d 2005 	strb.w	r2, [sp, #5]
 80a1280:	f88d 2006 	strb.w	r2, [sp, #6]
 80a1284:	f7ff fa27 	bl	80a06d6 <_ZN9NSFastLED4CRGBpLERKS0_>
  }
}
 80a1288:	b003      	add	sp, #12
 80a128a:	f85d fb04 	ldr.w	pc, [sp], #4
 80a128e:	bf00      	nop
 80a1290:	2000033c 	.word	0x2000033c
 80a1294:	200005b7 	.word	0x200005b7

080a1298 <_Z18rainbowWithGlitterv>:
  fill_rainbow( leds, NUM_LEDS, gHue, 255 / NUM_LEDS);
  return 8;
}

uint8_t rainbowWithGlitter()
{
 80a1298:	b508      	push	{r3, lr}
  // built-in FastLED rainbow, plus some random sparkly glitter
  rainbow();
 80a129a:	f7fe ff93 	bl	80a01c4 <_Z7rainbowv>
  addGlitter(80);
 80a129e:	2050      	movs	r0, #80	; 0x50
 80a12a0:	f7ff ffd0 	bl	80a1244 <_Z10addGlitterh>
  return 8;
}
 80a12a4:	2008      	movs	r0, #8
 80a12a6:	bd08      	pop	{r3, pc}

080a12a8 <_ZN10CloudClass8variableIA10_cIiEEEbRKT_DpRKT0_>:
        return _variable(varKey, (const char*)userVar, userVarType);
    }

    template<typename T> static inline bool _variable(const char *varKey, const typename T::varref userVar, const T& userVarType)
    {
        return CLOUD_FN(spark_variable(varKey, (const void*)userVar, T::value(), NULL), false);
 80a12a8:	2300      	movs	r3, #0
 80a12aa:	2202      	movs	r2, #2
 80a12ac:	f001 b93c 	b.w	80a2528 <spark_variable>

080a12b0 <setup>:
unsigned long lastDebounceTime = 0;  // the last time the output pin was toggled
unsigned long debounceDelay = 50;    // the debounce time; increase if the output flickers


void setup()
{
 80a12b0:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
	/// @tparam DATA_PIN - the optional data pin for the leds (required)
	/// @tparam RGB_ORDER - the rgb ordering for the leds (e.g. what order red, green, and blue data is written out in)
	/// @returns a reference to the added controller
	template<template<uint8_t DATA_PIN, EOrder RGB_ORDER> class CHIPSET, uint8_t DATA_PIN, EOrder RGB_ORDER>
	static CLEDController &addLeds(struct CRGB *data, int nLedsOrOffset, int nLedsIfOffset = 0) {
		static CHIPSET<DATA_PIN, RGB_ORDER> c;
 80a12b4:	4899      	ldr	r0, [pc, #612]	; (80a151c <setup+0x26c>)
 80a12b6:	6804      	ldr	r4, [r0, #0]
 80a12b8:	f014 0401 	ands.w	r4, r4, #1
 80a12bc:	d11f      	bne.n	80a12fe <setup+0x4e>
 80a12be:	f7fe feee 	bl	80a009e <__cxa_guard_acquire>
 80a12c2:	b1e0      	cbz	r0, 80a12fe <setup+0x4e>
#ifdef SUPPORT_ARGB
    // as above, but every 4th uint8_t is assumed to be alpha channel data, and will be skipped
    virtual void show(const struct CARGB *data, int nLeds, CRGB scale) = 0;
#endif
public:
    CLEDController() : m_Data(NULL), m_ColorCorrection(UncorrectedColor), m_ColorTemperature(UncorrectedTemperature), m_DitherMode(BINARY_DITHER), m_nLeds(0) {
 80a12c4:	4b96      	ldr	r3, [pc, #600]	; (80a1520 <setup+0x270>)
    {
    }

    inline CRGB( LEDColorCorrection colorcode) __attribute__((always_inline))
    : r((colorcode >> 16) & 0xFF), g((colorcode >> 8) & 0xFF), b((colorcode >> 0) & 0xFF)
 80a12c6:	22ff      	movs	r2, #255	; 0xff
 80a12c8:	731a      	strb	r2, [r3, #12]
 80a12ca:	735a      	strb	r2, [r3, #13]
 80a12cc:	739a      	strb	r2, [r3, #14]
    {

    }

    inline CRGB( ColorTemperature colorcode) __attribute__((always_inline))
    : r((colorcode >> 16) & 0xFF), g((colorcode >> 8) & 0xFF), b((colorcode >> 0) & 0xFF)
 80a12ce:	73da      	strb	r2, [r3, #15]
 80a12d0:	741a      	strb	r2, [r3, #16]
 80a12d2:	745a      	strb	r2, [r3, #17]
 80a12d4:	2201      	movs	r2, #1
 80a12d6:	749a      	strb	r2, [r3, #18]
        m_pNext = NULL;
        if(m_pHead==NULL) { m_pHead = this; }
 80a12d8:	4a92      	ldr	r2, [pc, #584]	; (80a1524 <setup+0x274>)
#ifdef SUPPORT_ARGB
    // as above, but every 4th uint8_t is assumed to be alpha channel data, and will be skipped
    virtual void show(const struct CARGB *data, int nLeds, CRGB scale) = 0;
#endif
public:
    CLEDController() : m_Data(NULL), m_ColorCorrection(UncorrectedColor), m_ColorTemperature(UncorrectedTemperature), m_DitherMode(BINARY_DITHER), m_nLeds(0) {
 80a12da:	605c      	str	r4, [r3, #4]
        m_pNext = NULL;
        if(m_pHead==NULL) { m_pHead = this; }
 80a12dc:	6811      	ldr	r1, [r2, #0]
#ifdef SUPPORT_ARGB
    // as above, but every 4th uint8_t is assumed to be alpha channel data, and will be skipped
    virtual void show(const struct CARGB *data, int nLeds, CRGB scale) = 0;
#endif
public:
    CLEDController() : m_Data(NULL), m_ColorCorrection(UncorrectedColor), m_ColorTemperature(UncorrectedTemperature), m_DitherMode(BINARY_DITHER), m_nLeds(0) {
 80a12de:	615c      	str	r4, [r3, #20]
        m_pNext = NULL;
 80a12e0:	609c      	str	r4, [r3, #8]
        if(m_pHead==NULL) { m_pHead = this; }
 80a12e2:	b901      	cbnz	r1, 80a12e6 <setup+0x36>
 80a12e4:	6013      	str	r3, [r2, #0]
        if(m_pTail != NULL) { m_pTail->m_pNext = this; }
 80a12e6:	4a90      	ldr	r2, [pc, #576]	; (80a1528 <setup+0x278>)
 80a12e8:	6811      	ldr	r1, [r2, #0]
 80a12ea:	b101      	cbz	r1, 80a12ee <setup+0x3e>
 80a12ec:	608b      	str	r3, [r1, #8]
        m_pTail = this;
 80a12ee:	6013      	str	r3, [r2, #0]
// Class to ensure that a minimum amount of time has kicked since the last time run - and delay if not enough time has passed yet
// this should make sure that chipsets that have 
template<int WAIT> class CMinWait {
	uint16_t mLastMicros;
public:
	CMinWait() { mLastMicros = 0; }
 80a12f0:	2200      	movs	r2, #0
 80a12f2:	841a      	strh	r2, [r3, #32]
template<uint8_t DATA_PIN, EOrder RGB_ORDER> class TM1803 : public TM1803Controller400Khz<DATA_PIN, RGB_ORDER> {};
template<uint8_t DATA_PIN, EOrder RGB_ORDER> class UCS1903 : public UCS1903Controller400Khz<DATA_PIN, RGB_ORDER> {};
template<uint8_t DATA_PIN, EOrder RGB_ORDER> class UCS1903B : public UCS1903BController800Khz<DATA_PIN, RGB_ORDER> {};
template<uint8_t DATA_PIN, EOrder RGB_ORDER> class UCS1904 : public UCS1904Controller800Khz<DATA_PIN, RGB_ORDER> {};
template<uint8_t DATA_PIN, EOrder RGB_ORDER> class WS2812 : public WS2812Controller800Khz<DATA_PIN, RGB_ORDER> {};
template<uint8_t DATA_PIN, EOrder RGB_ORDER> class WS2812B : public WS2812Controller800Khz<DATA_PIN, RGB_ORDER> {};
 80a12f4:	4a8d      	ldr	r2, [pc, #564]	; (80a152c <setup+0x27c>)
	/// @tparam DATA_PIN - the optional data pin for the leds (required)
	/// @tparam RGB_ORDER - the rgb ordering for the leds (e.g. what order red, green, and blue data is written out in)
	/// @returns a reference to the added controller
	template<template<uint8_t DATA_PIN, EOrder RGB_ORDER> class CHIPSET, uint8_t DATA_PIN, EOrder RGB_ORDER>
	static CLEDController &addLeds(struct CRGB *data, int nLedsOrOffset, int nLedsIfOffset = 0) {
		static CHIPSET<DATA_PIN, RGB_ORDER> c;
 80a12f6:	4889      	ldr	r0, [pc, #548]	; (80a151c <setup+0x26c>)
template<uint8_t DATA_PIN, EOrder RGB_ORDER> class TM1803 : public TM1803Controller400Khz<DATA_PIN, RGB_ORDER> {};
template<uint8_t DATA_PIN, EOrder RGB_ORDER> class UCS1903 : public UCS1903Controller400Khz<DATA_PIN, RGB_ORDER> {};
template<uint8_t DATA_PIN, EOrder RGB_ORDER> class UCS1903B : public UCS1903BController800Khz<DATA_PIN, RGB_ORDER> {};
template<uint8_t DATA_PIN, EOrder RGB_ORDER> class UCS1904 : public UCS1904Controller800Khz<DATA_PIN, RGB_ORDER> {};
template<uint8_t DATA_PIN, EOrder RGB_ORDER> class WS2812 : public WS2812Controller800Khz<DATA_PIN, RGB_ORDER> {};
template<uint8_t DATA_PIN, EOrder RGB_ORDER> class WS2812B : public WS2812Controller800Khz<DATA_PIN, RGB_ORDER> {};
 80a12f8:	601a      	str	r2, [r3, #0]
	/// @tparam DATA_PIN - the optional data pin for the leds (required)
	/// @tparam RGB_ORDER - the rgb ordering for the leds (e.g. what order red, green, and blue data is written out in)
	/// @returns a reference to the added controller
	template<template<uint8_t DATA_PIN, EOrder RGB_ORDER> class CHIPSET, uint8_t DATA_PIN, EOrder RGB_ORDER>
	static CLEDController &addLeds(struct CRGB *data, int nLedsOrOffset, int nLedsIfOffset = 0) {
		static CHIPSET<DATA_PIN, RGB_ORDER> c;
 80a12fa:	f7fe fed5 	bl	80a00a8 <__cxa_guard_release>
		return addLeds(&c, data, nLedsOrOffset, nLedsIfOffset);
 80a12fe:	2296      	movs	r2, #150	; 0x96
 80a1300:	2300      	movs	r3, #0
 80a1302:	498b      	ldr	r1, [pc, #556]	; (80a1530 <setup+0x280>)
 80a1304:	4886      	ldr	r0, [pc, #536]	; (80a1520 <setup+0x270>)
 80a1306:	f000 fc9d 	bl	80a1c44 <_ZN9NSFastLED8CFastLED7addLedsEPNS_14CLEDControllerEPNS_4CRGBEii>
    // FastLED.addLeds<APA102, D1, A3>(leds, NUM_LEDS);
    FastLED.addLeds<LED_TYPE,DATA_PIN,COLOR_ORDER>(leds, NUM_LEDS);

    FastLED.setCorrection(TypicalLEDStrip);
 80a130a:	4c8a      	ldr	r4, [pc, #552]	; (80a1534 <setup+0x284>)
    : r((colorcode >> 16) & 0xFF), g((colorcode >> 8) & 0xFF), b((colorcode >> 0) & 0xFF)
    {
    }

    inline CRGB( LEDColorCorrection colorcode) __attribute__((always_inline))
    : r((colorcode >> 16) & 0xFF), g((colorcode >> 8) & 0xFF), b((colorcode >> 0) & 0xFF)
 80a130c:	23ff      	movs	r3, #255	; 0xff
 80a130e:	f88d 3000 	strb.w	r3, [sp]
    FastLED.setBrightness(brightness);
 80a1312:	4d89      	ldr	r5, [pc, #548]	; (80a1538 <setup+0x288>)
 80a1314:	23b0      	movs	r3, #176	; 0xb0
 80a1316:	f88d 3001 	strb.w	r3, [sp, #1]
void setup()
{
    // FastLED.addLeds<APA102, D1, A3>(leds, NUM_LEDS);
    FastLED.addLeds<LED_TYPE,DATA_PIN,COLOR_ORDER>(leds, NUM_LEDS);

    FastLED.setCorrection(TypicalLEDStrip);
 80a131a:	4669      	mov	r1, sp
 80a131c:	23f0      	movs	r3, #240	; 0xf0
 80a131e:	4620      	mov	r0, r4
 80a1320:	f88d 3002 	strb.w	r3, [sp, #2]
 80a1324:	f000 fca2 	bl	80a1c6c <_ZN9NSFastLED8CFastLED13setCorrectionERKNS_4CRGBE>
	//@}
#endif

	/// Set the global brightness scaling
	/// @param scale a 0-255 value for how much to scale all leds before writing them out
	void setBrightness(uint8_t scale) { m_Scale = scale; }
 80a1328:	682b      	ldr	r3, [r5, #0]
    FastLED.setBrightness(brightness);
    FastLED.setDither(false);
 80a132a:	2100      	movs	r1, #0
 80a132c:	7023      	strb	r3, [r4, #0]
 80a132e:	4620      	mov	r0, r4
 80a1330:	f000 fcac 	bl	80a1c8c <_ZN9NSFastLED8CFastLED9setDitherEh>
    fill_solid(leds, NUM_LEDS, solidColor);
 80a1334:	4a81      	ldr	r2, [pc, #516]	; (80a153c <setup+0x28c>)
 80a1336:	2196      	movs	r1, #150	; 0x96
 80a1338:	487d      	ldr	r0, [pc, #500]	; (80a1530 <setup+0x280>)
 80a133a:	f000 fd56 	bl	80a1dea <_ZN9NSFastLED10fill_solidEPNS_4CRGBEiRKS0_>
    FastLED.show();
 80a133e:	4620      	mov	r0, r4
 80a1340:	f7ff fb2f 	bl	80a09a2 <_ZN9NSFastLED8CFastLED4showEv>

    
    pinMode(onboardLedPin, OUTPUT);
 80a1344:	4b7e      	ldr	r3, [pc, #504]	; (80a1540 <setup+0x290>)
 80a1346:	2101      	movs	r1, #1
 80a1348:	8818      	ldrh	r0, [r3, #0]
 80a134a:	f001 fe93 	bl	80a3074 <pinMode>
    pinMode(buttonPin, INPUT_PULLUP);
 80a134e:	4b7d      	ldr	r3, [pc, #500]	; (80a1544 <setup+0x294>)
 80a1350:	2102      	movs	r1, #2
 80a1352:	8818      	ldrh	r0, [r3, #0]
 80a1354:	f001 fe8e 	bl	80a3074 <pinMode>
    // pinMode(offlinePin, INPUT_PULLUP);
    // if(digitalRead(offlinePin) == LOW) {
    //     Particle.connect();
    // }

    Serial.begin(9600);
 80a1358:	f001 fd04 	bl	80a2d64 <_Z16_fetch_usbserialv>
 80a135c:	f44f 5116 	mov.w	r1, #9600	; 0x2580
 80a1360:	f001 fce6 	bl	80a2d30 <_ZN9USBSerial5beginEl>
    Serial.println("Hello - LED controller");
 80a1364:	f001 fcfe 	bl	80a2d64 <_Z16_fetch_usbserialv>
 80a1368:	4977      	ldr	r1, [pc, #476]	; (80a1548 <setup+0x298>)
 80a136a:	f001 fa06 	bl	80a277a <_ZN5Print7printlnEPKc>

    // load settings from EEPROM
    brightness = EEPROM.read(0);
 80a136e:	f001 fea5 	bl	80a30bc <_Z21__fetch_global_EEPROMv>
 80a1372:	2000      	movs	r0, #0
 80a1374:	f7fe ff34 	bl	80a01e0 <_ZN11EEPROMClass4readEi.isra.2>
 80a1378:	462b      	mov	r3, r5
    if(brightness < 1)
 80a137a:	b108      	cbz	r0, 80a1380 <setup+0xd0>

    Serial.begin(9600);
    Serial.println("Hello - LED controller");

    // load settings from EEPROM
    brightness = EEPROM.read(0);
 80a137c:	6028      	str	r0, [r5, #0]
 80a137e:	e001      	b.n	80a1384 <setup+0xd4>
    if(brightness < 1)
      brightness = 1;
 80a1380:	2201      	movs	r2, #1
 80a1382:	602a      	str	r2, [r5, #0]
    else if(brightness > 255)
      brightness = 255;

    FastLED.setBrightness(brightness);
 80a1384:	6819      	ldr	r1, [r3, #0]
    FastLED.setDither(brightness < 255);
 80a1386:	486b      	ldr	r0, [pc, #428]	; (80a1534 <setup+0x284>)
 80a1388:	29fe      	cmp	r1, #254	; 0xfe
 80a138a:	7021      	strb	r1, [r4, #0]
 80a138c:	bfcc      	ite	gt
 80a138e:	2100      	movgt	r1, #0
 80a1390:	2101      	movle	r1, #1
 80a1392:	f000 fc7b 	bl	80a1c8c <_ZN9NSFastLED8CFastLED9setDitherEh>

    patternIndex = EEPROM.read(1);
 80a1396:	f001 fe91 	bl	80a30bc <_Z21__fetch_global_EEPROMv>
 80a139a:	2001      	movs	r0, #1
 80a139c:	f7fe ff20 	bl	80a01e0 <_ZN11EEPROMClass4readEi.isra.2>
    if(patternIndex < 0)
      patternIndex = 0;
    else if (patternIndex >= patternCount)
 80a13a0:	4d6a      	ldr	r5, [pc, #424]	; (80a154c <setup+0x29c>)
      brightness = 255;

    FastLED.setBrightness(brightness);
    FastLED.setDither(brightness < 255);

    patternIndex = EEPROM.read(1);
 80a13a2:	4a6b      	ldr	r2, [pc, #428]	; (80a1550 <setup+0x2a0>)
    if(patternIndex < 0)
      patternIndex = 0;
    else if (patternIndex >= patternCount)
 80a13a4:	682b      	ldr	r3, [r5, #0]
      brightness = 255;

    FastLED.setBrightness(brightness);
    FastLED.setDither(brightness < 255);

    patternIndex = EEPROM.read(1);
 80a13a6:	6010      	str	r0, [r2, #0]
    if(patternIndex < 0)
      patternIndex = 0;
    else if (patternIndex >= patternCount)
 80a13a8:	4298      	cmp	r0, r3
      patternIndex = patternCount - 1;
 80a13aa:	bfa4      	itt	ge
 80a13ac:	f103 33ff 	addge.w	r3, r3, #4294967295	; 0xffffffff
 80a13b0:	6013      	strge	r3, [r2, #0]

    r = EEPROM.read(2);
 80a13b2:	f001 fe83 	bl	80a30bc <_Z21__fetch_global_EEPROMv>
 80a13b6:	2002      	movs	r0, #2
 80a13b8:	f7fe ff12 	bl	80a01e0 <_ZN11EEPROMClass4readEi.isra.2>
 80a13bc:	4e65      	ldr	r6, [pc, #404]	; (80a1554 <setup+0x2a4>)
    g = EEPROM.read(3);
 80a13be:	4c66      	ldr	r4, [pc, #408]	; (80a1558 <setup+0x2a8>)
    if(patternIndex < 0)
      patternIndex = 0;
    else if (patternIndex >= patternCount)
      patternIndex = patternCount - 1;

    r = EEPROM.read(2);
 80a13c0:	6030      	str	r0, [r6, #0]
    g = EEPROM.read(3);
 80a13c2:	f001 fe7b 	bl	80a30bc <_Z21__fetch_global_EEPROMv>
 80a13c6:	2003      	movs	r0, #3
 80a13c8:	f7fe ff0a 	bl	80a01e0 <_ZN11EEPROMClass4readEi.isra.2>
 80a13cc:	6020      	str	r0, [r4, #0]
    b = EEPROM.read(4);
 80a13ce:	f001 fe75 	bl	80a30bc <_Z21__fetch_global_EEPROMv>
 80a13d2:	2004      	movs	r0, #4
 80a13d4:	f7fe ff04 	bl	80a01e0 <_ZN11EEPROMClass4readEi.isra.2>
 80a13d8:	4b60      	ldr	r3, [pc, #384]	; (80a155c <setup+0x2ac>)

    if(r == 0 && g == 0 && b == 0) {
 80a13da:	6832      	ldr	r2, [r6, #0]
    else if (patternIndex >= patternCount)
      patternIndex = patternCount - 1;

    r = EEPROM.read(2);
    g = EEPROM.read(3);
    b = EEPROM.read(4);
 80a13dc:	6018      	str	r0, [r3, #0]

    if(r == 0 && g == 0 && b == 0) {
 80a13de:	b922      	cbnz	r2, 80a13ea <setup+0x13a>
 80a13e0:	6821      	ldr	r1, [r4, #0]
 80a13e2:	b911      	cbnz	r1, 80a13ea <setup+0x13a>
 80a13e4:	b908      	cbnz	r0, 80a13ea <setup+0x13a>
      r = 0;
      g = 0;
      b = 255;
 80a13e6:	21ff      	movs	r1, #255	; 0xff
 80a13e8:	6019      	str	r1, [r3, #0]
    }

    solidColor = CRGB(r, b, g);
 80a13ea:	7818      	ldrb	r0, [r3, #0]
 80a13ec:	7821      	ldrb	r1, [r4, #0]
    }

    // allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
 80a13ee:	4b53      	ldr	r3, [pc, #332]	; (80a153c <setup+0x28c>)
 80a13f0:	4c5b      	ldr	r4, [pc, #364]	; (80a1560 <setup+0x2b0>)
 80a13f2:	701a      	strb	r2, [r3, #0]
        g = rhs.g;
 80a13f4:	7058      	strb	r0, [r3, #1]
        b = rhs.b;
 80a13f6:	7099      	strb	r1, [r3, #2]

    uint8_t timezoneSign = EEPROM.read(5);
 80a13f8:	f001 fe60 	bl	80a30bc <_Z21__fetch_global_EEPROMv>
 80a13fc:	2005      	movs	r0, #5
 80a13fe:	f7fe feef 	bl	80a01e0 <_ZN11EEPROMClass4readEi.isra.2>
    if(timezoneSign < 1)
 80a1402:	b930      	cbnz	r0, 80a1412 <setup+0x162>
      timezone = -EEPROM.read(6);
 80a1404:	f001 fe5a 	bl	80a30bc <_Z21__fetch_global_EEPROMv>
 80a1408:	2006      	movs	r0, #6
 80a140a:	f7fe fee9 	bl	80a01e0 <_ZN11EEPROMClass4readEi.isra.2>
 80a140e:	4240      	negs	r0, r0
 80a1410:	e004      	b.n	80a141c <setup+0x16c>
    else
      timezone = EEPROM.read(6);
 80a1412:	f001 fe53 	bl	80a30bc <_Z21__fetch_global_EEPROMv>
 80a1416:	2006      	movs	r0, #6
 80a1418:	f7fe fee2 	bl	80a01e0 <_ZN11EEPROMClass4readEi.isra.2>
 80a141c:	6020      	str	r0, [r4, #0]

    if(timezone < -12)
 80a141e:	6822      	ldr	r2, [r4, #0]
 80a1420:	4b4f      	ldr	r3, [pc, #316]	; (80a1560 <setup+0x2b0>)
 80a1422:	320c      	adds	r2, #12
 80a1424:	da02      	bge.n	80a142c <setup+0x17c>
      timezone = -12;
 80a1426:	f06f 020b 	mvn.w	r2, #11
 80a142a:	e004      	b.n	80a1436 <setup+0x186>
    else if (power > 13)
 80a142c:	4a4d      	ldr	r2, [pc, #308]	; (80a1564 <setup+0x2b4>)
 80a142e:	6812      	ldr	r2, [r2, #0]
 80a1430:	2a0d      	cmp	r2, #13
 80a1432:	dd01      	ble.n	80a1438 <setup+0x188>
      timezone = 13;
 80a1434:	220d      	movs	r2, #13
 80a1436:	601a      	str	r2, [r3, #0]

    flipClock = EEPROM.read(7);
 80a1438:	f001 fe40 	bl	80a30bc <_Z21__fetch_global_EEPROMv>
 80a143c:	2007      	movs	r0, #7
 80a143e:	f7fe fecf 	bl	80a01e0 <_ZN11EEPROMClass4readEi.isra.2>
 80a1442:	4b49      	ldr	r3, [pc, #292]	; (80a1568 <setup+0x2b8>)
    if(flipClock < 0)
      flipClock = 0;
    else if (flipClock > 1)
 80a1444:	2801      	cmp	r0, #1
      flipClock = 1;
 80a1446:	bfca      	itet	gt
 80a1448:	2201      	movgt	r2, #1
    if(timezone < -12)
      timezone = -12;
    else if (power > 13)
      timezone = 13;

    flipClock = EEPROM.read(7);
 80a144a:	6018      	strle	r0, [r3, #0]
    if(flipClock < 0)
      flipClock = 0;
    else if (flipClock > 1)
      flipClock = 1;
 80a144c:	601a      	strgt	r2, [r3, #0]
        return _function(name, args...);
    }

    static bool _function(const char *funcKey, user_function_int_str_t* func)
    {
        return CLOUD_FN(register_function(call_raw_user_function, (void*)func, funcKey), false);
 80a144e:	4947      	ldr	r1, [pc, #284]	; (80a156c <setup+0x2bc>)
 80a1450:	4a47      	ldr	r2, [pc, #284]	; (80a1570 <setup+0x2c0>)
 80a1452:	4848      	ldr	r0, [pc, #288]	; (80a1574 <setup+0x2c4>)
 80a1454:	f001 f8c2 	bl	80a25dc <_ZN10CloudClass17register_functionEPFiPvPKcS0_ES0_S2_>
 80a1458:	4a47      	ldr	r2, [pc, #284]	; (80a1578 <setup+0x2c8>)
 80a145a:	4948      	ldr	r1, [pc, #288]	; (80a157c <setup+0x2cc>)
 80a145c:	4845      	ldr	r0, [pc, #276]	; (80a1574 <setup+0x2c4>)
 80a145e:	f001 f8bd 	bl	80a25dc <_ZN10CloudClass17register_functionEPFiPvPKcS0_ES0_S2_>

    Particle.function("patternIndex", setPatternIndex); // sets the current pattern index, changes to the pattern with the specified index
    Particle.function("variable", setVariable); // sets the value of a variable, args are name:value

    Particle.variable("power", power);
 80a1462:	4940      	ldr	r1, [pc, #256]	; (80a1564 <setup+0x2b4>)
 80a1464:	4846      	ldr	r0, [pc, #280]	; (80a1580 <setup+0x2d0>)
 80a1466:	f7ff ff1f 	bl	80a12a8 <_ZN10CloudClass8variableIA10_cIiEEEbRKT_DpRKT0_>
    Particle.variable("brightness", brightness);
 80a146a:	4933      	ldr	r1, [pc, #204]	; (80a1538 <setup+0x288>)
 80a146c:	4845      	ldr	r0, [pc, #276]	; (80a1584 <setup+0x2d4>)
 80a146e:	f7ff ff1b 	bl	80a12a8 <_ZN10CloudClass8variableIA10_cIiEEEbRKT_DpRKT0_>
    Particle.variable("patternIndex", patternIndex);
 80a1472:	4937      	ldr	r1, [pc, #220]	; (80a1550 <setup+0x2a0>)
 80a1474:	483e      	ldr	r0, [pc, #248]	; (80a1570 <setup+0x2c0>)
 80a1476:	f7ff ff17 	bl	80a12a8 <_ZN10CloudClass8variableIA10_cIiEEEbRKT_DpRKT0_>
    Particle.variable("r", r);
 80a147a:	4936      	ldr	r1, [pc, #216]	; (80a1554 <setup+0x2a4>)
 80a147c:	4842      	ldr	r0, [pc, #264]	; (80a1588 <setup+0x2d8>)
 80a147e:	f7ff ff13 	bl	80a12a8 <_ZN10CloudClass8variableIA10_cIiEEEbRKT_DpRKT0_>
    Particle.variable("g", g);
 80a1482:	4935      	ldr	r1, [pc, #212]	; (80a1558 <setup+0x2a8>)
 80a1484:	4841      	ldr	r0, [pc, #260]	; (80a158c <setup+0x2dc>)
 80a1486:	f7ff ff0f 	bl	80a12a8 <_ZN10CloudClass8variableIA10_cIiEEEbRKT_DpRKT0_>
    Particle.variable("b", b);
 80a148a:	4934      	ldr	r1, [pc, #208]	; (80a155c <setup+0x2ac>)
 80a148c:	4840      	ldr	r0, [pc, #256]	; (80a1590 <setup+0x2e0>)
 80a148e:	f7ff ff0b 	bl	80a12a8 <_ZN10CloudClass8variableIA10_cIiEEEbRKT_DpRKT0_>
    Particle.variable("timezone", timezone);
 80a1492:	4933      	ldr	r1, [pc, #204]	; (80a1560 <setup+0x2b0>)
 80a1494:	483f      	ldr	r0, [pc, #252]	; (80a1594 <setup+0x2e4>)
 80a1496:	f7ff ff07 	bl	80a12a8 <_ZN10CloudClass8variableIA10_cIiEEEbRKT_DpRKT0_>
    Particle.variable("flipClock", flipClock);
 80a149a:	4933      	ldr	r1, [pc, #204]	; (80a1568 <setup+0x2b8>)
 80a149c:	483e      	ldr	r0, [pc, #248]	; (80a1598 <setup+0x2e8>)
 80a149e:	f7ff ff03 	bl	80a12a8 <_ZN10CloudClass8variableIA10_cIiEEEbRKT_DpRKT0_>

    patternNames = "[";
 80a14a2:	493e      	ldr	r1, [pc, #248]	; (80a159c <setup+0x2ec>)
 80a14a4:	483e      	ldr	r0, [pc, #248]	; (80a15a0 <setup+0x2f0>)
 80a14a6:	f001 fa50 	bl	80a294a <_ZN6StringaSEPKc>
    for(uint8_t i = 0; i < patternCount; i++)
 80a14aa:	f8df 80a0 	ldr.w	r8, [pc, #160]	; 80a154c <setup+0x29c>
    Particle.variable("g", g);
    Particle.variable("b", b);
    Particle.variable("timezone", timezone);
    Particle.variable("flipClock", flipClock);

    patternNames = "[";
 80a14ae:	2600      	movs	r6, #0
    for(uint8_t i = 0; i < patternCount; i++)
 80a14b0:	682b      	ldr	r3, [r5, #0]
 80a14b2:	b2f7      	uxtb	r7, r6
 80a14b4:	429f      	cmp	r7, r3
 80a14b6:	da1a      	bge.n	80a14ee <setup+0x23e>
    {
      patternNames.concat("\"");
 80a14b8:	493a      	ldr	r1, [pc, #232]	; (80a15a4 <setup+0x2f4>)
 80a14ba:	4839      	ldr	r0, [pc, #228]	; (80a15a0 <setup+0x2f0>)
 80a14bc:	f001 fa84 	bl	80a29c8 <_ZN6String6concatEPKc>
      patternNames.concat(patterns[i].name);
 80a14c0:	4939      	ldr	r1, [pc, #228]	; (80a15a8 <setup+0x2f8>)
 80a14c2:	2314      	movs	r3, #20
 80a14c4:	fb03 1107 	mla	r1, r3, r7, r1
 80a14c8:	4835      	ldr	r0, [pc, #212]	; (80a15a0 <setup+0x2f0>)
 80a14ca:	3104      	adds	r1, #4
 80a14cc:	f001 fa78 	bl	80a29c0 <_ZN6String6concatERKS_>
      patternNames.concat("\"");
 80a14d0:	4934      	ldr	r1, [pc, #208]	; (80a15a4 <setup+0x2f4>)
 80a14d2:	4833      	ldr	r0, [pc, #204]	; (80a15a0 <setup+0x2f0>)
 80a14d4:	f001 fa78 	bl	80a29c8 <_ZN6String6concatEPKc>
      if(i < patternCount - 1)
 80a14d8:	f8d8 3000 	ldr.w	r3, [r8]
 80a14dc:	3b01      	subs	r3, #1
 80a14de:	429f      	cmp	r7, r3
 80a14e0:	da03      	bge.n	80a14ea <setup+0x23a>
        patternNames.concat(",");
 80a14e2:	4932      	ldr	r1, [pc, #200]	; (80a15ac <setup+0x2fc>)
 80a14e4:	482e      	ldr	r0, [pc, #184]	; (80a15a0 <setup+0x2f0>)
 80a14e6:	f001 fa6f 	bl	80a29c8 <_ZN6String6concatEPKc>
 80a14ea:	3601      	adds	r6, #1
    Particle.variable("b", b);
    Particle.variable("timezone", timezone);
    Particle.variable("flipClock", flipClock);

    patternNames = "[";
    for(uint8_t i = 0; i < patternCount; i++)
 80a14ec:	e7e0      	b.n	80a14b0 <setup+0x200>
      patternNames.concat(patterns[i].name);
      patternNames.concat("\"");
      if(i < patternCount - 1)
        patternNames.concat(",");
    }
    patternNames.concat("]");
 80a14ee:	4930      	ldr	r1, [pc, #192]	; (80a15b0 <setup+0x300>)
 80a14f0:	482b      	ldr	r0, [pc, #172]	; (80a15a0 <setup+0x2f0>)
 80a14f2:	f001 fa69 	bl	80a29c8 <_ZN6String6concatEPKc>

    template<typename T>
    static inline bool _variable(const T *varKey, const String *userVar, const CloudVariableTypeString& userVarType)
    {
        spark_variable_t extra;
        extra.size = sizeof(extra);
 80a14f6:	2308      	movs	r3, #8
 80a14f8:	f8ad 3000 	strh.w	r3, [sp]
        extra.update = update_string_variable;
 80a14fc:	4b2d      	ldr	r3, [pc, #180]	; (80a15b4 <setup+0x304>)
        return CLOUD_FN(spark_variable(varKey, userVar, CloudVariableTypeString::value(), &extra), false);
 80a14fe:	2204      	movs	r2, #4
 80a1500:	4927      	ldr	r1, [pc, #156]	; (80a15a0 <setup+0x2f0>)
    template<typename T>
    static inline bool _variable(const T *varKey, const String *userVar, const CloudVariableTypeString& userVarType)
    {
        spark_variable_t extra;
        extra.size = sizeof(extra);
        extra.update = update_string_variable;
 80a1502:	9301      	str	r3, [sp, #4]
        return CLOUD_FN(spark_variable(varKey, userVar, CloudVariableTypeString::value(), &extra), false);
 80a1504:	482c      	ldr	r0, [pc, #176]	; (80a15b8 <setup+0x308>)
 80a1506:	466b      	mov	r3, sp
 80a1508:	f001 f80e 	bl	80a2528 <spark_variable>
    Particle.variable("patternNames", patternNames);

    Time.zone(timezone);
 80a150c:	6820      	ldr	r0, [r4, #0]
 80a150e:	f002 f84b 	bl	80a35a8 <__aeabi_i2f>
 80a1512:	f001 fb3f 	bl	80a2b94 <_ZN9TimeClass4zoneEf>
}
 80a1516:	b002      	add	sp, #8
 80a1518:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80a151c:	200003b4 	.word	0x200003b4
 80a1520:	200003b8 	.word	0x200003b8
 80a1524:	20000be0 	.word	0x20000be0
 80a1528:	20000bd0 	.word	0x20000bd0
 80a152c:	080a3da8 	.word	0x080a3da8
 80a1530:	200005b7 	.word	0x200005b7
 80a1534:	20000bc8 	.word	0x20000bc8
 80a1538:	20000318 	.word	0x20000318
 80a153c:	20000780 	.word	0x20000780
 80a1540:	20000304 	.word	0x20000304
 80a1544:	20000334 	.word	0x20000334
 80a1548:	080a3e36 	.word	0x080a3e36
 80a154c:	20000338 	.word	0x20000338
 80a1550:	20000790 	.word	0x20000790
 80a1554:	200005a4 	.word	0x200005a4
 80a1558:	200003dc 	.word	0x200003dc
 80a155c:	20000330 	.word	0x20000330
 80a1560:	2000031c 	.word	0x2000031c
 80a1564:	20000314 	.word	0x20000314
 80a1568:	200005ac 	.word	0x200005ac
 80a156c:	080a01e9 	.word	0x080a01e9
 80a1570:	080a3e4d 	.word	0x080a3e4d
 80a1574:	080a25b1 	.word	0x080a25b1
 80a1578:	080a3e5a 	.word	0x080a3e5a
 80a157c:	080a0ea9 	.word	0x080a0ea9
 80a1580:	080a3e63 	.word	0x080a3e63
 80a1584:	080a3e69 	.word	0x080a3e69
 80a1588:	080a41cd 	.word	0x080a41cd
 80a158c:	080a3e74 	.word	0x080a3e74
 80a1590:	080a3e76 	.word	0x080a3e76
 80a1594:	080a3e78 	.word	0x080a3e78
 80a1598:	080a3e81 	.word	0x080a3e81
 80a159c:	080a4171 	.word	0x080a4171
 80a15a0:	20000844 	.word	0x20000844
 80a15a4:	080a3e8b 	.word	0x080a3e8b
 80a15a8:	20000858 	.word	0x20000858
 80a15ac:	080a3e15 	.word	0x080a3e15
 80a15b0:	080a3e8d 	.word	0x080a3e8d
 80a15b4:	080a00af 	.word	0x080a00af
 80a15b8:	080a3e8f 	.word	0x080a3e8f

080a15bc <_ZN9NSFastLED8CMinWaitILi50EE4waitEv>:

	void wait() { 
 80a15bc:	b510      	push	{r4, lr}
 80a15be:	4604      	mov	r4, r0
inline unsigned long micros(void) { return HAL_Timer_Get_Micro_Seconds(); }
 80a15c0:	f000 fe7a 	bl	80a22b8 <HAL_Timer_Get_Micro_Seconds>
		uint16_t diff;
		do {
 80a15c4:	8823      	ldrh	r3, [r4, #0]
 80a15c6:	1ac0      	subs	r0, r0, r3
 80a15c8:	b280      	uxth	r0, r0
 80a15ca:	2831      	cmp	r0, #49	; 0x31
 80a15cc:	d9f8      	bls.n	80a15c0 <_ZN9NSFastLED8CMinWaitILi50EE4waitEv+0x4>
			diff = (micros() & 0xFFFF) - mLastMicros;			
		} while(diff < WAIT);
	}
 80a15ce:	bd10      	pop	{r4, pc}

080a15d0 <_ZN9NSFastLED19ClocklessControllerILi15ELi30ELi75ELi45ELNS_6EOrderE66ELi0ELb0ELi50EE15showRGBInternalERNS_15PixelControllerILS1_66EEE>:
    }
  }

  // This method is made static to force making register Y available to use for data on AVR - if the method is non-static, then
  // gcc will use register Y for the this pointer.
  static uint32_t showRGBInternal(PixelController<RGB_ORDER> & pixels) {
 80a15d0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    // Get access to the clock
    CoreDebug->DEMCR  |= CoreDebug_DEMCR_TRCENA_Msk;
 80a15d4:	4a8c      	ldr	r2, [pc, #560]	; (80a1808 <_ZN9NSFastLED19ClocklessControllerILi15ELi30ELi75ELi45ELNS_6EOrderE66ELi0ELb0ELi50EE15showRGBInternalERNS_15PixelControllerILS1_66EEE+0x238>)
 80a15d6:	68d3      	ldr	r3, [r2, #12]
 80a15d8:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 80a15dc:	60d3      	str	r3, [r2, #12]
    DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
 80a15de:	4b8b      	ldr	r3, [pc, #556]	; (80a180c <_ZN9NSFastLED19ClocklessControllerILi15ELi30ELi75ELi45ELNS_6EOrderE66ELi0ELb0ELi50EE15showRGBInternalERNS_15PixelControllerILS1_66EEE+0x23c>)
 80a15e0:	681a      	ldr	r2, [r3, #0]
 80a15e2:	f042 0201 	orr.w	r2, r2, #1
 80a15e6:	601a      	str	r2, [r3, #0]
    DWT->CYCCNT = 0;
 80a15e8:	2200      	movs	r2, #0
 80a15ea:	605a      	str	r2, [r3, #4]

    register data_ptr_t port = FastPin<DATA_PIN>::port();
    register data_t hi = *port | FastPin<DATA_PIN>::mask();;
 80a15ec:	4a88      	ldr	r2, [pc, #544]	; (80a1810 <_ZN9NSFastLED19ClocklessControllerILi15ELi30ELi75ELi45ELNS_6EOrderE66ELi0ELb0ELi50EE15showRGBInternalERNS_15PixelControllerILS1_66EEE+0x240>)
 80a15ee:	6954      	ldr	r4, [r2, #20]
    register data_t lo = *port & ~FastPin<DATA_PIN>::mask();;
 80a15f0:	6953      	ldr	r3, [r2, #20]
    CoreDebug->DEMCR  |= CoreDebug_DEMCR_TRCENA_Msk;
    DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
    DWT->CYCCNT = 0;

    register data_ptr_t port = FastPin<DATA_PIN>::port();
    register data_t hi = *port | FastPin<DATA_PIN>::mask();;
 80a15f2:	f044 0480 	orr.w	r4, r4, #128	; 0x80
    register data_t lo = *port & ~FastPin<DATA_PIN>::mask();;
 80a15f6:	f023 0380 	bic.w	r3, r3, #128	; 0x80
    *port = lo;
 80a15fa:	6153      	str	r3, [r2, #20]
                d[2] = e[2] - d[2];
        }

        // Some chipsets pre-cycle the first byte, which means we want to cycle byte 0's dithering separately
        __attribute__((always_inline)) inline void preStepFirstByteDithering() {
            d[RO(0)] = e[RO(0)] - d[RO(0)];
 80a15fc:	7a41      	ldrb	r1, [r0, #9]
 80a15fe:	7b02      	ldrb	r2, [r0, #12]
 80a1600:	1a52      	subs	r2, r2, r1
 80a1602:	b2d2      	uxtb	r2, r2
        }

        template<int SLOT>  __attribute__((always_inline)) inline static uint8_t loadByte(PixelController & pc) { return pc.mData[RO(SLOT)]; }
 80a1604:	6801      	ldr	r1, [r0, #0]
                d[2] = e[2] - d[2];
        }

        // Some chipsets pre-cycle the first byte, which means we want to cycle byte 0's dithering separately
        __attribute__((always_inline)) inline void preStepFirstByteDithering() {
            d[RO(0)] = e[RO(0)] - d[RO(0)];
 80a1606:	7242      	strb	r2, [r0, #9]
        }

        template<int SLOT>  __attribute__((always_inline)) inline static uint8_t loadByte(PixelController & pc) { return pc.mData[RO(SLOT)]; }
 80a1608:	7849      	ldrb	r1, [r1, #1]
        template<int SLOT>  __attribute__((always_inline)) inline static uint8_t dither(PixelController & pc, uint8_t b) { return b ? qadd8(b, pc.d[RO(SLOT)]) : 0; }
 80a160a:	b121      	cbz	r1, 80a1616 <_ZN9NSFastLED19ClocklessControllerILi15ELi30ELi75ELi45ELNS_6EOrderE66ELi0ELb0ELi50EE15showRGBInternalERNS_15PixelControllerILS1_66EEE+0x46>

// qadd8: add one byte to another, saturating at 0xFF
LIB8STATIC uint8_t qadd8( uint8_t i, uint8_t j)
{
#if QADD8_C == 1
    unsigned int t = i + j;
 80a160c:	440a      	add	r2, r1
 80a160e:	2aff      	cmp	r2, #255	; 0xff
 80a1610:	bfa8      	it	ge
 80a1612:	22ff      	movge	r2, #255	; 0xff
    if( t > 255) t = 255;
    return t;
 80a1614:	b2d1      	uxtb	r1, r2
//         In other words, it computes i * (scale / 256)
//         4 clocks AVR with MUL, 2 clocks ARM
LIB8STATIC uint8_t scale8( uint8_t i, fract8 scale)
{
#if SCALE8_C == 1
    return ((uint16_t)i * (uint16_t)(scale) ) >> 8;
 80a1616:	7bc2      	ldrb	r2, [r0, #15]
 80a1618:	434a      	muls	r2, r1
 80a161a:	f3c2 2a07 	ubfx	sl, r2, #8, #8
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i");
 80a161e:	b672      	cpsid	i
    This function disables FIQ interrupts by setting the F-bit in the CPSR.
    Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_fault_irq(void)
{
  __ASM volatile ("cpsid f");
 80a1620:	b671      	cpsid	f

#define _CYCCNT (*(volatile uint32_t*)(0xE0001004UL))

  template<int BITS> __attribute__ ((always_inline)) inline static void writeBits(register uint32_t & next_mark, register data_ptr_t port, register data_t hi, register data_t lo, register uint8_t & b)  {
    for(register uint32_t i = BITS-1; i > 0; i--) {
      while(_CYCCNT < (T1+T2+T3-ADJ));
 80a1622:	f8df c1f0 	ldr.w	ip, [pc, #496]	; 80a1814 <_ZN9NSFastLED19ClocklessControllerILi15ELi30ELi75ELi45ELNS_6EOrderE66ELi0ELb0ELi50EE15showRGBInternalERNS_15PixelControllerILS1_66EEE+0x244>

    cli();

    uint32_t next_mark = (T1+T2+T3);

    DWT->CYCCNT = 0;
 80a1626:	4a79      	ldr	r2, [pc, #484]	; (80a180c <_ZN9NSFastLED19ClocklessControllerILi15ELi30ELi75ELi45ELNS_6EOrderE66ELi0ELb0ELi50EE15showRGBInternalERNS_15PixelControllerILS1_66EEE+0x23c>)

  inline static void toggle() __attribute__ ((always_inline)) { if(_GPIO::r()->ODR & _MASK) { lo(); } else { hi(); } }

  inline static void hi(register port_ptr_t port) __attribute__ ((always_inline)) { hi(); }
  inline static void lo(register port_ptr_t port) __attribute__ ((always_inline)) { lo(); }
  inline static void fastset(register port_ptr_t port, register port_t val) __attribute__ ((always_inline)) { *port = val; }
 80a1628:	4d79      	ldr	r5, [pc, #484]	; (80a1810 <_ZN9NSFastLED19ClocklessControllerILi15ELi30ELi75ELi45ELNS_6EOrderE66ELi0ELb0ELi50EE15showRGBInternalERNS_15PixelControllerILS1_66EEE+0x240>)
 80a162a:	2100      	movs	r1, #0

  template<int BITS> __attribute__ ((always_inline)) inline static void writeBits(register uint32_t & next_mark, register data_ptr_t port, register data_t hi, register data_t lo, register uint8_t & b)  {
    for(register uint32_t i = BITS-1; i > 0; i--) {
      while(_CYCCNT < (T1+T2+T3-ADJ));
      FastPin<DATA_PIN>::fastset(port, hi);
      _CYCCNT = 4;
 80a162c:	f04f 0e04 	mov.w	lr, #4

    cli();

    uint32_t next_mark = (T1+T2+T3);

    DWT->CYCCNT = 0;
 80a1630:	6051      	str	r1, [r2, #4]
 80a1632:	4666      	mov	r6, ip
 80a1634:	46e1      	mov	r9, ip
 80a1636:	4629      	mov	r1, r5
 80a1638:	4662      	mov	r2, ip

  template<int BITS> __attribute__ ((always_inline)) inline static void writeBits(register uint32_t & next_mark, register data_ptr_t port, register data_t hi, register data_t lo, register uint8_t & b)  {
    for(register uint32_t i = BITS-1; i > 0; i--) {
      while(_CYCCNT < (T1+T2+T3-ADJ));
      FastPin<DATA_PIN>::fastset(port, hi);
      _CYCCNT = 4;
 80a163a:	46f0      	mov	r8, lr
    cli();

    uint32_t next_mark = (T1+T2+T3);

    DWT->CYCCNT = 0;
    while(pixels.has(1)) {
 80a163c:	6847      	ldr	r7, [r0, #4]
 80a163e:	2f00      	cmp	r7, #0
 80a1640:	f340 80db 	ble.w	80a17fa <_ZN9NSFastLED19ClocklessControllerILi15ELi30ELi75ELi45ELNS_6EOrderE66ELi0ELb0ELi50EE15showRGBInternalERNS_15PixelControllerILS1_66EEE+0x22a>

        // step the dithering forward
         __attribute__((always_inline)) inline void stepDithering() {
         		// IF UPDATING HERE, BE SURE TO UPDATE THE ASM VERSION IN
         		// clockless_trinket.h!
                d[0] = e[0] - d[0];
 80a1644:	f890 b008 	ldrb.w	fp, [r0, #8]
 80a1648:	7ac7      	ldrb	r7, [r0, #11]
 80a164a:	ebcb 0707 	rsb	r7, fp, r7
 80a164e:	7207      	strb	r7, [r0, #8]
                d[1] = e[1] - d[1];
 80a1650:	f890 b009 	ldrb.w	fp, [r0, #9]
 80a1654:	7b07      	ldrb	r7, [r0, #12]
 80a1656:	ebcb 0707 	rsb	r7, fp, r7
 80a165a:	7247      	strb	r7, [r0, #9]
                d[2] = e[2] - d[2];
 80a165c:	f890 b00a 	ldrb.w	fp, [r0, #10]
 80a1660:	7b47      	ldrb	r7, [r0, #13]
 80a1662:	ebcb 0707 	rsb	r7, fp, r7
 80a1666:	7287      	strb	r7, [r0, #10]
 80a1668:	2707      	movs	r7, #7

#define _CYCCNT (*(volatile uint32_t*)(0xE0001004UL))

  template<int BITS> __attribute__ ((always_inline)) inline static void writeBits(register uint32_t & next_mark, register data_ptr_t port, register data_t hi, register data_t lo, register uint8_t & b)  {
    for(register uint32_t i = BITS-1; i > 0; i--) {
      while(_CYCCNT < (T1+T2+T3-ADJ));
 80a166a:	f8dc b000 	ldr.w	fp, [ip]
 80a166e:	f1bb 0f8d 	cmp.w	fp, #141	; 0x8d
 80a1672:	d9fa      	bls.n	80a166a <_ZN9NSFastLED19ClocklessControllerILi15ELi30ELi75ELi45ELNS_6EOrderE66ELi0ELb0ELi50EE15showRGBInternalERNS_15PixelControllerILS1_66EEE+0x9a>
      FastPin<DATA_PIN>::fastset(port, hi);
      _CYCCNT = 4;
      if(b&0x80) {
 80a1674:	f01a 0f80 	tst.w	sl, #128	; 0x80
 80a1678:	616c      	str	r4, [r5, #20]

  template<int BITS> __attribute__ ((always_inline)) inline static void writeBits(register uint32_t & next_mark, register data_ptr_t port, register data_t hi, register data_t lo, register uint8_t & b)  {
    for(register uint32_t i = BITS-1; i > 0; i--) {
      while(_CYCCNT < (T1+T2+T3-ADJ));
      FastPin<DATA_PIN>::fastset(port, hi);
      _CYCCNT = 4;
 80a167a:	f8c6 e000 	str.w	lr, [r6]
      if(b&0x80) {
 80a167e:	d005      	beq.n	80a168c <_ZN9NSFastLED19ClocklessControllerILi15ELi30ELi75ELi45ELNS_6EOrderE66ELi0ELb0ELi50EE15showRGBInternalERNS_15PixelControllerILS1_66EEE+0xbc>
        while(_CYCCNT < (T1+T2-ADJ));
 80a1680:	f8d9 b000 	ldr.w	fp, [r9]
 80a1684:	f1bb 0f60 	cmp.w	fp, #96	; 0x60
 80a1688:	d9fa      	bls.n	80a1680 <_ZN9NSFastLED19ClocklessControllerILi15ELi30ELi75ELi45ELNS_6EOrderE66ELi0ELb0ELi50EE15showRGBInternalERNS_15PixelControllerILS1_66EEE+0xb0>
 80a168a:	e004      	b.n	80a1696 <_ZN9NSFastLED19ClocklessControllerILi15ELi30ELi75ELi45ELNS_6EOrderE66ELi0ELb0ELi50EE15showRGBInternalERNS_15PixelControllerILS1_66EEE+0xc6>
        FastPin<DATA_PIN>::fastset(port, lo);
      } else {
        while(_CYCCNT < (T1-(ADJ/2)));
 80a168c:	f8d9 b000 	ldr.w	fp, [r9]
 80a1690:	f1bb 0f19 	cmp.w	fp, #25
 80a1694:	d9fa      	bls.n	80a168c <_ZN9NSFastLED19ClocklessControllerILi15ELi30ELi75ELi45ELNS_6EOrderE66ELi0ELb0ELi50EE15showRGBInternalERNS_15PixelControllerILS1_66EEE+0xbc>
        FastPin<DATA_PIN>::fastset(port, lo);
      }
      b <<= 1;
 80a1696:	ea4f 0a4a 	mov.w	sl, sl, lsl #1
  #endif

#define _CYCCNT (*(volatile uint32_t*)(0xE0001004UL))

  template<int BITS> __attribute__ ((always_inline)) inline static void writeBits(register uint32_t & next_mark, register data_ptr_t port, register data_t hi, register data_t lo, register uint8_t & b)  {
    for(register uint32_t i = BITS-1; i > 0; i--) {
 80a169a:	3f01      	subs	r7, #1
 80a169c:	614b      	str	r3, [r1, #20]
        FastPin<DATA_PIN>::fastset(port, lo);
      } else {
        while(_CYCCNT < (T1-(ADJ/2)));
        FastPin<DATA_PIN>::fastset(port, lo);
      }
      b <<= 1;
 80a169e:	fa5f fa8a 	uxtb.w	sl, sl
  #endif

#define _CYCCNT (*(volatile uint32_t*)(0xE0001004UL))

  template<int BITS> __attribute__ ((always_inline)) inline static void writeBits(register uint32_t & next_mark, register data_ptr_t port, register data_t hi, register data_t lo, register uint8_t & b)  {
    for(register uint32_t i = BITS-1; i > 0; i--) {
 80a16a2:	d1e2      	bne.n	80a166a <_ZN9NSFastLED19ClocklessControllerILi15ELi30ELi75ELi45ELNS_6EOrderE66ELi0ELb0ELi50EE15showRGBInternalERNS_15PixelControllerILS1_66EEE+0x9a>
        FastPin<DATA_PIN>::fastset(port, lo);
      }
      b <<= 1;
    }

    while(_CYCCNT < (T1+T2+T3-ADJ));
 80a16a4:	6817      	ldr	r7, [r2, #0]
 80a16a6:	2f8d      	cmp	r7, #141	; 0x8d
 80a16a8:	d9fc      	bls.n	80a16a4 <_ZN9NSFastLED19ClocklessControllerILi15ELi30ELi75ELi45ELNS_6EOrderE66ELi0ELb0ELi50EE15showRGBInternalERNS_15PixelControllerILS1_66EEE+0xd4>
    FastPin<DATA_PIN>::fastset(port, hi);
    _CYCCNT = 4;

    if(b&0x80) {
 80a16aa:	f01a 0f80 	tst.w	sl, #128	; 0x80
 80a16ae:	616c      	str	r4, [r5, #20]
      b <<= 1;
    }

    while(_CYCCNT < (T1+T2+T3-ADJ));
    FastPin<DATA_PIN>::fastset(port, hi);
    _CYCCNT = 4;
 80a16b0:	f8c6 e000 	str.w	lr, [r6]

    if(b&0x80) {
 80a16b4:	d003      	beq.n	80a16be <_ZN9NSFastLED19ClocklessControllerILi15ELi30ELi75ELi45ELNS_6EOrderE66ELi0ELb0ELi50EE15showRGBInternalERNS_15PixelControllerILS1_66EEE+0xee>
      while(_CYCCNT < (T1+T2-ADJ));
 80a16b6:	6817      	ldr	r7, [r2, #0]
 80a16b8:	2f60      	cmp	r7, #96	; 0x60
 80a16ba:	d9fc      	bls.n	80a16b6 <_ZN9NSFastLED19ClocklessControllerILi15ELi30ELi75ELi45ELNS_6EOrderE66ELi0ELb0ELi50EE15showRGBInternalERNS_15PixelControllerILS1_66EEE+0xe6>
 80a16bc:	e002      	b.n	80a16c4 <_ZN9NSFastLED19ClocklessControllerILi15ELi30ELi75ELi45ELNS_6EOrderE66ELi0ELb0ELi50EE15showRGBInternalERNS_15PixelControllerILS1_66EEE+0xf4>
      FastPin<DATA_PIN>::fastset(port, lo);
    } else {
      while(_CYCCNT < (T1-(ADJ/2)));
 80a16be:	6817      	ldr	r7, [r2, #0]
 80a16c0:	2f19      	cmp	r7, #25
 80a16c2:	d9fc      	bls.n	80a16be <_ZN9NSFastLED19ClocklessControllerILi15ELi30ELi75ELi45ELNS_6EOrderE66ELi0ELb0ELi50EE15showRGBInternalERNS_15PixelControllerILS1_66EEE+0xee>
 80a16c4:	614b      	str	r3, [r1, #20]
        // Some chipsets pre-cycle the first byte, which means we want to cycle byte 0's dithering separately
        __attribute__((always_inline)) inline void preStepFirstByteDithering() {
            d[RO(0)] = e[RO(0)] - d[RO(0)];
        }

        template<int SLOT>  __attribute__((always_inline)) inline static uint8_t loadByte(PixelController & pc) { return pc.mData[RO(SLOT)]; }
 80a16c6:	6807      	ldr	r7, [r0, #0]
 80a16c8:	783f      	ldrb	r7, [r7, #0]
        template<int SLOT>  __attribute__((always_inline)) inline static uint8_t dither(PixelController & pc, uint8_t b) { return b ? qadd8(b, pc.d[RO(SLOT)]) : 0; }
 80a16ca:	b137      	cbz	r7, 80a16da <_ZN9NSFastLED19ClocklessControllerILi15ELi30ELi75ELi45ELNS_6EOrderE66ELi0ELb0ELi50EE15showRGBInternalERNS_15PixelControllerILS1_66EEE+0x10a>

// qadd8: add one byte to another, saturating at 0xFF
LIB8STATIC uint8_t qadd8( uint8_t i, uint8_t j)
{
#if QADD8_C == 1
    unsigned int t = i + j;
 80a16cc:	f890 a008 	ldrb.w	sl, [r0, #8]
 80a16d0:	4457      	add	r7, sl
 80a16d2:	2fff      	cmp	r7, #255	; 0xff
 80a16d4:	bfa8      	it	ge
 80a16d6:	27ff      	movge	r7, #255	; 0xff
    if( t > 255) t = 255;
    return t;
 80a16d8:	b2ff      	uxtb	r7, r7
//         In other words, it computes i * (scale / 256)
//         4 clocks AVR with MUL, 2 clocks ARM
LIB8STATIC uint8_t scale8( uint8_t i, fract8 scale)
{
#if SCALE8_C == 1
    return ((uint16_t)i * (uint16_t)(scale) ) >> 8;
 80a16da:	f890 a00e 	ldrb.w	sl, [r0, #14]
 80a16de:	fb07 f70a 	mul.w	r7, r7, sl
 80a16e2:	f04f 0a07 	mov.w	sl, #7
 80a16e6:	f3c7 2707 	ubfx	r7, r7, #8, #8

#define _CYCCNT (*(volatile uint32_t*)(0xE0001004UL))

  template<int BITS> __attribute__ ((always_inline)) inline static void writeBits(register uint32_t & next_mark, register data_ptr_t port, register data_t hi, register data_t lo, register uint8_t & b)  {
    for(register uint32_t i = BITS-1; i > 0; i--) {
      while(_CYCCNT < (T1+T2+T3-ADJ));
 80a16ea:	f8d2 b000 	ldr.w	fp, [r2]
 80a16ee:	f1bb 0f8d 	cmp.w	fp, #141	; 0x8d
 80a16f2:	d9fa      	bls.n	80a16ea <_ZN9NSFastLED19ClocklessControllerILi15ELi30ELi75ELi45ELNS_6EOrderE66ELi0ELb0ELi50EE15showRGBInternalERNS_15PixelControllerILS1_66EEE+0x11a>
      FastPin<DATA_PIN>::fastset(port, hi);
      _CYCCNT = 4;
      if(b&0x80) {
 80a16f4:	f017 0f80 	tst.w	r7, #128	; 0x80
 80a16f8:	616c      	str	r4, [r5, #20]

  template<int BITS> __attribute__ ((always_inline)) inline static void writeBits(register uint32_t & next_mark, register data_ptr_t port, register data_t hi, register data_t lo, register uint8_t & b)  {
    for(register uint32_t i = BITS-1; i > 0; i--) {
      while(_CYCCNT < (T1+T2+T3-ADJ));
      FastPin<DATA_PIN>::fastset(port, hi);
      _CYCCNT = 4;
 80a16fa:	f8c6 8000 	str.w	r8, [r6]
      if(b&0x80) {
 80a16fe:	d005      	beq.n	80a170c <_ZN9NSFastLED19ClocklessControllerILi15ELi30ELi75ELi45ELNS_6EOrderE66ELi0ELb0ELi50EE15showRGBInternalERNS_15PixelControllerILS1_66EEE+0x13c>
        while(_CYCCNT < (T1+T2-ADJ));
 80a1700:	f8d2 b000 	ldr.w	fp, [r2]
 80a1704:	f1bb 0f60 	cmp.w	fp, #96	; 0x60
 80a1708:	d9fa      	bls.n	80a1700 <_ZN9NSFastLED19ClocklessControllerILi15ELi30ELi75ELi45ELNS_6EOrderE66ELi0ELb0ELi50EE15showRGBInternalERNS_15PixelControllerILS1_66EEE+0x130>
 80a170a:	e004      	b.n	80a1716 <_ZN9NSFastLED19ClocklessControllerILi15ELi30ELi75ELi45ELNS_6EOrderE66ELi0ELb0ELi50EE15showRGBInternalERNS_15PixelControllerILS1_66EEE+0x146>
        FastPin<DATA_PIN>::fastset(port, lo);
      } else {
        while(_CYCCNT < (T1-(ADJ/2)));
 80a170c:	f8d2 b000 	ldr.w	fp, [r2]
 80a1710:	f1bb 0f19 	cmp.w	fp, #25
 80a1714:	d9fa      	bls.n	80a170c <_ZN9NSFastLED19ClocklessControllerILi15ELi30ELi75ELi45ELNS_6EOrderE66ELi0ELb0ELi50EE15showRGBInternalERNS_15PixelControllerILS1_66EEE+0x13c>
        FastPin<DATA_PIN>::fastset(port, lo);
      }
      b <<= 1;
 80a1716:	007f      	lsls	r7, r7, #1
  #endif

#define _CYCCNT (*(volatile uint32_t*)(0xE0001004UL))

  template<int BITS> __attribute__ ((always_inline)) inline static void writeBits(register uint32_t & next_mark, register data_ptr_t port, register data_t hi, register data_t lo, register uint8_t & b)  {
    for(register uint32_t i = BITS-1; i > 0; i--) {
 80a1718:	f1ba 0a01 	subs.w	sl, sl, #1
 80a171c:	614b      	str	r3, [r1, #20]
        FastPin<DATA_PIN>::fastset(port, lo);
      } else {
        while(_CYCCNT < (T1-(ADJ/2)));
        FastPin<DATA_PIN>::fastset(port, lo);
      }
      b <<= 1;
 80a171e:	b2ff      	uxtb	r7, r7
  #endif

#define _CYCCNT (*(volatile uint32_t*)(0xE0001004UL))

  template<int BITS> __attribute__ ((always_inline)) inline static void writeBits(register uint32_t & next_mark, register data_ptr_t port, register data_t hi, register data_t lo, register uint8_t & b)  {
    for(register uint32_t i = BITS-1; i > 0; i--) {
 80a1720:	d1e3      	bne.n	80a16ea <_ZN9NSFastLED19ClocklessControllerILi15ELi30ELi75ELi45ELNS_6EOrderE66ELi0ELb0ELi50EE15showRGBInternalERNS_15PixelControllerILS1_66EEE+0x11a>
        FastPin<DATA_PIN>::fastset(port, lo);
      }
      b <<= 1;
    }

    while(_CYCCNT < (T1+T2+T3-ADJ));
 80a1722:	f8d2 a000 	ldr.w	sl, [r2]
 80a1726:	f1ba 0f8d 	cmp.w	sl, #141	; 0x8d
 80a172a:	d9fa      	bls.n	80a1722 <_ZN9NSFastLED19ClocklessControllerILi15ELi30ELi75ELi45ELNS_6EOrderE66ELi0ELb0ELi50EE15showRGBInternalERNS_15PixelControllerILS1_66EEE+0x152>
    FastPin<DATA_PIN>::fastset(port, hi);
    _CYCCNT = 4;

    if(b&0x80) {
 80a172c:	063f      	lsls	r7, r7, #24
 80a172e:	616c      	str	r4, [r5, #20]
      b <<= 1;
    }

    while(_CYCCNT < (T1+T2+T3-ADJ));
    FastPin<DATA_PIN>::fastset(port, hi);
    _CYCCNT = 4;
 80a1730:	f8c6 e000 	str.w	lr, [r6]

    if(b&0x80) {
 80a1734:	d503      	bpl.n	80a173e <_ZN9NSFastLED19ClocklessControllerILi15ELi30ELi75ELi45ELNS_6EOrderE66ELi0ELb0ELi50EE15showRGBInternalERNS_15PixelControllerILS1_66EEE+0x16e>
      while(_CYCCNT < (T1+T2-ADJ));
 80a1736:	6817      	ldr	r7, [r2, #0]
 80a1738:	2f60      	cmp	r7, #96	; 0x60
 80a173a:	d9fc      	bls.n	80a1736 <_ZN9NSFastLED19ClocklessControllerILi15ELi30ELi75ELi45ELNS_6EOrderE66ELi0ELb0ELi50EE15showRGBInternalERNS_15PixelControllerILS1_66EEE+0x166>
 80a173c:	e002      	b.n	80a1744 <_ZN9NSFastLED19ClocklessControllerILi15ELi30ELi75ELi45ELNS_6EOrderE66ELi0ELb0ELi50EE15showRGBInternalERNS_15PixelControllerILS1_66EEE+0x174>
      FastPin<DATA_PIN>::fastset(port, lo);
    } else {
      while(_CYCCNT < (T1-(ADJ/2)));
 80a173e:	6817      	ldr	r7, [r2, #0]
 80a1740:	2f19      	cmp	r7, #25
 80a1742:	d9fc      	bls.n	80a173e <_ZN9NSFastLED19ClocklessControllerILi15ELi30ELi75ELi45ELNS_6EOrderE66ELi0ELb0ELi50EE15showRGBInternalERNS_15PixelControllerILS1_66EEE+0x16e>
 80a1744:	614b      	str	r3, [r1, #20]
        // Some chipsets pre-cycle the first byte, which means we want to cycle byte 0's dithering separately
        __attribute__((always_inline)) inline void preStepFirstByteDithering() {
            d[RO(0)] = e[RO(0)] - d[RO(0)];
        }

        template<int SLOT>  __attribute__((always_inline)) inline static uint8_t loadByte(PixelController & pc) { return pc.mData[RO(SLOT)]; }
 80a1746:	6807      	ldr	r7, [r0, #0]
 80a1748:	78bf      	ldrb	r7, [r7, #2]
        template<int SLOT>  __attribute__((always_inline)) inline static uint8_t dither(PixelController & pc, uint8_t b) { return b ? qadd8(b, pc.d[RO(SLOT)]) : 0; }
 80a174a:	b137      	cbz	r7, 80a175a <_ZN9NSFastLED19ClocklessControllerILi15ELi30ELi75ELi45ELNS_6EOrderE66ELi0ELb0ELi50EE15showRGBInternalERNS_15PixelControllerILS1_66EEE+0x18a>

// qadd8: add one byte to another, saturating at 0xFF
LIB8STATIC uint8_t qadd8( uint8_t i, uint8_t j)
{
#if QADD8_C == 1
    unsigned int t = i + j;
 80a174c:	f890 a00a 	ldrb.w	sl, [r0, #10]
 80a1750:	4457      	add	r7, sl
 80a1752:	2fff      	cmp	r7, #255	; 0xff
 80a1754:	bfa8      	it	ge
 80a1756:	27ff      	movge	r7, #255	; 0xff
    if( t > 255) t = 255;
    return t;
 80a1758:	b2ff      	uxtb	r7, r7
//         In other words, it computes i * (scale / 256)
//         4 clocks AVR with MUL, 2 clocks ARM
LIB8STATIC uint8_t scale8( uint8_t i, fract8 scale)
{
#if SCALE8_C == 1
    return ((uint16_t)i * (uint16_t)(scale) ) >> 8;
 80a175a:	f890 a010 	ldrb.w	sl, [r0, #16]
 80a175e:	fb07 f70a 	mul.w	r7, r7, sl
 80a1762:	f04f 0a07 	mov.w	sl, #7
 80a1766:	f3c7 2707 	ubfx	r7, r7, #8, #8

#define _CYCCNT (*(volatile uint32_t*)(0xE0001004UL))

  template<int BITS> __attribute__ ((always_inline)) inline static void writeBits(register uint32_t & next_mark, register data_ptr_t port, register data_t hi, register data_t lo, register uint8_t & b)  {
    for(register uint32_t i = BITS-1; i > 0; i--) {
      while(_CYCCNT < (T1+T2+T3-ADJ));
 80a176a:	f8d2 b000 	ldr.w	fp, [r2]
 80a176e:	f1bb 0f8d 	cmp.w	fp, #141	; 0x8d
 80a1772:	d9fa      	bls.n	80a176a <_ZN9NSFastLED19ClocklessControllerILi15ELi30ELi75ELi45ELNS_6EOrderE66ELi0ELb0ELi50EE15showRGBInternalERNS_15PixelControllerILS1_66EEE+0x19a>
      FastPin<DATA_PIN>::fastset(port, hi);
      _CYCCNT = 4;
      if(b&0x80) {
 80a1774:	f017 0f80 	tst.w	r7, #128	; 0x80
 80a1778:	616c      	str	r4, [r5, #20]

  template<int BITS> __attribute__ ((always_inline)) inline static void writeBits(register uint32_t & next_mark, register data_ptr_t port, register data_t hi, register data_t lo, register uint8_t & b)  {
    for(register uint32_t i = BITS-1; i > 0; i--) {
      while(_CYCCNT < (T1+T2+T3-ADJ));
      FastPin<DATA_PIN>::fastset(port, hi);
      _CYCCNT = 4;
 80a177a:	f8c6 8000 	str.w	r8, [r6]
      if(b&0x80) {
 80a177e:	d005      	beq.n	80a178c <_ZN9NSFastLED19ClocklessControllerILi15ELi30ELi75ELi45ELNS_6EOrderE66ELi0ELb0ELi50EE15showRGBInternalERNS_15PixelControllerILS1_66EEE+0x1bc>
        while(_CYCCNT < (T1+T2-ADJ));
 80a1780:	f8d2 b000 	ldr.w	fp, [r2]
 80a1784:	f1bb 0f60 	cmp.w	fp, #96	; 0x60
 80a1788:	d9fa      	bls.n	80a1780 <_ZN9NSFastLED19ClocklessControllerILi15ELi30ELi75ELi45ELNS_6EOrderE66ELi0ELb0ELi50EE15showRGBInternalERNS_15PixelControllerILS1_66EEE+0x1b0>
 80a178a:	e004      	b.n	80a1796 <_ZN9NSFastLED19ClocklessControllerILi15ELi30ELi75ELi45ELNS_6EOrderE66ELi0ELb0ELi50EE15showRGBInternalERNS_15PixelControllerILS1_66EEE+0x1c6>
        FastPin<DATA_PIN>::fastset(port, lo);
      } else {
        while(_CYCCNT < (T1-(ADJ/2)));
 80a178c:	f8d2 b000 	ldr.w	fp, [r2]
 80a1790:	f1bb 0f19 	cmp.w	fp, #25
 80a1794:	d9fa      	bls.n	80a178c <_ZN9NSFastLED19ClocklessControllerILi15ELi30ELi75ELi45ELNS_6EOrderE66ELi0ELb0ELi50EE15showRGBInternalERNS_15PixelControllerILS1_66EEE+0x1bc>
        FastPin<DATA_PIN>::fastset(port, lo);
      }
      b <<= 1;
 80a1796:	007f      	lsls	r7, r7, #1
  #endif

#define _CYCCNT (*(volatile uint32_t*)(0xE0001004UL))

  template<int BITS> __attribute__ ((always_inline)) inline static void writeBits(register uint32_t & next_mark, register data_ptr_t port, register data_t hi, register data_t lo, register uint8_t & b)  {
    for(register uint32_t i = BITS-1; i > 0; i--) {
 80a1798:	f1ba 0a01 	subs.w	sl, sl, #1
 80a179c:	614b      	str	r3, [r1, #20]
        FastPin<DATA_PIN>::fastset(port, lo);
      } else {
        while(_CYCCNT < (T1-(ADJ/2)));
        FastPin<DATA_PIN>::fastset(port, lo);
      }
      b <<= 1;
 80a179e:	b2ff      	uxtb	r7, r7
  #endif

#define _CYCCNT (*(volatile uint32_t*)(0xE0001004UL))

  template<int BITS> __attribute__ ((always_inline)) inline static void writeBits(register uint32_t & next_mark, register data_ptr_t port, register data_t hi, register data_t lo, register uint8_t & b)  {
    for(register uint32_t i = BITS-1; i > 0; i--) {
 80a17a0:	d1e3      	bne.n	80a176a <_ZN9NSFastLED19ClocklessControllerILi15ELi30ELi75ELi45ELNS_6EOrderE66ELi0ELb0ELi50EE15showRGBInternalERNS_15PixelControllerILS1_66EEE+0x19a>
        FastPin<DATA_PIN>::fastset(port, lo);
      }
      b <<= 1;
    }

    while(_CYCCNT < (T1+T2+T3-ADJ));
 80a17a2:	f8d2 a000 	ldr.w	sl, [r2]
 80a17a6:	f1ba 0f8d 	cmp.w	sl, #141	; 0x8d
 80a17aa:	d9fa      	bls.n	80a17a2 <_ZN9NSFastLED19ClocklessControllerILi15ELi30ELi75ELi45ELNS_6EOrderE66ELi0ELb0ELi50EE15showRGBInternalERNS_15PixelControllerILS1_66EEE+0x1d2>
    FastPin<DATA_PIN>::fastset(port, hi);
    _CYCCNT = 4;

    if(b&0x80) {
 80a17ac:	063f      	lsls	r7, r7, #24
 80a17ae:	616c      	str	r4, [r5, #20]
      b <<= 1;
    }

    while(_CYCCNT < (T1+T2+T3-ADJ));
    FastPin<DATA_PIN>::fastset(port, hi);
    _CYCCNT = 4;
 80a17b0:	f8c6 e000 	str.w	lr, [r6]

    if(b&0x80) {
 80a17b4:	d503      	bpl.n	80a17be <_ZN9NSFastLED19ClocklessControllerILi15ELi30ELi75ELi45ELNS_6EOrderE66ELi0ELb0ELi50EE15showRGBInternalERNS_15PixelControllerILS1_66EEE+0x1ee>
      while(_CYCCNT < (T1+T2-ADJ));
 80a17b6:	6817      	ldr	r7, [r2, #0]
 80a17b8:	2f60      	cmp	r7, #96	; 0x60
 80a17ba:	d9fc      	bls.n	80a17b6 <_ZN9NSFastLED19ClocklessControllerILi15ELi30ELi75ELi45ELNS_6EOrderE66ELi0ELb0ELi50EE15showRGBInternalERNS_15PixelControllerILS1_66EEE+0x1e6>
 80a17bc:	e002      	b.n	80a17c4 <_ZN9NSFastLED19ClocklessControllerILi15ELi30ELi75ELi45ELNS_6EOrderE66ELi0ELb0ELi50EE15showRGBInternalERNS_15PixelControllerILS1_66EEE+0x1f4>
      FastPin<DATA_PIN>::fastset(port, lo);
    } else {
      while(_CYCCNT < (T1-(ADJ/2)));
 80a17be:	6817      	ldr	r7, [r2, #0]
 80a17c0:	2f19      	cmp	r7, #25
 80a17c2:	d9fc      	bls.n	80a17be <_ZN9NSFastLED19ClocklessControllerILi15ELi30ELi75ELi45ELNS_6EOrderE66ELi0ELb0ELi50EE15showRGBInternalERNS_15PixelControllerILS1_66EEE+0x1ee>
 80a17c4:	614b      	str	r3, [r1, #20]

        // get the amount to advance the pointer by
        __attribute__((always_inline)) inline int advanceBy() { return mAdvance; }

        // advance the data pointer forward, adjust position counter
         __attribute__((always_inline)) inline void advanceData() { mData += mAdvance; mLen--;}
 80a17c6:	6807      	ldr	r7, [r0, #0]
 80a17c8:	f890 a011 	ldrb.w	sl, [r0, #17]
 80a17cc:	44ba      	add	sl, r7
 80a17ce:	6847      	ldr	r7, [r0, #4]
 80a17d0:	f8c0 a000 	str.w	sl, [r0]
 80a17d4:	3f01      	subs	r7, #1
 80a17d6:	6047      	str	r7, [r0, #4]
        // Some chipsets pre-cycle the first byte, which means we want to cycle byte 0's dithering separately
        __attribute__((always_inline)) inline void preStepFirstByteDithering() {
            d[RO(0)] = e[RO(0)] - d[RO(0)];
        }

        template<int SLOT>  __attribute__((always_inline)) inline static uint8_t loadByte(PixelController & pc) { return pc.mData[RO(SLOT)]; }
 80a17d8:	f89a 7001 	ldrb.w	r7, [sl, #1]
        template<int SLOT>  __attribute__((always_inline)) inline static uint8_t dither(PixelController & pc, uint8_t b) { return b ? qadd8(b, pc.d[RO(SLOT)]) : 0; }
 80a17dc:	b137      	cbz	r7, 80a17ec <_ZN9NSFastLED19ClocklessControllerILi15ELi30ELi75ELi45ELNS_6EOrderE66ELi0ELb0ELi50EE15showRGBInternalERNS_15PixelControllerILS1_66EEE+0x21c>

// qadd8: add one byte to another, saturating at 0xFF
LIB8STATIC uint8_t qadd8( uint8_t i, uint8_t j)
{
#if QADD8_C == 1
    unsigned int t = i + j;
 80a17de:	f890 a009 	ldrb.w	sl, [r0, #9]
 80a17e2:	4457      	add	r7, sl
 80a17e4:	2fff      	cmp	r7, #255	; 0xff
 80a17e6:	bfa8      	it	ge
 80a17e8:	27ff      	movge	r7, #255	; 0xff
    if( t > 255) t = 255;
    return t;
 80a17ea:	b2ff      	uxtb	r7, r7
//         In other words, it computes i * (scale / 256)
//         4 clocks AVR with MUL, 2 clocks ARM
LIB8STATIC uint8_t scale8( uint8_t i, fract8 scale)
{
#if SCALE8_C == 1
    return ((uint16_t)i * (uint16_t)(scale) ) >> 8;
 80a17ec:	f890 a00f 	ldrb.w	sl, [r0, #15]
 80a17f0:	fb07 fa0a 	mul.w	sl, r7, sl
 80a17f4:	f3ca 2a07 	ubfx	sl, sl, #8, #8
    cli();

    uint32_t next_mark = (T1+T2+T3);

    DWT->CYCCNT = 0;
    while(pixels.has(1)) {
 80a17f8:	e720      	b.n	80a163c <_ZN9NSFastLED19ClocklessControllerILi15ELi30ELi75ELi45ELNS_6EOrderE66ELi0ELb0ELi50EE15showRGBInternalERNS_15PixelControllerILS1_66EEE+0x6c>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i");
 80a17fa:	b662      	cpsie	i
    This function enables FIQ interrupts by clearing the F-bit in the CPSR.
    Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_fault_irq(void)
{
  __ASM volatile ("cpsie f");
 80a17fc:	b661      	cpsie	f
      sei();
      #endif
    };

    sei();
    return DWT->CYCCNT;
 80a17fe:	4b03      	ldr	r3, [pc, #12]	; (80a180c <_ZN9NSFastLED19ClocklessControllerILi15ELi30ELi75ELi45ELNS_6EOrderE66ELi0ELb0ELi50EE15showRGBInternalERNS_15PixelControllerILS1_66EEE+0x23c>)
 80a1800:	6858      	ldr	r0, [r3, #4]
  }
 80a1802:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80a1806:	bf00      	nop
 80a1808:	e000edf0 	.word	0xe000edf0
 80a180c:	e0001000 	.word	0xe0001000
 80a1810:	40020000 	.word	0x40020000
 80a1814:	e0001004 	.word	0xe0001004

080a1818 <_ZN9NSFastLED15PixelControllerILNS_6EOrderE66EE21init_binary_ditheringEv>:
            mData += 1;
            mAdvance = 4;
        }
#endif

        void init_binary_dithering() {
 80a1818:	b530      	push	{r4, r5, lr}
                                  (UPDATES_PER_FULL_DITHER_CYCLE>128) )
#define VIRTUAL_BITS RECOMMENDED_VIRTUAL_BITS

            // R is the digther signal 'counter'.
            static byte R = 0;
            R++;
 80a181a:	4b17      	ldr	r3, [pc, #92]	; (80a1878 <_ZN9NSFastLED15PixelControllerILNS_6EOrderE66EE21init_binary_ditheringEv+0x60>)
            // actual dithering.

            // Setup the initial D and E values
            for(int i = 0; i < 3; i++) {
                    byte s = mScale.raw[i];
                    e[i] = s ? (256/s) + 1 : 0;
 80a181c:	f44f 7580 	mov.w	r5, #256	; 0x100
            R++;

            // R is wrapped around at 2^ditherBits,
            // so if ditherBits is 2, R will cycle through (0,1,2,3)
            byte ditherBits = VIRTUAL_BITS;
            R &= (0x01 << ditherBits) - 1;
 80a1820:	781a      	ldrb	r2, [r3, #0]
 80a1822:	3201      	adds	r2, #1
 80a1824:	f002 0207 	and.w	r2, r2, #7
            // If 'ditherBits' is 2, Q here will cycle through (0,128,64,192)
            byte Q = 0;

            // Reverse bits in a byte
            {
                if(R & 0x01) { Q |= 0x80; }
 80a1828:	f012 0f01 	tst.w	r2, #1
            R++;

            // R is wrapped around at 2^ditherBits,
            // so if ditherBits is 2, R will cycle through (0,1,2,3)
            byte ditherBits = VIRTUAL_BITS;
            R &= (0x01 << ditherBits) - 1;
 80a182c:	701a      	strb	r2, [r3, #0]
            // If 'ditherBits' is 2, Q here will cycle through (0,128,64,192)
            byte Q = 0;

            // Reverse bits in a byte
            {
                if(R & 0x01) { Q |= 0x80; }
 80a182e:	bf0c      	ite	eq
 80a1830:	2300      	moveq	r3, #0
 80a1832:	2380      	movne	r3, #128	; 0x80
                if(R & 0x02) { Q |= 0x40; }
 80a1834:	0791      	lsls	r1, r2, #30
 80a1836:	bf44      	itt	mi
 80a1838:	f043 0340 	orrmi.w	r3, r3, #64	; 0x40
 80a183c:	b2db      	uxtbmi	r3, r3
                if(R & 0x04) { Q |= 0x20; }
 80a183e:	0752      	lsls	r2, r2, #29
 80a1840:	bf48      	it	mi
 80a1842:	f043 0320 	orrmi.w	r3, r3, #32
            // Now we adjust Q to fall in the center of each range,
            // instead of at the start of the range.
            // If ditherBits is 2, Q will be (0, 128, 64, 192) at first,
            // and this adjustment makes it (31, 159, 95, 223).
            if( ditherBits < 8) {
                Q += 0x01 << (7 - ditherBits);
 80a1846:	3310      	adds	r3, #16
 80a1848:	f100 010a 	add.w	r1, r0, #10
 80a184c:	b2da      	uxtb	r2, r3
 80a184e:	300d      	adds	r0, #13
            // which is added to pixel values to affect the
            // actual dithering.

            // Setup the initial D and E values
            for(int i = 0; i < 3; i++) {
                    byte s = mScale.raw[i];
 80a1850:	790b      	ldrb	r3, [r1, #4]
                    e[i] = s ? (256/s) + 1 : 0;
 80a1852:	b11b      	cbz	r3, 80a185c <_ZN9NSFastLED15PixelControllerILNS_6EOrderE66EE21init_binary_ditheringEv+0x44>
 80a1854:	fb95 f3f3 	sdiv	r3, r5, r3
 80a1858:	3301      	adds	r3, #1
 80a185a:	b2db      	uxtb	r3, r3
                    d[i] = scale8(Q, e[i]);
 80a185c:	fb03 f402 	mul.w	r4, r3, r2
            // actual dithering.

            // Setup the initial D and E values
            for(int i = 0; i < 3; i++) {
                    byte s = mScale.raw[i];
                    e[i] = s ? (256/s) + 1 : 0;
 80a1860:	f801 3f01 	strb.w	r3, [r1, #1]!
                    d[i] = scale8(Q, e[i]);
 80a1864:	1224      	asrs	r4, r4, #8
 80a1866:	f801 4c03 	strb.w	r4, [r1, #-3]
                    if(e[i]) e[i]--;
 80a186a:	b10b      	cbz	r3, 80a1870 <_ZN9NSFastLED15PixelControllerILNS_6EOrderE66EE21init_binary_ditheringEv+0x58>
 80a186c:	3b01      	subs	r3, #1
 80a186e:	700b      	strb	r3, [r1, #0]
            // D and E form the "scaled dither signal"
            // which is added to pixel values to affect the
            // actual dithering.

            // Setup the initial D and E values
            for(int i = 0; i < 3; i++) {
 80a1870:	4288      	cmp	r0, r1
 80a1872:	d1ed      	bne.n	80a1850 <_ZN9NSFastLED15PixelControllerILNS_6EOrderE66EE21init_binary_ditheringEv+0x38>
                    e[i] = s ? (256/s) + 1 : 0;
                    d[i] = scale8(Q, e[i]);
                    if(e[i]) e[i]--;
            }
#endif
        }
 80a1874:	bd30      	pop	{r4, r5, pc}
 80a1876:	bf00      	nop
 80a1878:	200003b0 	.word	0x200003b0

080a187c <_ZN9NSFastLED19ClocklessControllerILi15ELi30ELi75ELi45ELNS_6EOrderE66ELi0ELb0ELi50EE4showEPKNS_4CRGBEiS3_>:
    mWait.wait();
    showRGBInternal(pixels);
    mWait.mark();
  }

  virtual void show(const struct CRGB *rgbdata, int nLeds, CRGB scale) {
 80a187c:	b510      	push	{r4, lr}
 80a187e:	b086      	sub	sp, #24
            enable_dithering(dither);
            mData += skip;
            mAdvance = (advance) ? 3+skip : 0;
        }

        PixelController(const CRGB *d, int len, CRGB & s, EDitherMode dither = BINARY_DITHER) : mData((const uint8_t*)d), mLen(len), mScale(s) {
 80a1880:	9202      	str	r2, [sp, #8]
    }

    // allow copy construction
	inline CRGB(const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
 80a1882:	781a      	ldrb	r2, [r3, #0]
 80a1884:	4604      	mov	r4, r0
 80a1886:	7c80      	ldrb	r0, [r0, #18]
 80a1888:	f88d 2012 	strb.w	r2, [sp, #18]
        g = rhs.g;
 80a188c:	785a      	ldrb	r2, [r3, #1]
        b = rhs.b;
 80a188e:	789b      	ldrb	r3, [r3, #2]
            return mLen >= n;
        }

        // toggle dithering enable
        void enable_dithering(EDitherMode dither) {
            switch(dither) {
 80a1890:	2801      	cmp	r0, #1
            enable_dithering(dither);
            mData += skip;
            mAdvance = (advance) ? 3+skip : 0;
        }

        PixelController(const CRGB *d, int len, CRGB & s, EDitherMode dither = BINARY_DITHER) : mData((const uint8_t*)d), mLen(len), mScale(s) {
 80a1892:	9101      	str	r1, [sp, #4]

    // allow copy construction
	inline CRGB(const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
        g = rhs.g;
 80a1894:	f88d 2013 	strb.w	r2, [sp, #19]
        b = rhs.b;
 80a1898:	f88d 3014 	strb.w	r3, [sp, #20]
            return mLen >= n;
        }

        // toggle dithering enable
        void enable_dithering(EDitherMode dither) {
            switch(dither) {
 80a189c:	d103      	bne.n	80a18a6 <_ZN9NSFastLED19ClocklessControllerILi15ELi30ELi75ELi45ELNS_6EOrderE66ELi0ELb0ELi50EE4showEPKNS_4CRGBEiS3_+0x2a>
                case BINARY_DITHER: init_binary_dithering(); break;
 80a189e:	a801      	add	r0, sp, #4
 80a18a0:	f7ff ffba 	bl	80a1818 <_ZN9NSFastLED15PixelControllerILNS_6EOrderE66EE21init_binary_ditheringEv>
 80a18a4:	e00c      	b.n	80a18c0 <_ZN9NSFastLED19ClocklessControllerILi15ELi30ELi75ELi45ELNS_6EOrderE66ELi0ELb0ELi50EE4showEPKNS_4CRGBEiS3_+0x44>
                default: d[0]=d[1]=d[2]=e[0]=e[1]=e[2]=0; break;
 80a18a6:	2300      	movs	r3, #0
 80a18a8:	f88d 3011 	strb.w	r3, [sp, #17]
 80a18ac:	f88d 3010 	strb.w	r3, [sp, #16]
 80a18b0:	f88d 300f 	strb.w	r3, [sp, #15]
 80a18b4:	f88d 300e 	strb.w	r3, [sp, #14]
 80a18b8:	f88d 300d 	strb.w	r3, [sp, #13]
 80a18bc:	f88d 300c 	strb.w	r3, [sp, #12]
            mAdvance = (advance) ? 3+skip : 0;
        }

        PixelController(const CRGB *d, int len, CRGB & s, EDitherMode dither = BINARY_DITHER) : mData((const uint8_t*)d), mLen(len), mScale(s) {
            enable_dithering(dither);
            mAdvance = 3;
 80a18c0:	2303      	movs	r3, #3
    PixelController<RGB_ORDER> pixels(rgbdata, nLeds, scale, getDither());

    mWait.wait();
 80a18c2:	f104 0020 	add.w	r0, r4, #32
 80a18c6:	f88d 3015 	strb.w	r3, [sp, #21]
 80a18ca:	f7ff fe77 	bl	80a15bc <_ZN9NSFastLED8CMinWaitILi50EE4waitEv>
    showRGBInternal(pixels);
 80a18ce:	a801      	add	r0, sp, #4
 80a18d0:	f7ff fe7e 	bl	80a15d0 <_ZN9NSFastLED19ClocklessControllerILi15ELi30ELi75ELi45ELNS_6EOrderE66ELi0ELb0ELi50EE15showRGBInternalERNS_15PixelControllerILS1_66EEE>
 80a18d4:	f000 fcf0 	bl	80a22b8 <HAL_Timer_Get_Micro_Seconds>

	void mark() { mLastMicros = micros() & 0xFFFF; }
 80a18d8:	8420      	strh	r0, [r4, #32]
    mWait.mark();
  }
 80a18da:	b006      	add	sp, #24
 80a18dc:	bd10      	pop	{r4, pc}

080a18de <_ZN9NSFastLED19ClocklessControllerILi15ELi30ELi75ELi45ELNS_6EOrderE66ELi0ELb0ELi50EE9showColorERKNS_4CRGBEiS3_>:
  }

protected:

  // set all the leds on the controller to a given color
  virtual void showColor(const struct CRGB & rgbdata, int nLeds, CRGB scale) {
 80a18de:	b510      	push	{r4, lr}
 80a18e0:	b086      	sub	sp, #24
        }

        PixelController(const CRGB &d, int len, CRGB & s, EDitherMode dither = BINARY_DITHER) : mData((const uint8_t*)&d), mLen(len), mScale(s) {
 80a18e2:	9202      	str	r2, [sp, #8]
    }

    // allow copy construction
	inline CRGB(const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
 80a18e4:	781a      	ldrb	r2, [r3, #0]
 80a18e6:	4604      	mov	r4, r0
 80a18e8:	7c80      	ldrb	r0, [r0, #18]
 80a18ea:	f88d 2012 	strb.w	r2, [sp, #18]
        g = rhs.g;
 80a18ee:	785a      	ldrb	r2, [r3, #1]
        b = rhs.b;
 80a18f0:	789b      	ldrb	r3, [r3, #2]
            return mLen >= n;
        }

        // toggle dithering enable
        void enable_dithering(EDitherMode dither) {
            switch(dither) {
 80a18f2:	2801      	cmp	r0, #1
        PixelController(const CRGB *d, int len, CRGB & s, EDitherMode dither = BINARY_DITHER) : mData((const uint8_t*)d), mLen(len), mScale(s) {
            enable_dithering(dither);
            mAdvance = 3;
        }

        PixelController(const CRGB &d, int len, CRGB & s, EDitherMode dither = BINARY_DITHER) : mData((const uint8_t*)&d), mLen(len), mScale(s) {
 80a18f4:	9101      	str	r1, [sp, #4]

    // allow copy construction
	inline CRGB(const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
        g = rhs.g;
 80a18f6:	f88d 2013 	strb.w	r2, [sp, #19]
        b = rhs.b;
 80a18fa:	f88d 3014 	strb.w	r3, [sp, #20]
            return mLen >= n;
        }

        // toggle dithering enable
        void enable_dithering(EDitherMode dither) {
            switch(dither) {
 80a18fe:	d103      	bne.n	80a1908 <_ZN9NSFastLED19ClocklessControllerILi15ELi30ELi75ELi45ELNS_6EOrderE66ELi0ELb0ELi50EE9showColorERKNS_4CRGBEiS3_+0x2a>
                case BINARY_DITHER: init_binary_dithering(); break;
 80a1900:	a801      	add	r0, sp, #4
 80a1902:	f7ff ff89 	bl	80a1818 <_ZN9NSFastLED15PixelControllerILNS_6EOrderE66EE21init_binary_ditheringEv>
 80a1906:	e00c      	b.n	80a1922 <_ZN9NSFastLED19ClocklessControllerILi15ELi30ELi75ELi45ELNS_6EOrderE66ELi0ELb0ELi50EE9showColorERKNS_4CRGBEiS3_+0x44>
                default: d[0]=d[1]=d[2]=e[0]=e[1]=e[2]=0; break;
 80a1908:	2300      	movs	r3, #0
 80a190a:	f88d 3011 	strb.w	r3, [sp, #17]
 80a190e:	f88d 3010 	strb.w	r3, [sp, #16]
 80a1912:	f88d 300f 	strb.w	r3, [sp, #15]
 80a1916:	f88d 300e 	strb.w	r3, [sp, #14]
 80a191a:	f88d 300d 	strb.w	r3, [sp, #13]
 80a191e:	f88d 300c 	strb.w	r3, [sp, #12]
            mAdvance = 3;
        }

        PixelController(const CRGB &d, int len, CRGB & s, EDitherMode dither = BINARY_DITHER) : mData((const uint8_t*)&d), mLen(len), mScale(s) {
            enable_dithering(dither);
            mAdvance = 0;
 80a1922:	2300      	movs	r3, #0
    PixelController<RGB_ORDER> pixels(rgbdata, nLeds, scale, getDither());

    mWait.wait();
 80a1924:	f104 0020 	add.w	r0, r4, #32
 80a1928:	f88d 3015 	strb.w	r3, [sp, #21]
 80a192c:	f7ff fe46 	bl	80a15bc <_ZN9NSFastLED8CMinWaitILi50EE4waitEv>
    showRGBInternal(pixels);
 80a1930:	a801      	add	r0, sp, #4
 80a1932:	f7ff fe4d 	bl	80a15d0 <_ZN9NSFastLED19ClocklessControllerILi15ELi30ELi75ELi45ELNS_6EOrderE66ELi0ELb0ELi50EE15showRGBInternalERNS_15PixelControllerILS1_66EEE>
 80a1936:	f000 fcbf 	bl	80a22b8 <HAL_Timer_Get_Micro_Seconds>
 80a193a:	8420      	strh	r0, [r4, #32]
    mWait.mark();
  }
 80a193c:	b006      	add	sp, #24
 80a193e:	bd10      	pop	{r4, pc}

080a1940 <_GLOBAL__sub_I_ib_jul01_gp>:
  uint8_t value = directionFlags[index] & andMask;
  if( dir ) {
    value += orMask;
  }
  directionFlags[index] = value;
}
 80a1940:	b570      	push	{r4, r5, r6, lr}
} // namespace particle

// particle::Flag<TagT, ValueT>
template<typename TagT, typename ValueT>
inline particle::Flag<TagT, ValueT>::Flag(ValueT val) :
        val_(val) {
 80a1942:	4b7c      	ldr	r3, [pc, #496]	; (80a1b34 <_GLOBAL__sub_I_ib_jul01_gp+0x1f4>)
 80a1944:	b086      	sub	sp, #24
 80a1946:	2600      	movs	r6, #0
 80a1948:	601e      	str	r6, [r3, #0]
inline int32_t pinReadFast(pin_t _pin)
{
	return ((PIN_MAP[_pin].gpio_peripheral->IDR & PIN_MAP[_pin].gpio_pin) == 0 ? LOW : HIGH);
}
#elif defined(STM32F2XX)
static STM32_Pin_Info* PIN_MAP = HAL_Pin_Map();
 80a194a:	f000 fcdd 	bl	80a2308 <HAL_Pin_Map>
    WAKEUP_REASON_RTC = 2,
    WAKEUP_REASON_PIN_OR_RTC = 3
};

struct SleepResult {
    SleepResult() {}
 80a194e:	f64f 739c 	movw	r3, #65436	; 0xff9c
 80a1952:	4c79      	ldr	r4, [pc, #484]	; (80a1b38 <_GLOBAL__sub_I_ib_jul01_gp+0x1f8>)

class SystemClass {
public:

    SystemClass(System_Mode_TypeDef mode = DEFAULT) {
        set_system_mode(mode);
 80a1954:	2002      	movs	r0, #2
    WAKEUP_REASON_RTC = 2,
    WAKEUP_REASON_PIN_OR_RTC = 3
};

struct SleepResult {
    SleepResult() {}
 80a1956:	8063      	strh	r3, [r4, #2]
 80a1958:	f64f 73ff 	movw	r3, #65535	; 0xffff
        return get_flag(flag) != 0;
    }

    inline int resetReason() const
    {
        int reason = RESET_REASON_NONE;
 80a195c:	ad06      	add	r5, sp, #24
    WAKEUP_REASON_RTC = 2,
    WAKEUP_REASON_PIN_OR_RTC = 3
};

struct SleepResult {
    SleepResult() {}
 80a195e:	80a3      	strh	r3, [r4, #4]
 80a1960:	7026      	strb	r6, [r4, #0]

class SystemClass {
public:

    SystemClass(System_Mode_TypeDef mode = DEFAULT) {
        set_system_mode(mode);
 80a1962:	f000 fdb3 	bl	80a24cc <set_system_mode>
        return get_flag(flag) != 0;
    }

    inline int resetReason() const
    {
        int reason = RESET_REASON_NONE;
 80a1966:	f845 6d04 	str.w	r6, [r5, #-4]!
        HAL_Core_Get_Last_Reset_Info(&reason, nullptr, nullptr);
 80a196a:	4632      	mov	r2, r6
 80a196c:	4631      	mov	r1, r6
 80a196e:	4628      	mov	r0, r5
 80a1970:	f000 fc92 	bl	80a2298 <HAL_Core_Get_Last_Reset_Info>
        return reason;
 80a1974:	9b05      	ldr	r3, [sp, #20]
class SystemClass {
public:

    SystemClass(System_Mode_TypeDef mode = DEFAULT) {
        set_system_mode(mode);
        if (resetReason() == RESET_REASON_POWER_MANAGEMENT) {
 80a1976:	2b1e      	cmp	r3, #30
 80a1978:	d104      	bne.n	80a1984 <_GLOBAL__sub_I_ib_jul01_gp+0x44>
            // Woken up from standby mode
            sleepResult_ = SleepResult(WAKEUP_REASON_PIN_OR_RTC, SYSTEM_ERROR_NONE, WKP);
 80a197a:	2303      	movs	r3, #3
 80a197c:	7023      	strb	r3, [r4, #0]
 80a197e:	2311      	movs	r3, #17
 80a1980:	8066      	strh	r6, [r4, #2]
 80a1982:	80a3      	strh	r3, [r4, #4]
  { juggle2,                "Juggle 2" },
  { fire,                   "Fire" },
  { water,                  "Water" },
  // { analogClock,            "Analog Clock" },
  // { showSolidColor,         "Solid Color" }
};
 80a1984:	4c6d      	ldr	r4, [pc, #436]	; (80a1b3c <_GLOBAL__sub_I_ib_jul01_gp+0x1fc>)
 80a1986:	4b6e      	ldr	r3, [pc, #440]	; (80a1b40 <_GLOBAL__sub_I_ib_jul01_gp+0x200>)
 80a1988:	4620      	mov	r0, r4
 80a198a:	496e      	ldr	r1, [pc, #440]	; (80a1b44 <_GLOBAL__sub_I_ib_jul01_gp+0x204>)
 80a198c:	f840 3b04 	str.w	r3, [r0], #4
 80a1990:	f000 ffae 	bl	80a28f0 <_ZN6StringC1EPK19__FlashStringHelper>
 80a1994:	4b6c      	ldr	r3, [pc, #432]	; (80a1b48 <_GLOBAL__sub_I_ib_jul01_gp+0x208>)
 80a1996:	496d      	ldr	r1, [pc, #436]	; (80a1b4c <_GLOBAL__sub_I_ib_jul01_gp+0x20c>)
 80a1998:	6163      	str	r3, [r4, #20]
 80a199a:	f104 0018 	add.w	r0, r4, #24
 80a199e:	f000 ffa7 	bl	80a28f0 <_ZN6StringC1EPK19__FlashStringHelper>
 80a19a2:	4b6b      	ldr	r3, [pc, #428]	; (80a1b50 <_GLOBAL__sub_I_ib_jul01_gp+0x210>)
 80a19a4:	496b      	ldr	r1, [pc, #428]	; (80a1b54 <_GLOBAL__sub_I_ib_jul01_gp+0x214>)
 80a19a6:	62a3      	str	r3, [r4, #40]	; 0x28
 80a19a8:	f104 002c 	add.w	r0, r4, #44	; 0x2c
 80a19ac:	f000 ffa0 	bl	80a28f0 <_ZN6StringC1EPK19__FlashStringHelper>
 80a19b0:	4b69      	ldr	r3, [pc, #420]	; (80a1b58 <_GLOBAL__sub_I_ib_jul01_gp+0x218>)
 80a19b2:	496a      	ldr	r1, [pc, #424]	; (80a1b5c <_GLOBAL__sub_I_ib_jul01_gp+0x21c>)
 80a19b4:	63e3      	str	r3, [r4, #60]	; 0x3c
 80a19b6:	f104 0040 	add.w	r0, r4, #64	; 0x40
 80a19ba:	f000 ff99 	bl	80a28f0 <_ZN6StringC1EPK19__FlashStringHelper>
 80a19be:	4b68      	ldr	r3, [pc, #416]	; (80a1b60 <_GLOBAL__sub_I_ib_jul01_gp+0x220>)
 80a19c0:	4968      	ldr	r1, [pc, #416]	; (80a1b64 <_GLOBAL__sub_I_ib_jul01_gp+0x224>)
 80a19c2:	6523      	str	r3, [r4, #80]	; 0x50
 80a19c4:	f104 0054 	add.w	r0, r4, #84	; 0x54
 80a19c8:	f000 ff92 	bl	80a28f0 <_ZN6StringC1EPK19__FlashStringHelper>
 80a19cc:	4b66      	ldr	r3, [pc, #408]	; (80a1b68 <_GLOBAL__sub_I_ib_jul01_gp+0x228>)
 80a19ce:	4967      	ldr	r1, [pc, #412]	; (80a1b6c <_GLOBAL__sub_I_ib_jul01_gp+0x22c>)
 80a19d0:	6663      	str	r3, [r4, #100]	; 0x64
 80a19d2:	f104 0068 	add.w	r0, r4, #104	; 0x68
 80a19d6:	f000 ff8b 	bl	80a28f0 <_ZN6StringC1EPK19__FlashStringHelper>
 80a19da:	4b65      	ldr	r3, [pc, #404]	; (80a1b70 <_GLOBAL__sub_I_ib_jul01_gp+0x230>)
 80a19dc:	4965      	ldr	r1, [pc, #404]	; (80a1b74 <_GLOBAL__sub_I_ib_jul01_gp+0x234>)
 80a19de:	67a3      	str	r3, [r4, #120]	; 0x78
 80a19e0:	f104 007c 	add.w	r0, r4, #124	; 0x7c
 80a19e4:	f000 ff84 	bl	80a28f0 <_ZN6StringC1EPK19__FlashStringHelper>
 80a19e8:	4b63      	ldr	r3, [pc, #396]	; (80a1b78 <_GLOBAL__sub_I_ib_jul01_gp+0x238>)
 80a19ea:	4964      	ldr	r1, [pc, #400]	; (80a1b7c <_GLOBAL__sub_I_ib_jul01_gp+0x23c>)
 80a19ec:	f8c4 308c 	str.w	r3, [r4, #140]	; 0x8c
 80a19f0:	f104 0090 	add.w	r0, r4, #144	; 0x90
 80a19f4:	f000 ff7c 	bl	80a28f0 <_ZN6StringC1EPK19__FlashStringHelper>
 80a19f8:	4b61      	ldr	r3, [pc, #388]	; (80a1b80 <_GLOBAL__sub_I_ib_jul01_gp+0x240>)
 80a19fa:	4962      	ldr	r1, [pc, #392]	; (80a1b84 <_GLOBAL__sub_I_ib_jul01_gp+0x244>)
 80a19fc:	f8c4 30a0 	str.w	r3, [r4, #160]	; 0xa0
 80a1a00:	f104 00a4 	add.w	r0, r4, #164	; 0xa4
 80a1a04:	f000 ff74 	bl	80a28f0 <_ZN6StringC1EPK19__FlashStringHelper>
typedef struct { SimplePattern drawFrame;  String name; } PatternAndName;
typedef PatternAndName PatternAndNameList[];

// List of patterns to cycle through.  Each is defined as a separate function below.                                                                                                                                                                                                                    

const PatternAndNameList patterns =
 80a1a08:	4a5f      	ldr	r2, [pc, #380]	; (80a1b88 <_GLOBAL__sub_I_ib_jul01_gp+0x248>)
 80a1a0a:	4960      	ldr	r1, [pc, #384]	; (80a1b8c <_GLOBAL__sub_I_ib_jul01_gp+0x24c>)
 80a1a0c:	2000      	movs	r0, #0
 80a1a0e:	f001 fbc3 	bl	80a3198 <__aeabi_atexit>
int patternCount = ARRAY_SIZE(patterns);

// variables exposed via Particle cloud API (Spark Core is limited to 10)
int brightness = 255;
int patternIndex = 0;
String patternNames = "";
 80a1a12:	495f      	ldr	r1, [pc, #380]	; (80a1b90 <_GLOBAL__sub_I_ib_jul01_gp+0x250>)
 80a1a14:	485f      	ldr	r0, [pc, #380]	; (80a1b94 <_GLOBAL__sub_I_ib_jul01_gp+0x254>)
 80a1a16:	f000 ff6b 	bl	80a28f0 <_ZN6StringC1EPK19__FlashStringHelper>
 80a1a1a:	4a5b      	ldr	r2, [pc, #364]	; (80a1b88 <_GLOBAL__sub_I_ib_jul01_gp+0x248>)
 80a1a1c:	495e      	ldr	r1, [pc, #376]	; (80a1b98 <_GLOBAL__sub_I_ib_jul01_gp+0x258>)
 80a1a1e:	485d      	ldr	r0, [pc, #372]	; (80a1b94 <_GLOBAL__sub_I_ib_jul01_gp+0x254>)
 80a1a20:	f001 fbba 	bl	80a3198 <__aeabi_atexit>
#endif

#include "timer_hal.h"
#include "delay_hal.h"

inline system_tick_t millis(void) { return HAL_Timer_Get_Milli_Seconds(); }
 80a1a24:	f000 fc50 	bl	80a22c8 <HAL_Timer_Get_Milli_Seconds>
int g = 0;
int b = 255;
int flipClock = 0;
int timezone = -6;

unsigned long lastTimeSync = millis();
 80a1a28:	4b5c      	ldr	r3, [pc, #368]	; (80a1b9c <_GLOBAL__sub_I_ib_jul01_gp+0x25c>)
 80a1a2a:	6018      	str	r0, [r3, #0]

CRGB solidColor = CRGB(r, g, b);
 80a1a2c:	4b5c      	ldr	r3, [pc, #368]	; (80a1ba0 <_GLOBAL__sub_I_ib_jul01_gp+0x260>)
 80a1a2e:	485d      	ldr	r0, [pc, #372]	; (80a1ba4 <_GLOBAL__sub_I_ib_jul01_gp+0x264>)
 80a1a30:	7819      	ldrb	r1, [r3, #0]
 80a1a32:	4b5d      	ldr	r3, [pc, #372]	; (80a1ba8 <_GLOBAL__sub_I_ib_jul01_gp+0x268>)
    {
    }

    // allow construction from R, G, B
    inline CRGB( uint8_t ir, uint8_t ig, uint8_t ib)  __attribute__((always_inline))
        : r(ir), g(ig), b(ib)
 80a1a34:	6800      	ldr	r0, [r0, #0]
 80a1a36:	781a      	ldrb	r2, [r3, #0]
 80a1a38:	4b5c      	ldr	r3, [pc, #368]	; (80a1bac <_GLOBAL__sub_I_ib_jul01_gp+0x26c>)
 80a1a3a:	7018      	strb	r0, [r3, #0]
 80a1a3c:	7059      	strb	r1, [r3, #1]
 80a1a3e:	709a      	strb	r2, [r3, #2]
    {
    }

    // allow construction from 32-bit (really 24-bit) bit 0xRRGGBB color code
    inline CRGB( uint32_t colorcode)  __attribute__((always_inline))
    : r((colorcode >> 16) & 0xFF), g((colorcode >> 8) & 0xFF), b((colorcode >> 0) & 0xFF)
 80a1a40:	23ff      	movs	r3, #255	; 0xff
 80a1a42:	2200      	movs	r2, #0
 80a1a44:	f88d 300e 	strb.w	r3, [sp, #14]
 80a1a48:	f88d 3011 	strb.w	r3, [sp, #17]
 80a1a4c:	f88d 3012 	strb.w	r3, [sp, #18]
 80a1a50:	f88d 3014 	strb.w	r3, [sp, #20]
 80a1a54:	f88d 3015 	strb.w	r3, [sp, #21]
 80a1a58:	f88d 3016 	strb.w	r3, [sp, #22]
    {
        fill_gradient_RGB( &(entries[0]), 16, c1, c2, c3);
    }
    CRGBPalette16( const CRGB& c1, const CRGB& c2, const CRGB& c3, const CRGB& c4)
    {
        fill_gradient_RGB( &(entries[0]), 16, c1, c2, c3, c4);
 80a1a5c:	ab04      	add	r3, sp, #16
 80a1a5e:	f88d 2008 	strb.w	r2, [sp, #8]
 80a1a62:	f88d 2009 	strb.w	r2, [sp, #9]
 80a1a66:	f88d 200a 	strb.w	r2, [sp, #10]
 80a1a6a:	f88d 200c 	strb.w	r2, [sp, #12]
 80a1a6e:	f88d 200d 	strb.w	r2, [sp, #13]
 80a1a72:	f88d 2010 	strb.w	r2, [sp, #16]
 80a1a76:	9300      	str	r3, [sp, #0]
 80a1a78:	aa02      	add	r2, sp, #8
 80a1a7a:	ab03      	add	r3, sp, #12
 80a1a7c:	2110      	movs	r1, #16
 80a1a7e:	484c      	ldr	r0, [pc, #304]	; (80a1bb0 <_GLOBAL__sub_I_ib_jul01_gp+0x270>)
 80a1a80:	9501      	str	r5, [sp, #4]
 80a1a82:	f000 fa45 	bl	80a1f10 <_ZN9NSFastLED17fill_gradient_RGBEPNS_4CRGBEtRKS0_S3_S3_S3_>
  ForestColors_p,
  HeatColors_p,
  LavaColors_p,
  PartyColors_p,
  IceColors_p,
};
 80a1a86:	494b      	ldr	r1, [pc, #300]	; (80a1bb4 <_GLOBAL__sub_I_ib_jul01_gp+0x274>)
 80a1a88:	484b      	ldr	r0, [pc, #300]	; (80a1bb8 <_GLOBAL__sub_I_ib_jul01_gp+0x278>)
 80a1a8a:	f7fe ff1f 	bl	80a08cc <_ZN9NSFastLED13CRGBPalette16C1ERA16_Km>
 80a1a8e:	494b      	ldr	r1, [pc, #300]	; (80a1bbc <_GLOBAL__sub_I_ib_jul01_gp+0x27c>)
 80a1a90:	484b      	ldr	r0, [pc, #300]	; (80a1bc0 <_GLOBAL__sub_I_ib_jul01_gp+0x280>)
 80a1a92:	f7fe ff1b 	bl	80a08cc <_ZN9NSFastLED13CRGBPalette16C1ERA16_Km>
 80a1a96:	494b      	ldr	r1, [pc, #300]	; (80a1bc4 <_GLOBAL__sub_I_ib_jul01_gp+0x284>)
 80a1a98:	484b      	ldr	r0, [pc, #300]	; (80a1bc8 <_GLOBAL__sub_I_ib_jul01_gp+0x288>)
 80a1a9a:	f7fe ff17 	bl	80a08cc <_ZN9NSFastLED13CRGBPalette16C1ERA16_Km>
 80a1a9e:	494b      	ldr	r1, [pc, #300]	; (80a1bcc <_GLOBAL__sub_I_ib_jul01_gp+0x28c>)
 80a1aa0:	484b      	ldr	r0, [pc, #300]	; (80a1bd0 <_GLOBAL__sub_I_ib_jul01_gp+0x290>)
 80a1aa2:	f7fe ff13 	bl	80a08cc <_ZN9NSFastLED13CRGBPalette16C1ERA16_Km>
 80a1aa6:	494b      	ldr	r1, [pc, #300]	; (80a1bd4 <_GLOBAL__sub_I_ib_jul01_gp+0x294>)
 80a1aa8:	484b      	ldr	r0, [pc, #300]	; (80a1bd8 <_GLOBAL__sub_I_ib_jul01_gp+0x298>)
 80a1aaa:	f7fe ff0f 	bl	80a08cc <_ZN9NSFastLED13CRGBPalette16C1ERA16_Km>
 80a1aae:	494b      	ldr	r1, [pc, #300]	; (80a1bdc <_GLOBAL__sub_I_ib_jul01_gp+0x29c>)
 80a1ab0:	484b      	ldr	r0, [pc, #300]	; (80a1be0 <_GLOBAL__sub_I_ib_jul01_gp+0x2a0>)
 80a1ab2:	f7fe ff0b 	bl	80a08cc <_ZN9NSFastLED13CRGBPalette16C1ERA16_Km>
 80a1ab6:	494b      	ldr	r1, [pc, #300]	; (80a1be4 <_GLOBAL__sub_I_ib_jul01_gp+0x2a4>)
 80a1ab8:	484b      	ldr	r0, [pc, #300]	; (80a1be8 <_GLOBAL__sub_I_ib_jul01_gp+0x2a8>)
 80a1aba:	f7fe ff07 	bl	80a08cc <_ZN9NSFastLED13CRGBPalette16C1ERA16_Km>
 80a1abe:	494b      	ldr	r1, [pc, #300]	; (80a1bec <_GLOBAL__sub_I_ib_jul01_gp+0x2ac>)
 80a1ac0:	484b      	ldr	r0, [pc, #300]	; (80a1bf0 <_GLOBAL__sub_I_ib_jul01_gp+0x2b0>)
 80a1ac2:	f7fe ff03 	bl	80a08cc <_ZN9NSFastLED13CRGBPalette16C1ERA16_Km>
        entries[12]=c12; entries[13]=c13; entries[14]=c14; entries[15]=c15;
    };

    CRGBPalette16( const CRGBPalette16& rhs)
    {
        memmove8( &(entries[0]), &(rhs.entries[0]), sizeof( entries));
 80a1ac6:	4b3a      	ldr	r3, [pc, #232]	; (80a1bb0 <_GLOBAL__sub_I_ib_jul01_gp+0x270>)
 80a1ac8:	4a4a      	ldr	r2, [pc, #296]	; (80a1bf4 <_GLOBAL__sub_I_ib_jul01_gp+0x2b4>)
 80a1aca:	f103 0130 	add.w	r1, r3, #48	; 0x30
 80a1ace:	f853 0b04 	ldr.w	r0, [r3], #4
 80a1ad2:	428b      	cmp	r3, r1
 80a1ad4:	f842 0b04 	str.w	r0, [r2], #4
 80a1ad8:	d1f9      	bne.n	80a1ace <_GLOBAL__sub_I_ib_jul01_gp+0x18e>
 80a1ada:	2300      	movs	r3, #0
        fill_gradient( &(entries[0]), 16, c1, c2, c3, c4);
    }

    CRGBPalette16( const CRGB& c1)
    {
        fill_solid( &(entries[0]), 16, c1);
 80a1adc:	462a      	mov	r2, r5
 80a1ade:	2110      	movs	r1, #16
 80a1ae0:	4845      	ldr	r0, [pc, #276]	; (80a1bf8 <_GLOBAL__sub_I_ib_jul01_gp+0x2b8>)
 80a1ae2:	f88d 3014 	strb.w	r3, [sp, #20]
 80a1ae6:	f88d 3015 	strb.w	r3, [sp, #21]
 80a1aea:	f88d 3016 	strb.w	r3, [sp, #22]
 80a1aee:	f000 f97c 	bl	80a1dea <_ZN9NSFastLED10fill_solidEPNS_4CRGBEiRKS0_>

uint8_t paletteCount = ARRAY_SIZE(palettes);

CRGBPalette16 currentPalette(CRGB::Black);
CRGBPalette16 targetPalette = palettes[paletteIndex];
 80a1af2:	4b42      	ldr	r3, [pc, #264]	; (80a1bfc <_GLOBAL__sub_I_ib_jul01_gp+0x2bc>)
        entries[12]=c12; entries[13]=c13; entries[14]=c14; entries[15]=c15;
    };

    CRGBPalette16( const CRGBPalette16& rhs)
    {
        memmove8( &(entries[0]), &(rhs.entries[0]), sizeof( entries));
 80a1af4:	2130      	movs	r1, #48	; 0x30
 80a1af6:	781a      	ldrb	r2, [r3, #0]
 80a1af8:	4b2f      	ldr	r3, [pc, #188]	; (80a1bb8 <_GLOBAL__sub_I_ib_jul01_gp+0x278>)
 80a1afa:	fb01 3302 	mla	r3, r1, r2, r3
 80a1afe:	4a40      	ldr	r2, [pc, #256]	; (80a1c00 <_GLOBAL__sub_I_ib_jul01_gp+0x2c0>)
 80a1b00:	1859      	adds	r1, r3, r1
 80a1b02:	f853 0b04 	ldr.w	r0, [r3], #4
 80a1b06:	428b      	cmp	r3, r1
 80a1b08:	f842 0b04 	str.w	r0, [r2], #4
 80a1b0c:	d1f9      	bne.n	80a1b02 <_GLOBAL__sub_I_ib_jul01_gp+0x1c2>
 80a1b0e:	2300      	movs	r3, #0
        fill_gradient( &(entries[0]), 16, c1, c2, c3, c4);
    }

    CRGBPalette16( const CRGB& c1)
    {
        fill_solid( &(entries[0]), 16, c1);
 80a1b10:	462a      	mov	r2, r5
 80a1b12:	2110      	movs	r1, #16
 80a1b14:	483b      	ldr	r0, [pc, #236]	; (80a1c04 <_GLOBAL__sub_I_ib_jul01_gp+0x2c4>)
 80a1b16:	f88d 3014 	strb.w	r3, [sp, #20]
 80a1b1a:	f88d 3015 	strb.w	r3, [sp, #21]
 80a1b1e:	f88d 3016 	strb.w	r3, [sp, #22]
 80a1b22:	f000 f962 	bl	80a1dea <_ZN9NSFastLED10fill_solidEPNS_4CRGBEiRKS0_>
    // will be, by definition, different from the widths in the gradient
    // palette.  This code attempts to preserve "all the colors", rather than
    // the exact stripe widths at the expense of dropping some colors.
    CRGBPalette16( TProgmemRGBGradientPalette_bytes progpal )
    {
        *this = progpal;
 80a1b26:	4938      	ldr	r1, [pc, #224]	; (80a1c08 <_GLOBAL__sub_I_ib_jul01_gp+0x2c8>)
 80a1b28:	4838      	ldr	r0, [pc, #224]	; (80a1c0c <_GLOBAL__sub_I_ib_jul01_gp+0x2cc>)
 80a1b2a:	f7fe fee2 	bl	80a08f2 <_ZN9NSFastLED13CRGBPalette16aSEPKh>
  uint8_t value = directionFlags[index] & andMask;
  if( dir ) {
    value += orMask;
  }
  directionFlags[index] = value;
}
 80a1b2e:	b006      	add	sp, #24
 80a1b30:	bd70      	pop	{r4, r5, r6, pc}
 80a1b32:	bf00      	nop
 80a1b34:	20000bc0 	.word	0x20000bc0
 80a1b38:	2000090c 	.word	0x2000090c
 80a1b3c:	20000858 	.word	0x20000858
 80a1b40:	080a01c5 	.word	0x080a01c5
 80a1b44:	080a3e9c 	.word	0x080a3e9c
 80a1b48:	080a1299 	.word	0x080a1299
 80a1b4c:	080a3ea4 	.word	0x080a3ea4
 80a1b50:	080a0705 	.word	0x080a0705
 80a1b54:	080a3eb9 	.word	0x080a3eb9
 80a1b58:	080a0221 	.word	0x080a0221
 80a1b5c:	080a3ec1 	.word	0x080a3ec1
 80a1b60:	080a0769 	.word	0x080a0769
 80a1b64:	080a3ec6 	.word	0x080a3ec6
 80a1b68:	080a029d 	.word	0x080a029d
 80a1b6c:	080a3ecd 	.word	0x080a3ecd
 80a1b70:	080a0565 	.word	0x080a0565
 80a1b74:	080a3edb 	.word	0x080a3edb
 80a1b78:	080a11f5 	.word	0x080a11f5
 80a1b7c:	080a3ee4 	.word	0x080a3ee4
 80a1b80:	080a1215 	.word	0x080a1215
 80a1b84:	080a3ee9 	.word	0x080a3ee9
 80a1b88:	200003ac 	.word	0x200003ac
 80a1b8c:	080a01a5 	.word	0x080a01a5
 80a1b90:	080a415a 	.word	0x080a415a
 80a1b94:	20000844 	.word	0x20000844
 80a1b98:	080a2863 	.word	0x080a2863
 80a1b9c:	2000077c 	.word	0x2000077c
 80a1ba0:	200003dc 	.word	0x200003dc
 80a1ba4:	200005a4 	.word	0x200005a4
 80a1ba8:	20000330 	.word	0x20000330
 80a1bac:	20000780 	.word	0x20000780
 80a1bb0:	200007d6 	.word	0x200007d6
 80a1bb4:	080a3f48 	.word	0x080a3f48
 80a1bb8:	20000a10 	.word	0x20000a10
 80a1bbc:	080a4088 	.word	0x080a4088
 80a1bc0:	20000a40 	.word	0x20000a40
 80a1bc4:	080a3fc8 	.word	0x080a3fc8
 80a1bc8:	20000a70 	.word	0x20000a70
 80a1bcc:	080a40c8 	.word	0x080a40c8
 80a1bd0:	20000aa0 	.word	0x20000aa0
 80a1bd4:	080a4048 	.word	0x080a4048
 80a1bd8:	20000ad0 	.word	0x20000ad0
 80a1bdc:	080a4008 	.word	0x080a4008
 80a1be0:	20000b00 	.word	0x20000b00
 80a1be4:	080a3f08 	.word	0x080a3f08
 80a1be8:	20000b30 	.word	0x20000b30
 80a1bec:	080a3f88 	.word	0x080a3f88
 80a1bf0:	20000b60 	.word	0x20000b60
 80a1bf4:	20000b90 	.word	0x20000b90
 80a1bf8:	20000942 	.word	0x20000942
 80a1bfc:	20000794 	.word	0x20000794
 80a1c00:	20000814 	.word	0x20000814
 80a1c04:	20000912 	.word	0x20000912
 80a1c08:	080a3dd0 	.word	0x080a3dd0
 80a1c0c:	200007a1 	.word	0x200007a1

080a1c10 <_ZN9NSFastLED14CLEDController13getAdjustmentEh>:
    {
    }

    // allow construction from R, G, B
    inline CRGB( uint8_t ir, uint8_t ig, uint8_t ib)  __attribute__((always_inline))
        : r(ir), g(ig), b(ib)
 80a1c10:	2300      	movs	r3, #0

    CLEDController & setTemperature(CRGB temperature) { m_ColorTemperature = temperature; return *this; }
    CLEDController & setTemperature(ColorTemperature temperature) { m_ColorTemperature = temperature; return *this; }
    CRGB getTemperature() { return m_ColorTemperature; }

    CRGB getAdjustment(uint8_t scale) {
 80a1c12:	b570      	push	{r4, r5, r6, lr}
 80a1c14:	7003      	strb	r3, [r0, #0]
 80a1c16:	7043      	strb	r3, [r0, #1]
 80a1c18:	7083      	strb	r3, [r0, #2]
#if defined(NO_CORRECTION) && (NO_CORRECTION==1)
        return CRGB(scale,scale,scale);
#else
        CRGB adj(0,0,0);

        if(scale > 0) {
 80a1c1a:	b192      	cbz	r2, 80a1c42 <_ZN9NSFastLED14CLEDController13getAdjustmentEh+0x32>
 80a1c1c:	4605      	mov	r5, r0
 80a1c1e:	f101 040b 	add.w	r4, r1, #11
 80a1c22:	310e      	adds	r1, #14
            for(uint8_t i = 0; i < 3; i++) {
                uint8_t cc = m_ColorCorrection.raw[i];
 80a1c24:	f814 6f01 	ldrb.w	r6, [r4, #1]!
                uint8_t ct = m_ColorTemperature.raw[i];
                if(cc > 0 && ct > 0) {
 80a1c28:	b13e      	cbz	r6, 80a1c3a <_ZN9NSFastLED14CLEDController13getAdjustmentEh+0x2a>
        CRGB adj(0,0,0);

        if(scale > 0) {
            for(uint8_t i = 0; i < 3; i++) {
                uint8_t cc = m_ColorCorrection.raw[i];
                uint8_t ct = m_ColorTemperature.raw[i];
 80a1c2a:	78e3      	ldrb	r3, [r4, #3]
                if(cc > 0 && ct > 0) {
 80a1c2c:	b12b      	cbz	r3, 80a1c3a <_ZN9NSFastLED14CLEDController13getAdjustmentEh+0x2a>
                    uint32_t work = (((uint32_t)cc)+1) * (((uint32_t)ct)+1) * scale;
 80a1c2e:	3301      	adds	r3, #1
 80a1c30:	fb06 3303 	mla	r3, r6, r3, r3
 80a1c34:	4353      	muls	r3, r2
                    work /= 0x10000L;
                    adj.raw[i] = work & 0xFF;
 80a1c36:	0c1b      	lsrs	r3, r3, #16
 80a1c38:	702b      	strb	r3, [r5, #0]
        return CRGB(scale,scale,scale);
#else
        CRGB adj(0,0,0);

        if(scale > 0) {
            for(uint8_t i = 0; i < 3; i++) {
 80a1c3a:	428c      	cmp	r4, r1
 80a1c3c:	f105 0501 	add.w	r5, r5, #1
 80a1c40:	d1f0      	bne.n	80a1c24 <_ZN9NSFastLED14CLEDController13getAdjustmentEh+0x14>
            }
        }

        return adj;
#endif
    }
 80a1c42:	bd70      	pop	{r4, r5, r6, pc}

080a1c44 <_ZN9NSFastLED8CFastLED7addLedsEPNS_14CLEDControllerEPNS_4CRGBEii>:
	setMaxRefreshRate(400);
}

CLEDController &CFastLED::addLeds(CLEDController *pLed,
									   struct CRGB *data,
									   int nLedsOrOffset, int nLedsIfOffset) {
 80a1c44:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80a1c46:	4614      	mov	r4, r2
	int nOffset = (nLedsIfOffset > 0) ? nLedsOrOffset : 0;
 80a1c48:	1e1e      	subs	r6, r3, #0
	setMaxRefreshRate(400);
}

CLEDController &CFastLED::addLeds(CLEDController *pLed,
									   struct CRGB *data,
									   int nLedsOrOffset, int nLedsIfOffset) {
 80a1c4a:	460f      	mov	r7, r1
 80a1c4c:	4605      	mov	r5, r0
	int nOffset = (nLedsIfOffset > 0) ? nLedsOrOffset : 0;
	int nLeds = (nLedsIfOffset > 0) ? nLedsIfOffset : nLedsOrOffset;
 80a1c4e:	bfd8      	it	le
 80a1c50:	4616      	movle	r6, r2

	pLed->init();
 80a1c52:	6803      	ldr	r3, [r0, #0]
}

CLEDController &CFastLED::addLeds(CLEDController *pLed,
									   struct CRGB *data,
									   int nLedsOrOffset, int nLedsIfOffset) {
	int nOffset = (nLedsIfOffset > 0) ? nLedsOrOffset : 0;
 80a1c54:	bfd8      	it	le
 80a1c56:	2400      	movle	r4, #0
	int nLeds = (nLedsIfOffset > 0) ? nLedsIfOffset : nLedsOrOffset;

	pLed->init();
 80a1c58:	689b      	ldr	r3, [r3, #8]
        show(data, nLeds, getAdjustment(brightness))
    }
#endif

    CLEDController & setLeds(CRGB *data, int nLeds) {
        m_Data = data;
 80a1c5a:	eb04 0444 	add.w	r4, r4, r4, lsl #1
 80a1c5e:	4798      	blx	r3
 80a1c60:	1939      	adds	r1, r7, r4
 80a1c62:	6069      	str	r1, [r5, #4]
        m_nLeds = nLeds;
 80a1c64:	616e      	str	r6, [r5, #20]
	pLed->setLeds(data + nOffset, nLeds);
	return *pLed;
}
 80a1c66:	4628      	mov	r0, r5
 80a1c68:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	...

080a1c6c <_ZN9NSFastLED8CFastLED13setCorrectionERKNS_4CRGBE>:
		pCur->setTemperature(temp);
		pCur = pCur->next();
	}
}

void CFastLED::setCorrection(const struct CRGB & correction) {
 80a1c6c:	b510      	push	{r4, lr}
    void showColor(const struct CRGB & data, uint8_t brightness=255) {
        showColor(data, m_nLeds, getAdjustment(brightness));
    }

    // navigating the list of controllers
    static CLEDController *head() { return m_pHead; }
 80a1c6e:	4b06      	ldr	r3, [pc, #24]	; (80a1c88 <_ZN9NSFastLED8CFastLED13setCorrectionERKNS_4CRGBE+0x1c>)
 80a1c70:	681b      	ldr	r3, [r3, #0]
	CLEDController *pCur = CLEDController::head();
	while(pCur) {
 80a1c72:	b13b      	cbz	r3, 80a1c84 <_ZN9NSFastLED8CFastLED13setCorrectionERKNS_4CRGBE+0x18>
    }

    // allow copy construction
	inline CRGB(const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
 80a1c74:	780c      	ldrb	r4, [r1, #0]
        g = rhs.g;
 80a1c76:	7848      	ldrb	r0, [r1, #1]
        b = rhs.b;
 80a1c78:	788a      	ldrb	r2, [r1, #2]
    }

    // allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
 80a1c7a:	731c      	strb	r4, [r3, #12]
        g = rhs.g;
 80a1c7c:	7358      	strb	r0, [r3, #13]
        b = rhs.b;
 80a1c7e:	739a      	strb	r2, [r3, #14]
 80a1c80:	689b      	ldr	r3, [r3, #8]
 80a1c82:	e7f6      	b.n	80a1c72 <_ZN9NSFastLED8CFastLED13setCorrectionERKNS_4CRGBE+0x6>
 80a1c84:	bd10      	pop	{r4, pc}
 80a1c86:	bf00      	nop
 80a1c88:	20000be0 	.word	0x20000be0

080a1c8c <_ZN9NSFastLED8CFastLED9setDitherEh>:
 80a1c8c:	4b03      	ldr	r3, [pc, #12]	; (80a1c9c <_ZN9NSFastLED8CFastLED9setDitherEh+0x10>)
 80a1c8e:	681b      	ldr	r3, [r3, #0]
	}
}

void CFastLED::setDither(uint8_t ditherMode)  {
	CLEDController *pCur = CLEDController::head();
	while(pCur) {
 80a1c90:	b113      	cbz	r3, 80a1c98 <_ZN9NSFastLED8CFastLED9setDitherEh+0xc>
    CRGB* leds() { return m_Data; }

    // Reference to the n'th item in the controller
    CRGB &operator[](int x) { return m_Data[x]; }

    inline CLEDController & setDither(uint8_t ditherMode = BINARY_DITHER) { m_DitherMode = ditherMode; return *this; }
 80a1c92:	7499      	strb	r1, [r3, #18]
 80a1c94:	689b      	ldr	r3, [r3, #8]
 80a1c96:	e7fb      	b.n	80a1c90 <_ZN9NSFastLED8CFastLED9setDitherEh+0x4>
 80a1c98:	4770      	bx	lr
 80a1c9a:	bf00      	nop
 80a1c9c:	20000be0 	.word	0x20000be0

080a1ca0 <_ZN9NSFastLED8CFastLED8countFPSEi>:
// }

extern int noise_min;
extern int noise_max;

void CFastLED::countFPS(int nFrames) {
 80a1ca0:	b570      	push	{r4, r5, r6, lr}
  static int br = 0;
  static uint32_t lastframe = 0; // ::millis();

  if(br++ >= nFrames) {
 80a1ca2:	4c0c      	ldr	r4, [pc, #48]	; (80a1cd4 <_ZN9NSFastLED8CFastLED8countFPSEi+0x34>)
// }

extern int noise_min;
extern int noise_max;

void CFastLED::countFPS(int nFrames) {
 80a1ca4:	4606      	mov	r6, r0
  static int br = 0;
  static uint32_t lastframe = 0; // ::millis();

  if(br++ >= nFrames) {
 80a1ca6:	6823      	ldr	r3, [r4, #0]
 80a1ca8:	1c5a      	adds	r2, r3, #1
 80a1caa:	428b      	cmp	r3, r1
 80a1cac:	6022      	str	r2, [r4, #0]
 80a1cae:	db10      	blt.n	80a1cd2 <_ZN9NSFastLED8CFastLED8countFPSEi+0x32>
 80a1cb0:	f000 fb0a 	bl	80a22c8 <HAL_Timer_Get_Milli_Seconds>
		uint32_t now = ::millis();
		now -= lastframe;
		m_nFPS = (br * 1000) / now;
 80a1cb4:	6822      	ldr	r2, [r4, #0]
  static int br = 0;
  static uint32_t lastframe = 0; // ::millis();

  if(br++ >= nFrames) {
		uint32_t now = ::millis();
		now -= lastframe;
 80a1cb6:	4d08      	ldr	r5, [pc, #32]	; (80a1cd8 <_ZN9NSFastLED8CFastLED8countFPSEi+0x38>)
		m_nFPS = (br * 1000) / now;
 80a1cb8:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 80a1cbc:	4353      	muls	r3, r2
 80a1cbe:	682a      	ldr	r2, [r5, #0]
 80a1cc0:	1a80      	subs	r0, r0, r2
 80a1cc2:	fbb3 f3f0 	udiv	r3, r3, r0
 80a1cc6:	8073      	strh	r3, [r6, #2]
    br = 0;
 80a1cc8:	2300      	movs	r3, #0
 80a1cca:	6023      	str	r3, [r4, #0]
 80a1ccc:	f000 fafc 	bl	80a22c8 <HAL_Timer_Get_Milli_Seconds>
    lastframe = ::millis();
 80a1cd0:	6028      	str	r0, [r5, #0]
 80a1cd2:	bd70      	pop	{r4, r5, r6, pc}
 80a1cd4:	20000bd4 	.word	0x20000bd4
 80a1cd8:	20000bd8 	.word	0x20000bd8

080a1cdc <_ZN9NSFastLED8CFastLED4showEh>:
	pLed->init();
	pLed->setLeds(data + nOffset, nLeds);
	return *pLed;
}

void CFastLED::show(uint8_t scale) {
 80a1cdc:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80a1ce0:	4605      	mov	r5, r0
 80a1ce2:	460f      	mov	r7, r1
 80a1ce4:	4c19      	ldr	r4, [pc, #100]	; (80a1d4c <_ZN9NSFastLED8CFastLED4showEh+0x70>)
	// guard against showing too rapidly
	while(m_nMinMicros && ((micros()-lastshow) < m_nMinMicros));
 80a1ce6:	686b      	ldr	r3, [r5, #4]
 80a1ce8:	b133      	cbz	r3, 80a1cf8 <_ZN9NSFastLED8CFastLED4showEh+0x1c>
inline unsigned long micros(void) { return HAL_Timer_Get_Micro_Seconds(); }
 80a1cea:	f000 fae5 	bl	80a22b8 <HAL_Timer_Get_Micro_Seconds>
 80a1cee:	6823      	ldr	r3, [r4, #0]
 80a1cf0:	1ac0      	subs	r0, r0, r3
 80a1cf2:	686b      	ldr	r3, [r5, #4]
 80a1cf4:	4298      	cmp	r0, r3
 80a1cf6:	d3f6      	bcc.n	80a1ce6 <_ZN9NSFastLED8CFastLED4showEh+0xa>
 80a1cf8:	f000 fade 	bl	80a22b8 <HAL_Timer_Get_Micro_Seconds>
	lastshow = micros();
 80a1cfc:	4b13      	ldr	r3, [pc, #76]	; (80a1d4c <_ZN9NSFastLED8CFastLED4showEh+0x70>)
 80a1cfe:	2600      	movs	r6, #0
 80a1d00:	6018      	str	r0, [r3, #0]
    void showColor(const struct CRGB & data, uint8_t brightness=255) {
        showColor(data, m_nLeds, getAdjustment(brightness));
    }

    // navigating the list of controllers
    static CLEDController *head() { return m_pHead; }
 80a1d02:	4b13      	ldr	r3, [pc, #76]	; (80a1d50 <_ZN9NSFastLED8CFastLED4showEh+0x74>)
 80a1d04:	681c      	ldr	r4, [r3, #0]

	CLEDController *pCur = CLEDController::head();
	while(pCur) {
 80a1d06:	b1d4      	cbz	r4, 80a1d3e <_ZN9NSFastLED8CFastLED4showEh+0x62>
		uint8_t d = pCur->getDither();
		if(m_nFPS < 100) { pCur->setDither(0); }
 80a1d08:	886b      	ldrh	r3, [r5, #2]
        showColor(data, nLeds, getAdjustment(brightness));
    }

    // show function using the "attached to this controller" led data
    void showLeds(uint8_t brightness=255) {
        show(m_Data, m_nLeds, getAdjustment(brightness));
 80a1d0a:	f8d4 a004 	ldr.w	sl, [r4, #4]
 80a1d0e:	2b63      	cmp	r3, #99	; 0x63
 80a1d10:	f8d4 b014 	ldr.w	fp, [r4, #20]
 80a1d14:	6823      	ldr	r3, [r4, #0]
 80a1d16:	f894 8012 	ldrb.w	r8, [r4, #18]
 80a1d1a:	4621      	mov	r1, r4
    CRGB* leds() { return m_Data; }

    // Reference to the n'th item in the controller
    CRGB &operator[](int x) { return m_Data[x]; }

    inline CLEDController & setDither(uint8_t ditherMode = BINARY_DITHER) { m_DitherMode = ditherMode; return *this; }
 80a1d1c:	bf98      	it	ls
 80a1d1e:	74a6      	strbls	r6, [r4, #18]
        showColor(data, nLeds, getAdjustment(brightness));
    }

    // show function using the "attached to this controller" led data
    void showLeds(uint8_t brightness=255) {
        show(m_Data, m_nLeds, getAdjustment(brightness));
 80a1d20:	463a      	mov	r2, r7
 80a1d22:	a801      	add	r0, sp, #4
 80a1d24:	f8d3 9004 	ldr.w	r9, [r3, #4]
 80a1d28:	f7ff ff72 	bl	80a1c10 <_ZN9NSFastLED14CLEDController13getAdjustmentEh>
 80a1d2c:	4620      	mov	r0, r4
 80a1d2e:	ab01      	add	r3, sp, #4
 80a1d30:	465a      	mov	r2, fp
 80a1d32:	4651      	mov	r1, sl
 80a1d34:	47c8      	blx	r9
    CRGB* leds() { return m_Data; }

    // Reference to the n'th item in the controller
    CRGB &operator[](int x) { return m_Data[x]; }

    inline CLEDController & setDither(uint8_t ditherMode = BINARY_DITHER) { m_DitherMode = ditherMode; return *this; }
 80a1d36:	f884 8012 	strb.w	r8, [r4, #18]
 80a1d3a:	68a4      	ldr	r4, [r4, #8]
	// guard against showing too rapidly
	while(m_nMinMicros && ((micros()-lastshow) < m_nMinMicros));
	lastshow = micros();

	CLEDController *pCur = CLEDController::head();
	while(pCur) {
 80a1d3c:	e7e3      	b.n	80a1d06 <_ZN9NSFastLED8CFastLED4showEh+0x2a>
		if(m_nFPS < 100) { pCur->setDither(0); }
		pCur->showLeds(scale);
		pCur->setDither(d);
		pCur = pCur->next();
	}
	countFPS();
 80a1d3e:	2119      	movs	r1, #25
 80a1d40:	4628      	mov	r0, r5
 80a1d42:	f7ff ffad 	bl	80a1ca0 <_ZN9NSFastLED8CFastLED8countFPSEi>
}
 80a1d46:	b003      	add	sp, #12
 80a1d48:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80a1d4c:	20000bdc 	.word	0x20000bdc
 80a1d50:	20000be0 	.word	0x20000be0

080a1d54 <_ZN9NSFastLED8CFastLED5delayEm>:
		pCur->clearLedData();
		pCur = pCur->next();
	}
}

void CFastLED::delay(unsigned long ms) {
 80a1d54:	b570      	push	{r4, r5, r6, lr}
 80a1d56:	4604      	mov	r4, r0
 80a1d58:	460e      	mov	r6, r1
#endif

#include "timer_hal.h"
#include "delay_hal.h"

inline system_tick_t millis(void) { return HAL_Timer_Get_Milli_Seconds(); }
 80a1d5a:	f000 fab5 	bl	80a22c8 <HAL_Timer_Get_Milli_Seconds>
 80a1d5e:	4605      	mov	r5, r0
 80a1d60:	f000 fab2 	bl	80a22c8 <HAL_Timer_Get_Milli_Seconds>
	unsigned long start = ::millis();
	while((::millis()-start) < ms) {
 80a1d64:	1b40      	subs	r0, r0, r5
 80a1d66:	42b0      	cmp	r0, r6
 80a1d68:	d207      	bcs.n	80a1d7a <_ZN9NSFastLED8CFastLED5delayEm+0x26>
#ifndef FASTLED_ACCURATE_CLOCK
		// make sure to allow at least one ms to pass to ensure the clock moves
		// forward
		::delay(1);
 80a1d6a:	2001      	movs	r0, #1
 80a1d6c:	f000 fc14 	bl	80a2598 <delay>
	/// Update all our controllers with the current led colors, using the passed in brightness
	/// @param scale temporarily override the scale
	void show(uint8_t scale);

	/// Update all our controllers with the current led colors
	void show() { show(m_Scale); }
 80a1d70:	7821      	ldrb	r1, [r4, #0]
 80a1d72:	4620      	mov	r0, r4
 80a1d74:	f7ff ffb2 	bl	80a1cdc <_ZN9NSFastLED8CFastLED4showEh>
 80a1d78:	e7f2      	b.n	80a1d60 <_ZN9NSFastLED8CFastLED5delayEm+0xc>
 80a1d7a:	bd70      	pop	{r4, r5, r6, pc}

080a1d7c <_GLOBAL__sub_I__ZN9NSFastLED12pSmartMatrixE>:

	}
}
#endif

FASTLED_NAMESPACE_END
 80a1d7c:	b508      	push	{r3, lr}
 80a1d7e:	f000 fac3 	bl	80a2308 <HAL_Pin_Map>
// uint32_t CRGB::Squant = ((uint32_t)((__TIME__[4]-'0') * 28))<<16 | ((__TIME__[6]-'0')*50)<<8 | ((__TIME__[7]-'0')*28);

CFastLED::CFastLED() {
	// clear out the array of led controllers
	// m_nControllers = 0;
	m_Scale = 255;
 80a1d82:	4b04      	ldr	r3, [pc, #16]	; (80a1d94 <_GLOBAL__sub_I__ZN9NSFastLED12pSmartMatrixE+0x18>)
 80a1d84:	22ff      	movs	r2, #255	; 0xff
 80a1d86:	701a      	strb	r2, [r3, #0]
	m_nFPS = 0;
 80a1d88:	2200      	movs	r2, #0
 80a1d8a:	805a      	strh	r2, [r3, #2]
  }
}

void CFastLED::setMaxRefreshRate(uint16_t refresh) {
		if(refresh > 0) {
			m_nMinMicros = 1000000 / refresh;
 80a1d8c:	f640 12c4 	movw	r2, #2500	; 0x9c4
 80a1d90:	605a      	str	r2, [r3, #4]
 80a1d92:	bd08      	pop	{r3, pc}
 80a1d94:	20000bc8 	.word	0x20000bc8

080a1d98 <_GLOBAL__sub_I__ZN9NSFastLED13CloudColors_pE>:
 80a1d98:	f000 bab6 	b.w	80a2308 <HAL_Pin_Map>

080a1d9c <_ZN9NSFastLEDL15nscale8x3_videoERhS0_S0_h>:
#endif
}


LIB8STATIC void nscale8x3_video( uint8_t& r, uint8_t& g, uint8_t& b, fract8 scale)
{
 80a1d9c:	b530      	push	{r4, r5, lr}
#if SCALE8_C == 1
    uint8_t nonzeroscale = (scale != 0) ? 1 : 0;
    r = (r == 0) ? 0 : (((int)r * (int)(scale) ) >> 8) + nonzeroscale;
 80a1d9e:	7804      	ldrb	r4, [r0, #0]


LIB8STATIC void nscale8x3_video( uint8_t& r, uint8_t& g, uint8_t& b, fract8 scale)
{
#if SCALE8_C == 1
    uint8_t nonzeroscale = (scale != 0) ? 1 : 0;
 80a1da0:	1c1d      	adds	r5, r3, #0
 80a1da2:	bf18      	it	ne
 80a1da4:	2501      	movne	r5, #1
    r = (r == 0) ? 0 : (((int)r * (int)(scale) ) >> 8) + nonzeroscale;
 80a1da6:	b11c      	cbz	r4, 80a1db0 <_ZN9NSFastLEDL15nscale8x3_videoERhS0_S0_h+0x14>
 80a1da8:	435c      	muls	r4, r3
 80a1daa:	eb05 2424 	add.w	r4, r5, r4, asr #8
 80a1dae:	b2e4      	uxtb	r4, r4
 80a1db0:	7004      	strb	r4, [r0, #0]
    g = (g == 0) ? 0 : (((int)g * (int)(scale) ) >> 8) + nonzeroscale;
 80a1db2:	7808      	ldrb	r0, [r1, #0]
 80a1db4:	b118      	cbz	r0, 80a1dbe <_ZN9NSFastLEDL15nscale8x3_videoERhS0_S0_h+0x22>
 80a1db6:	4358      	muls	r0, r3
 80a1db8:	eb05 2020 	add.w	r0, r5, r0, asr #8
 80a1dbc:	b2c0      	uxtb	r0, r0
 80a1dbe:	7008      	strb	r0, [r1, #0]
    b = (b == 0) ? 0 : (((int)b * (int)(scale) ) >> 8) + nonzeroscale;
 80a1dc0:	7811      	ldrb	r1, [r2, #0]
 80a1dc2:	b119      	cbz	r1, 80a1dcc <_ZN9NSFastLEDL15nscale8x3_videoERhS0_S0_h+0x30>
 80a1dc4:	434b      	muls	r3, r1
 80a1dc6:	eb05 2323 	add.w	r3, r5, r3, asr #8
 80a1dca:	b2d9      	uxtb	r1, r3
 80a1dcc:	7011      	strb	r1, [r2, #0]
 80a1dce:	bd30      	pop	{r4, r5, pc}

080a1dd0 <_ZN9NSFastLED4CRGB7nscale8Eh>:
//         THIS FUNCTION ALWAYS MODIFIES ITS ARGUMENTS IN PLACE

LIB8STATIC void nscale8x3( uint8_t& r, uint8_t& g, uint8_t& b, fract8 scale)
{
#if SCALE8_C == 1
    r = ((int)r * (int)(scale) ) >> 8;
 80a1dd0:	7802      	ldrb	r2, [r0, #0]
 80a1dd2:	434a      	muls	r2, r1
 80a1dd4:	1212      	asrs	r2, r2, #8
 80a1dd6:	7002      	strb	r2, [r0, #0]
    g = ((int)g * (int)(scale) ) >> 8;
 80a1dd8:	7842      	ldrb	r2, [r0, #1]
 80a1dda:	434a      	muls	r2, r1
 80a1ddc:	1212      	asrs	r2, r2, #8
 80a1dde:	7042      	strb	r2, [r0, #1]
    b = ((int)b * (int)(scale) ) >> 8;
 80a1de0:	7882      	ldrb	r2, [r0, #2]
 80a1de2:	4351      	muls	r1, r2
 80a1de4:	1209      	asrs	r1, r1, #8
 80a1de6:	7081      	strb	r1, [r0, #2]
    // may dim all the way to 100% black.
    inline CRGB& nscale8 (uint8_t scaledown )
    {
        nscale8x3( r, g, b, scaledown);
        return *this;
    }
 80a1de8:	4770      	bx	lr

080a1dea <_ZN9NSFastLED10fill_solidEPNS_4CRGBEiRKS0_>:



void fill_solid( struct CRGB * leds, int numToFill,
                 const struct CRGB& color)
{
 80a1dea:	b510      	push	{r4, lr}
    for( int i = 0; i < numToFill; i++) {
 80a1dec:	2300      	movs	r3, #0
 80a1dee:	428b      	cmp	r3, r1
 80a1df0:	f100 0003 	add.w	r0, r0, #3
 80a1df4:	da0a      	bge.n	80a1e0c <_ZN9NSFastLED10fill_solidEPNS_4CRGBEiRKS0_+0x22>
    }

    // allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
 80a1df6:	7814      	ldrb	r4, [r2, #0]
 80a1df8:	3301      	adds	r3, #1
 80a1dfa:	f800 4c03 	strb.w	r4, [r0, #-3]
        g = rhs.g;
 80a1dfe:	7854      	ldrb	r4, [r2, #1]
 80a1e00:	f800 4c02 	strb.w	r4, [r0, #-2]
        b = rhs.b;
 80a1e04:	7894      	ldrb	r4, [r2, #2]
 80a1e06:	f800 4c01 	strb.w	r4, [r0, #-1]
 80a1e0a:	e7f0      	b.n	80a1dee <_ZN9NSFastLED10fill_solidEPNS_4CRGBEiRKS0_+0x4>
 80a1e0c:	bd10      	pop	{r4, pc}

080a1e0e <_ZN9NSFastLED12fill_rainbowEPNS_4CRGBEihh>:
// }

void fill_rainbow( struct CRGB * pFirstLED, int numToFill,
                  uint8_t initialhue,
                  uint8_t deltahue )
{
 80a1e0e:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 80a1e10:	4606      	mov	r6, r0
 80a1e12:	460f      	mov	r7, r1
 80a1e14:	461d      	mov	r5, r3
    CHSV hsv;
    hsv.hue = initialhue;
    hsv.val = 255;
 80a1e16:	23ff      	movs	r3, #255	; 0xff
 80a1e18:	f88d 3006 	strb.w	r3, [sp, #6]
    hsv.sat = 240;
 80a1e1c:	23f0      	movs	r3, #240	; 0xf0
void fill_rainbow( struct CRGB * pFirstLED, int numToFill,
                  uint8_t initialhue,
                  uint8_t deltahue )
{
    CHSV hsv;
    hsv.hue = initialhue;
 80a1e1e:	f88d 2004 	strb.w	r2, [sp, #4]
    hsv.val = 255;
    hsv.sat = 240;
 80a1e22:	f88d 3005 	strb.w	r3, [sp, #5]
    for( int i = 0; i < numToFill; i++) {
 80a1e26:	2400      	movs	r4, #0
 80a1e28:	42bc      	cmp	r4, r7
 80a1e2a:	da0c      	bge.n	80a1e46 <_ZN9NSFastLED12fill_rainbowEPNS_4CRGBEihh+0x38>
    }

    // allow assignment from HSV color
	inline CRGB& operator= (const CHSV& rhs) __attribute__((always_inline))
    {
        hsv2rgb_rainbow( rhs, *this);
 80a1e2c:	eb04 0144 	add.w	r1, r4, r4, lsl #1
 80a1e30:	4431      	add	r1, r6
 80a1e32:	a801      	add	r0, sp, #4
 80a1e34:	f000 f976 	bl	80a2124 <_ZN9NSFastLED15hsv2rgb_rainbowERKNS_4CHSVERNS_4CRGBE>
        pFirstLED[i] = hsv;
        hsv.hue += deltahue;
 80a1e38:	f89d 2004 	ldrb.w	r2, [sp, #4]
{
    CHSV hsv;
    hsv.hue = initialhue;
    hsv.val = 255;
    hsv.sat = 240;
    for( int i = 0; i < numToFill; i++) {
 80a1e3c:	3401      	adds	r4, #1
        pFirstLED[i] = hsv;
        hsv.hue += deltahue;
 80a1e3e:	442a      	add	r2, r5
 80a1e40:	f88d 2004 	strb.w	r2, [sp, #4]
{
    CHSV hsv;
    hsv.hue = initialhue;
    hsv.val = 255;
    hsv.sat = 240;
    for( int i = 0; i < numToFill; i++) {
 80a1e44:	e7f0      	b.n	80a1e28 <_ZN9NSFastLED12fill_rainbowEPNS_4CRGBEihh+0x1a>
        pFirstLED[i] = hsv;
        hsv.hue += deltahue;
    }
}
 80a1e46:	b003      	add	sp, #12
 80a1e48:	bdf0      	pop	{r4, r5, r6, r7, pc}

080a1e4a <_ZN9NSFastLED17fill_gradient_RGBEPNS_4CRGBEtS0_tS0_>:


void fill_gradient_RGB( CRGB* leds,
                   uint16_t startpos, CRGB startcolor,
                   uint16_t endpos,   CRGB endcolor )
{
 80a1e4a:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    // if the points are in the wrong order, straighten them
    if( endpos < startpos ) {
 80a1e4e:	428b      	cmp	r3, r1


void fill_gradient_RGB( CRGB* leds,
                   uint16_t startpos, CRGB startcolor,
                   uint16_t endpos,   CRGB endcolor )
{
 80a1e50:	9c07      	ldr	r4, [sp, #28]
    // if the points are in the wrong order, straighten them
    if( endpos < startpos ) {
 80a1e52:	d214      	bcs.n	80a1e7e <_ZN9NSFastLED17fill_gradient_RGBEPNS_4CRGBEtS0_tS0_+0x34>
    }

    // allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
 80a1e54:	f892 e000 	ldrb.w	lr, [r2]
    // allow copy construction
	inline CRGB(const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
        g = rhs.g;
        b = rhs.b;
 80a1e58:	78a5      	ldrb	r5, [r4, #2]
    }

    // allow copy construction
	inline CRGB(const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
 80a1e5a:	7827      	ldrb	r7, [r4, #0]
    }

    // allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
 80a1e5c:	f884 e000 	strb.w	lr, [r4]
        g = rhs.g;
 80a1e60:	f892 e001 	ldrb.w	lr, [r2, #1]

    // allow copy construction
	inline CRGB(const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
        g = rhs.g;
 80a1e64:	7866      	ldrb	r6, [r4, #1]

    // allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
        g = rhs.g;
 80a1e66:	f884 e001 	strb.w	lr, [r4, #1]
        b = rhs.b;
 80a1e6a:	f892 e002 	ldrb.w	lr, [r2, #2]
 80a1e6e:	7095      	strb	r5, [r2, #2]
 80a1e70:	460d      	mov	r5, r1
 80a1e72:	4619      	mov	r1, r3
 80a1e74:	462b      	mov	r3, r5
 80a1e76:	f884 e002 	strb.w	lr, [r4, #2]
    }

    // allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
 80a1e7a:	7017      	strb	r7, [r2, #0]
        g = rhs.g;
 80a1e7c:	7056      	strb	r6, [r2, #1]

    saccum87 rdistance87;
    saccum87 gdistance87;
    saccum87 bdistance87;

    rdistance87 = (endcolor.r - startcolor.r) << 7;
 80a1e7e:	f892 c000 	ldrb.w	ip, [r2]
    gdistance87 = (endcolor.g - startcolor.g) << 7;
 80a1e82:	f892 e001 	ldrb.w	lr, [r2, #1]
    bdistance87 = (endcolor.b - startcolor.b) << 7;
 80a1e86:	f892 8002 	ldrb.w	r8, [r2, #2]
 80a1e8a:	78a2      	ldrb	r2, [r4, #2]

    saccum87 rdistance87;
    saccum87 gdistance87;
    saccum87 bdistance87;

    rdistance87 = (endcolor.r - startcolor.r) << 7;
 80a1e8c:	7827      	ldrb	r7, [r4, #0]
    gdistance87 = (endcolor.g - startcolor.g) << 7;
    bdistance87 = (endcolor.b - startcolor.b) << 7;
 80a1e8e:	ebc8 0202 	rsb	r2, r8, r2
    saccum87 rdistance87;
    saccum87 gdistance87;
    saccum87 bdistance87;

    rdistance87 = (endcolor.r - startcolor.r) << 7;
    gdistance87 = (endcolor.g - startcolor.g) << 7;
 80a1e92:	7866      	ldrb	r6, [r4, #1]
    bdistance87 = (endcolor.b - startcolor.b) << 7;
 80a1e94:	01d5      	lsls	r5, r2, #7

    uint16_t pixeldistance = endpos - startpos;
 80a1e96:	1a5a      	subs	r2, r3, r1

    saccum87 rdistance87;
    saccum87 gdistance87;
    saccum87 bdistance87;

    rdistance87 = (endcolor.r - startcolor.r) << 7;
 80a1e98:	ebcc 0707 	rsb	r7, ip, r7
    gdistance87 = (endcolor.g - startcolor.g) << 7;
 80a1e9c:	ebce 0606 	rsb	r6, lr, r6
    bdistance87 = (endcolor.b - startcolor.b) << 7;

    uint16_t pixeldistance = endpos - startpos;
 80a1ea0:	b292      	uxth	r2, r2

    saccum87 rdistance87;
    saccum87 gdistance87;
    saccum87 bdistance87;

    rdistance87 = (endcolor.r - startcolor.r) << 7;
 80a1ea2:	01ff      	lsls	r7, r7, #7
    gdistance87 = (endcolor.g - startcolor.g) << 7;
 80a1ea4:	01f6      	lsls	r6, r6, #7
    bdistance87 = (endcolor.b - startcolor.b) << 7;

    uint16_t pixeldistance = endpos - startpos;
    int16_t divisor = pixeldistance ? pixeldistance : 1;
 80a1ea6:	b10a      	cbz	r2, 80a1eac <_ZN9NSFastLED17fill_gradient_RGBEPNS_4CRGBEtS0_tS0_+0x62>
 80a1ea8:	b212      	sxth	r2, r2
 80a1eaa:	e000      	b.n	80a1eae <_ZN9NSFastLED17fill_gradient_RGBEPNS_4CRGBEtS0_tS0_+0x64>
 80a1eac:	2201      	movs	r2, #1

    saccum87 rdelta87 = rdistance87 / divisor;
    saccum87 gdelta87 = gdistance87 / divisor;
    saccum87 bdelta87 = bdistance87 / divisor;

    rdelta87 *= 2;
 80a1eae:	fb97 f7f2 	sdiv	r7, r7, r2
    gdelta87 *= 2;
 80a1eb2:	fb96 f6f2 	sdiv	r6, r6, r2
    bdelta87 *= 2;
 80a1eb6:	fb95 f2f2 	sdiv	r2, r5, r2

    saccum87 rdelta87 = rdistance87 / divisor;
    saccum87 gdelta87 = gdistance87 / divisor;
    saccum87 bdelta87 = bdistance87 / divisor;

    rdelta87 *= 2;
 80a1eba:	007f      	lsls	r7, r7, #1
    gdelta87 *= 2;
 80a1ebc:	0076      	lsls	r6, r6, #1
    bdelta87 *= 2;
 80a1ebe:	0052      	lsls	r2, r2, #1

    saccum87 rdelta87 = rdistance87 / divisor;
    saccum87 gdelta87 = gdistance87 / divisor;
    saccum87 bdelta87 = bdistance87 / divisor;

    rdelta87 *= 2;
 80a1ec0:	b2bf      	uxth	r7, r7
    gdelta87 *= 2;
 80a1ec2:	b2b6      	uxth	r6, r6
    bdelta87 *= 2;
 80a1ec4:	b292      	uxth	r2, r2

    accum88 r88 = startcolor.r << 8;
 80a1ec6:	ea4f 2c0c 	mov.w	ip, ip, lsl #8
    accum88 g88 = startcolor.g << 8;
 80a1eca:	ea4f 2e0e 	mov.w	lr, lr, lsl #8
    accum88 b88 = startcolor.b << 8;
 80a1ece:	ea4f 2408 	mov.w	r4, r8, lsl #8
    for( uint16_t i = startpos; i <= endpos; i++) {
 80a1ed2:	428b      	cmp	r3, r1
 80a1ed4:	d31a      	bcc.n	80a1f0c <_ZN9NSFastLED17fill_gradient_RGBEPNS_4CRGBEtS0_tS0_+0xc2>
        leds[i] = CRGB( r88 >> 8, g88 >> 8, b88 >> 8);
 80a1ed6:	eb01 0841 	add.w	r8, r1, r1, lsl #1
    }

    // allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
 80a1eda:	ea4f 292c 	mov.w	r9, ip, asr #8
 80a1ede:	eb00 0508 	add.w	r5, r0, r8
 80a1ee2:	f800 9008 	strb.w	r9, [r0, r8]
        g = rhs.g;
 80a1ee6:	ea4f 282e 	mov.w	r8, lr, asr #8
 80a1eea:	f885 8001 	strb.w	r8, [r5, #1]
        r88 += rdelta87;
 80a1eee:	44bc      	add	ip, r7
        b = rhs.b;
 80a1ef0:	ea4f 2824 	mov.w	r8, r4, asr #8
        g88 += gdelta87;
 80a1ef4:	44b6      	add	lr, r6
        b88 += bdelta87;
 80a1ef6:	4414      	add	r4, r2
    bdelta87 *= 2;

    accum88 r88 = startcolor.r << 8;
    accum88 g88 = startcolor.g << 8;
    accum88 b88 = startcolor.b << 8;
    for( uint16_t i = startpos; i <= endpos; i++) {
 80a1ef8:	3101      	adds	r1, #1
 80a1efa:	f885 8002 	strb.w	r8, [r5, #2]
        leds[i] = CRGB( r88 >> 8, g88 >> 8, b88 >> 8);
        r88 += rdelta87;
 80a1efe:	fa1f fc8c 	uxth.w	ip, ip
        g88 += gdelta87;
 80a1f02:	fa1f fe8e 	uxth.w	lr, lr
        b88 += bdelta87;
 80a1f06:	b2a4      	uxth	r4, r4
    bdelta87 *= 2;

    accum88 r88 = startcolor.r << 8;
    accum88 g88 = startcolor.g << 8;
    accum88 b88 = startcolor.b << 8;
    for( uint16_t i = startpos; i <= endpos; i++) {
 80a1f08:	b289      	uxth	r1, r1
 80a1f0a:	e7e2      	b.n	80a1ed2 <_ZN9NSFastLED17fill_gradient_RGBEPNS_4CRGBEtS0_tS0_+0x88>
 80a1f0c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

080a1f10 <_ZN9NSFastLED17fill_gradient_RGBEPNS_4CRGBEtRKS0_S3_S3_S3_>:
    fill_gradient_RGB( leds,    0, c1, half, c2);
    fill_gradient_RGB( leds, half, c2, last, c3);
}

void fill_gradient_RGB( CRGB* leds, uint16_t numLeds, const CRGB& c1, const CRGB& c2, const CRGB& c3, const CRGB& c4)
{
 80a1f10:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80a1f14:	461e      	mov	r6, r3
    uint16_t onethird = (numLeds / 3);
 80a1f16:	2403      	movs	r4, #3
 80a1f18:	fbb1 fbf4 	udiv	fp, r1, r4
    uint16_t twothirds = ((numLeds * 2) / 3);
 80a1f1c:	004b      	lsls	r3, r1, #1
 80a1f1e:	fb93 f4f4 	sdiv	r4, r3, r4
    }

    // allow copy construction
	inline CRGB(const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
 80a1f22:	7813      	ldrb	r3, [r2, #0]
    fill_gradient_RGB( leds,    0, c1, half, c2);
    fill_gradient_RGB( leds, half, c2, last, c3);
}

void fill_gradient_RGB( CRGB* leds, uint16_t numLeds, const CRGB& c1, const CRGB& c2, const CRGB& c3, const CRGB& c4)
{
 80a1f24:	b085      	sub	sp, #20
 80a1f26:	f88d 3008 	strb.w	r3, [sp, #8]
        g = rhs.g;
 80a1f2a:	7853      	ldrb	r3, [r2, #1]
 80a1f2c:	460f      	mov	r7, r1
 80a1f2e:	f88d 3009 	strb.w	r3, [sp, #9]
        b = rhs.b;
 80a1f32:	7893      	ldrb	r3, [r2, #2]
    uint16_t onethird = (numLeds / 3);
    uint16_t twothirds = ((numLeds * 2) / 3);
    uint16_t last = numLeds - 1;
    fill_gradient_RGB( leds,         0, c1,  onethird, c2);
 80a1f34:	f10d 080c 	add.w	r8, sp, #12
 80a1f38:	f88d 300a 	strb.w	r3, [sp, #10]
    }

    // allow copy construction
	inline CRGB(const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
 80a1f3c:	7833      	ldrb	r3, [r6, #0]
 80a1f3e:	aa02      	add	r2, sp, #8
 80a1f40:	f88d 300c 	strb.w	r3, [sp, #12]
        g = rhs.g;
 80a1f44:	7873      	ldrb	r3, [r6, #1]
 80a1f46:	f8cd 8000 	str.w	r8, [sp]
 80a1f4a:	f88d 300d 	strb.w	r3, [sp, #13]
        b = rhs.b;
 80a1f4e:	78b3      	ldrb	r3, [r6, #2]
 80a1f50:	2100      	movs	r1, #0
 80a1f52:	f88d 300e 	strb.w	r3, [sp, #14]
 80a1f56:	465b      	mov	r3, fp
    fill_gradient_RGB( leds,    0, c1, half, c2);
    fill_gradient_RGB( leds, half, c2, last, c3);
}

void fill_gradient_RGB( CRGB* leds, uint16_t numLeds, const CRGB& c1, const CRGB& c2, const CRGB& c3, const CRGB& c4)
{
 80a1f58:	9d0e      	ldr	r5, [sp, #56]	; 0x38
 80a1f5a:	f8dd 903c 	ldr.w	r9, [sp, #60]	; 0x3c
    uint16_t onethird = (numLeds / 3);
    uint16_t twothirds = ((numLeds * 2) / 3);
    uint16_t last = numLeds - 1;
    fill_gradient_RGB( leds,         0, c1,  onethird, c2);
 80a1f5e:	f7ff ff74 	bl	80a1e4a <_ZN9NSFastLED17fill_gradient_RGBEPNS_4CRGBEtS0_tS0_>
    }

    // allow copy construction
	inline CRGB(const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
 80a1f62:	7833      	ldrb	r3, [r6, #0]
}

void fill_gradient_RGB( CRGB* leds, uint16_t numLeds, const CRGB& c1, const CRGB& c2, const CRGB& c3, const CRGB& c4)
{
    uint16_t onethird = (numLeds / 3);
    uint16_t twothirds = ((numLeds * 2) / 3);
 80a1f64:	b2a4      	uxth	r4, r4
 80a1f66:	f88d 3008 	strb.w	r3, [sp, #8]
        g = rhs.g;
 80a1f6a:	7873      	ldrb	r3, [r6, #1]
    uint16_t last = numLeds - 1;
    fill_gradient_RGB( leds,         0, c1,  onethird, c2);
    fill_gradient_RGB( leds,  onethird, c2, twothirds, c3);
 80a1f6c:	aa02      	add	r2, sp, #8
 80a1f6e:	f88d 3009 	strb.w	r3, [sp, #9]
        b = rhs.b;
 80a1f72:	78b3      	ldrb	r3, [r6, #2]
 80a1f74:	4659      	mov	r1, fp
 80a1f76:	f88d 300a 	strb.w	r3, [sp, #10]
    }

    // allow copy construction
	inline CRGB(const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
 80a1f7a:	782b      	ldrb	r3, [r5, #0]
 80a1f7c:	f88d 300c 	strb.w	r3, [sp, #12]
        g = rhs.g;
 80a1f80:	786b      	ldrb	r3, [r5, #1]
 80a1f82:	f88d 300d 	strb.w	r3, [sp, #13]
        b = rhs.b;
 80a1f86:	78ab      	ldrb	r3, [r5, #2]
 80a1f88:	f8cd 8000 	str.w	r8, [sp]
 80a1f8c:	f88d 300e 	strb.w	r3, [sp, #14]
 80a1f90:	4623      	mov	r3, r4
 80a1f92:	f7ff ff5a 	bl	80a1e4a <_ZN9NSFastLED17fill_gradient_RGBEPNS_4CRGBEtS0_tS0_>
    }

    // allow copy construction
	inline CRGB(const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
 80a1f96:	782b      	ldrb	r3, [r5, #0]
    fill_gradient_RGB( leds, twothirds, c3,      last, c4);
 80a1f98:	aa02      	add	r2, sp, #8
 80a1f9a:	f88d 3008 	strb.w	r3, [sp, #8]
        g = rhs.g;
 80a1f9e:	786b      	ldrb	r3, [r5, #1]
 80a1fa0:	4621      	mov	r1, r4
 80a1fa2:	f88d 3009 	strb.w	r3, [sp, #9]
        b = rhs.b;
 80a1fa6:	78ab      	ldrb	r3, [r5, #2]
 80a1fa8:	f88d 300a 	strb.w	r3, [sp, #10]
    }

    // allow copy construction
	inline CRGB(const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
 80a1fac:	f899 3000 	ldrb.w	r3, [r9]
 80a1fb0:	f88d 300c 	strb.w	r3, [sp, #12]
        g = rhs.g;
 80a1fb4:	f899 3001 	ldrb.w	r3, [r9, #1]
 80a1fb8:	f88d 300d 	strb.w	r3, [sp, #13]
        b = rhs.b;
 80a1fbc:	f899 3002 	ldrb.w	r3, [r9, #2]
 80a1fc0:	f8cd 8000 	str.w	r8, [sp]
 80a1fc4:	f88d 300e 	strb.w	r3, [sp, #14]
 80a1fc8:	1e7b      	subs	r3, r7, #1
 80a1fca:	b29b      	uxth	r3, r3
 80a1fcc:	f7ff ff3d 	bl	80a1e4a <_ZN9NSFastLED17fill_gradient_RGBEPNS_4CRGBEtS0_tS0_>
}
 80a1fd0:	b005      	add	sp, #20
 80a1fd2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

080a1fd6 <_ZN9NSFastLED7nscale8EPNS_4CRGBEth>:
{
    nscale8( leds, num_leds, scale);
}

void nscale8( CRGB* leds, uint16_t num_leds, uint8_t scale)
{
 80a1fd6:	b570      	push	{r4, r5, r6, lr}
 80a1fd8:	4616      	mov	r6, r2
 80a1fda:	4604      	mov	r4, r0
 80a1fdc:	eb01 0141 	add.w	r1, r1, r1, lsl #1
 80a1fe0:	1845      	adds	r5, r0, r1
    for( uint16_t i = 0; i < num_leds; i++) {
 80a1fe2:	42ac      	cmp	r4, r5
 80a1fe4:	d005      	beq.n	80a1ff2 <_ZN9NSFastLED7nscale8EPNS_4CRGBEth+0x1c>
        leds[i].nscale8( scale);
 80a1fe6:	4620      	mov	r0, r4
 80a1fe8:	4631      	mov	r1, r6
 80a1fea:	f7ff fef1 	bl	80a1dd0 <_ZN9NSFastLED4CRGB7nscale8Eh>
 80a1fee:	3403      	adds	r4, #3
    nscale8( leds, num_leds, scale);
}

void nscale8( CRGB* leds, uint16_t num_leds, uint8_t scale)
{
    for( uint16_t i = 0; i < num_leds; i++) {
 80a1ff0:	e7f7      	b.n	80a1fe2 <_ZN9NSFastLED7nscale8EPNS_4CRGBEth+0xc>
 80a1ff2:	bd70      	pop	{r4, r5, r6, pc}

080a1ff4 <_ZN9NSFastLED8fade_rawEPNS_4CRGBEth>:
    nscale8( leds, num_leds, 255 - fadeBy);
}

void fade_raw( CRGB* leds, uint16_t num_leds, uint8_t fadeBy)
{
    nscale8( leds, num_leds, 255 - fadeBy);
 80a1ff4:	43d2      	mvns	r2, r2
 80a1ff6:	b2d2      	uxtb	r2, r2
 80a1ff8:	f7ff bfed 	b.w	80a1fd6 <_ZN9NSFastLED7nscale8EPNS_4CRGBEth>

080a1ffc <_ZN9NSFastLED13fadeToBlackByEPNS_4CRGBEth>:
 80a1ffc:	f7ff bffa 	b.w	80a1ff4 <_ZN9NSFastLED8fade_rawEPNS_4CRGBEth>

080a2000 <_ZN9NSFastLED16ColorFromPaletteERKNS_13CRGBPalette16EhhNS_10TBlendTypeE>:
}



CRGB ColorFromPalette( const CRGBPalette16& pal, uint8_t index, uint8_t brightness, TBlendType blendType)
{
 80a2000:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    uint8_t hi4 = index >> 4;
 80a2002:	1117      	asrs	r7, r2, #4
}



CRGB ColorFromPalette( const CRGBPalette16& pal, uint8_t index, uint8_t brightness, TBlendType blendType)
{
 80a2004:	4605      	mov	r5, r0
    uint8_t hi4 = index >> 4;
    uint8_t lo4 = index & 0x0F;

    //  CRGB rgb1 = pal[ hi4];
    const CRGB* entry = &(pal[0]) + hi4;
 80a2006:	eb07 0047 	add.w	r0, r7, r7, lsl #1
 80a200a:	180c      	adds	r4, r1, r0
    uint8_t red1   = entry->red;
    uint8_t green1 = entry->green;
 80a200c:	7866      	ldrb	r6, [r4, #1]
    uint8_t hi4 = index >> 4;
    uint8_t lo4 = index & 0x0F;

    //  CRGB rgb1 = pal[ hi4];
    const CRGB* entry = &(pal[0]) + hi4;
    uint8_t red1   = entry->red;
 80a200e:	5c08      	ldrb	r0, [r1, r0]
    uint8_t green1 = entry->green;
    uint8_t blue1  = entry->blue;
 80a2010:	f894 e002 	ldrb.w	lr, [r4, #2]

    uint8_t blend = lo4 && (blendType != NOBLEND);
 80a2014:	f012 020f 	ands.w	r2, r2, #15
    uint8_t hi4 = index >> 4;
    uint8_t lo4 = index & 0x0F;

    //  CRGB rgb1 = pal[ hi4];
    const CRGB* entry = &(pal[0]) + hi4;
    uint8_t red1   = entry->red;
 80a2018:	f88d 0005 	strb.w	r0, [sp, #5]
    uint8_t green1 = entry->green;
 80a201c:	f88d 6006 	strb.w	r6, [sp, #6]
    uint8_t blue1  = entry->blue;
 80a2020:	f88d e007 	strb.w	lr, [sp, #7]

    uint8_t blend = lo4 && (blendType != NOBLEND);
 80a2024:	d027      	beq.n	80a2076 <_ZN9NSFastLED16ColorFromPaletteERKNS_13CRGBPalette16EhhNS_10TBlendTypeE+0x76>
 80a2026:	f89d c020 	ldrb.w	ip, [sp, #32]
 80a202a:	f1bc 0f00 	cmp.w	ip, #0
 80a202e:	d022      	beq.n	80a2076 <_ZN9NSFastLED16ColorFromPaletteERKNS_13CRGBPalette16EhhNS_10TBlendTypeE+0x76>

    if( blend ) {

        if( hi4 == 15 ) {
 80a2030:	2f0f      	cmp	r7, #15
 80a2032:	d000      	beq.n	80a2036 <_ZN9NSFastLED16ColorFromPaletteERKNS_13CRGBPalette16EhhNS_10TBlendTypeE+0x36>
            entry = &(pal[0]);
        } else {
            entry++;
 80a2034:	1ce1      	adds	r1, r4, #3
        }

        uint8_t f2 = lo4 << 4;
 80a2036:	0112      	lsls	r2, r2, #4
// If you are doing several 'scale8's in a row, use this, and
// then explicitly call cleanup_R1.
LIB8STATIC uint8_t scale8_LEAVING_R1_DIRTY( uint8_t i, fract8 scale)
{
#if SCALE8_C == 1
    return ((int)i * (int)(scale) ) >> 8;
 80a2038:	4254      	negs	r4, r2
 80a203a:	f891 c001 	ldrb.w	ip, [r1, #1]
 80a203e:	788f      	ldrb	r7, [r1, #2]
 80a2040:	b2e4      	uxtb	r4, r4
        blue2  = scale8_LEAVING_R1_DIRTY( blue2,  f2);

        cleanup_R1();

        // These sums can't overflow, so no qadd8 needed.
        red1   += red2;
 80a2042:	7809      	ldrb	r1, [r1, #0]
 80a2044:	fb02 fc0c 	mul.w	ip, r2, ip
 80a2048:	4357      	muls	r7, r2
 80a204a:	4360      	muls	r0, r4
        green1 += green2;
 80a204c:	4366      	muls	r6, r4
        blue2  = scale8_LEAVING_R1_DIRTY( blue2,  f2);

        cleanup_R1();

        // These sums can't overflow, so no qadd8 needed.
        red1   += red2;
 80a204e:	434a      	muls	r2, r1
        green1 += green2;
        blue1  += blue2;
 80a2050:	fb04 f40e 	mul.w	r4, r4, lr
 80a2054:	f3cc 2c07 	ubfx	ip, ip, #8, #8
 80a2058:	f3c7 2707 	ubfx	r7, r7, #8, #8
        blue2  = scale8_LEAVING_R1_DIRTY( blue2,  f2);

        cleanup_R1();

        // These sums can't overflow, so no qadd8 needed.
        red1   += red2;
 80a205c:	1200      	asrs	r0, r0, #8
 80a205e:	eb00 2222 	add.w	r2, r0, r2, asr #8
        green1 += green2;
 80a2062:	eb0c 2626 	add.w	r6, ip, r6, asr #8
        blue1  += blue2;
 80a2066:	eb07 2424 	add.w	r4, r7, r4, asr #8
        blue2  = scale8_LEAVING_R1_DIRTY( blue2,  f2);

        cleanup_R1();

        // These sums can't overflow, so no qadd8 needed.
        red1   += red2;
 80a206a:	f88d 2005 	strb.w	r2, [sp, #5]
        green1 += green2;
 80a206e:	f88d 6006 	strb.w	r6, [sp, #6]
        blue1  += blue2;
 80a2072:	f88d 4007 	strb.w	r4, [sp, #7]

    }

    if( brightness != 255) {
 80a2076:	2bff      	cmp	r3, #255	; 0xff
 80a2078:	d007      	beq.n	80a208a <_ZN9NSFastLED16ColorFromPaletteERKNS_13CRGBPalette16EhhNS_10TBlendTypeE+0x8a>
        nscale8x3_video( red1, green1, blue1, brightness);
 80a207a:	f10d 0207 	add.w	r2, sp, #7
 80a207e:	f10d 0106 	add.w	r1, sp, #6
 80a2082:	f10d 0005 	add.w	r0, sp, #5
 80a2086:	f7ff fe89 	bl	80a1d9c <_ZN9NSFastLEDL15nscale8x3_videoERhS0_S0_h>
    }

    return CRGB( red1, green1, blue1);
}
 80a208a:	4628      	mov	r0, r5

    if( brightness != 255) {
        nscale8x3_video( red1, green1, blue1, brightness);
    }

    return CRGB( red1, green1, blue1);
 80a208c:	f89d 2006 	ldrb.w	r2, [sp, #6]
 80a2090:	f89d 3007 	ldrb.w	r3, [sp, #7]
    {
    }

    // allow construction from R, G, B
    inline CRGB( uint8_t ir, uint8_t ig, uint8_t ib)  __attribute__((always_inline))
        : r(ir), g(ig), b(ib)
 80a2094:	f89d 1005 	ldrb.w	r1, [sp, #5]
 80a2098:	706a      	strb	r2, [r5, #1]
 80a209a:	7029      	strb	r1, [r5, #0]
 80a209c:	70ab      	strb	r3, [r5, #2]
}
 80a209e:	b003      	add	sp, #12
 80a20a0:	bdf0      	pop	{r4, r5, r6, r7, pc}

080a20a2 <_ZN9NSFastLED26nblendPaletteTowardPaletteERNS_13CRGBPalette16ES1_h>:
}
#endif


void nblendPaletteTowardPalette( CRGBPalette16& current, CRGBPalette16& target, uint8_t maxChanges)
{
 80a20a2:	b5f0      	push	{r4, r5, r6, r7, lr}
 80a20a4:	3901      	subs	r1, #1
 80a20a6:	1e44      	subs	r4, r0, #1
    uint8_t* p1;
    uint8_t* p2;
    uint8_t  changes = 0;
 80a20a8:	2300      	movs	r3, #0
 80a20aa:	302f      	adds	r0, #47	; 0x2f
    p2 = (uint8_t*)target.entries;

    const uint8_t totalChannels = sizeof(CRGBPalette16);
    for( uint8_t i = 0; i < totalChannels; i++) {
        // if the values are equal, no changes are needed
        if( p1[i] == p2[i] ) { continue; }
 80a20ac:	f814 5f01 	ldrb.w	r5, [r4, #1]!
 80a20b0:	f811 6f01 	ldrb.w	r6, [r1, #1]!
 80a20b4:	42b5      	cmp	r5, r6
 80a20b6:	d016      	beq.n	80a20e6 <_ZN9NSFastLED26nblendPaletteTowardPaletteERNS_13CRGBPalette16ES1_h+0x44>

        // if the current value is less than the target, increase it by one
        if( p1[i] < p2[i] ) { p1[i]++; changes++; }
 80a20b8:	bf3c      	itt	cc
 80a20ba:	3501      	addcc	r5, #1
 80a20bc:	7025      	strbcc	r5, [r4, #0]

        // if the current value is greater than the target,
        // increase it by one (or two if it's still greater).
        if( p1[i] > p2[i] ) {
 80a20be:	7825      	ldrb	r5, [r4, #0]
 80a20c0:	780e      	ldrb	r6, [r1, #0]
    for( uint8_t i = 0; i < totalChannels; i++) {
        // if the values are equal, no changes are needed
        if( p1[i] == p2[i] ) { continue; }

        // if the current value is less than the target, increase it by one
        if( p1[i] < p2[i] ) { p1[i]++; changes++; }
 80a20c2:	bf3c      	itt	cc
 80a20c4:	3301      	addcc	r3, #1
 80a20c6:	b2db      	uxtbcc	r3, r3

        // if the current value is greater than the target,
        // increase it by one (or two if it's still greater).
        if( p1[i] > p2[i] ) {
 80a20c8:	42ae      	cmp	r6, r5
 80a20ca:	d20a      	bcs.n	80a20e2 <_ZN9NSFastLED26nblendPaletteTowardPaletteERNS_13CRGBPalette16ES1_h+0x40>
            p1[i]--; changes++;
 80a20cc:	1e6e      	subs	r6, r5, #1
 80a20ce:	b2f6      	uxtb	r6, r6
 80a20d0:	7026      	strb	r6, [r4, #0]
            if( p1[i] > p2[i] ) { p1[i]--; }
 80a20d2:	780f      	ldrb	r7, [r1, #0]
        if( p1[i] < p2[i] ) { p1[i]++; changes++; }

        // if the current value is greater than the target,
        // increase it by one (or two if it's still greater).
        if( p1[i] > p2[i] ) {
            p1[i]--; changes++;
 80a20d4:	3301      	adds	r3, #1
            if( p1[i] > p2[i] ) { p1[i]--; }
 80a20d6:	42b7      	cmp	r7, r6
 80a20d8:	bf38      	it	cc
 80a20da:	3d02      	subcc	r5, #2
        if( p1[i] < p2[i] ) { p1[i]++; changes++; }

        // if the current value is greater than the target,
        // increase it by one (or two if it's still greater).
        if( p1[i] > p2[i] ) {
            p1[i]--; changes++;
 80a20dc:	b2db      	uxtb	r3, r3
            if( p1[i] > p2[i] ) { p1[i]--; }
 80a20de:	bf38      	it	cc
 80a20e0:	7025      	strbcc	r5, [r4, #0]
        }

        // if we've hit the maximum number of changes, exit
        if( changes >= maxChanges) { break; }
 80a20e2:	4293      	cmp	r3, r2
 80a20e4:	d201      	bcs.n	80a20ea <_ZN9NSFastLED26nblendPaletteTowardPaletteERNS_13CRGBPalette16ES1_h+0x48>

    p1 = (uint8_t*)current.entries;
    p2 = (uint8_t*)target.entries;

    const uint8_t totalChannels = sizeof(CRGBPalette16);
    for( uint8_t i = 0; i < totalChannels; i++) {
 80a20e6:	4284      	cmp	r4, r0
 80a20e8:	d1e0      	bne.n	80a20ac <_ZN9NSFastLED26nblendPaletteTowardPaletteERNS_13CRGBPalette16ES1_h+0xa>
 80a20ea:	bdf0      	pop	{r4, r5, r6, r7, pc}

080a20ec <_GLOBAL__sub_I__ZN9NSFastLED10fill_solidEPNS_4CRGBEiRKS0_>:
 80a20ec:	f000 b90c 	b.w	80a2308 <HAL_Pin_Map>

080a20f0 <_ZN9NSFastLEDL15nscale8x3_videoERhS0_S0_h>:
#endif
}


LIB8STATIC void nscale8x3_video( uint8_t& r, uint8_t& g, uint8_t& b, fract8 scale)
{
 80a20f0:	b530      	push	{r4, r5, lr}
#if SCALE8_C == 1
    uint8_t nonzeroscale = (scale != 0) ? 1 : 0;
    r = (r == 0) ? 0 : (((int)r * (int)(scale) ) >> 8) + nonzeroscale;
 80a20f2:	7804      	ldrb	r4, [r0, #0]


LIB8STATIC void nscale8x3_video( uint8_t& r, uint8_t& g, uint8_t& b, fract8 scale)
{
#if SCALE8_C == 1
    uint8_t nonzeroscale = (scale != 0) ? 1 : 0;
 80a20f4:	1c1d      	adds	r5, r3, #0
 80a20f6:	bf18      	it	ne
 80a20f8:	2501      	movne	r5, #1
    r = (r == 0) ? 0 : (((int)r * (int)(scale) ) >> 8) + nonzeroscale;
 80a20fa:	b11c      	cbz	r4, 80a2104 <_ZN9NSFastLEDL15nscale8x3_videoERhS0_S0_h+0x14>
 80a20fc:	435c      	muls	r4, r3
 80a20fe:	eb05 2424 	add.w	r4, r5, r4, asr #8
 80a2102:	b2e4      	uxtb	r4, r4
 80a2104:	7004      	strb	r4, [r0, #0]
    g = (g == 0) ? 0 : (((int)g * (int)(scale) ) >> 8) + nonzeroscale;
 80a2106:	7808      	ldrb	r0, [r1, #0]
 80a2108:	b118      	cbz	r0, 80a2112 <_ZN9NSFastLEDL15nscale8x3_videoERhS0_S0_h+0x22>
 80a210a:	4358      	muls	r0, r3
 80a210c:	eb05 2020 	add.w	r0, r5, r0, asr #8
 80a2110:	b2c0      	uxtb	r0, r0
 80a2112:	7008      	strb	r0, [r1, #0]
    b = (b == 0) ? 0 : (((int)b * (int)(scale) ) >> 8) + nonzeroscale;
 80a2114:	7811      	ldrb	r1, [r2, #0]
 80a2116:	b119      	cbz	r1, 80a2120 <_ZN9NSFastLEDL15nscale8x3_videoERhS0_S0_h+0x30>
 80a2118:	434b      	muls	r3, r1
 80a211a:	eb05 2323 	add.w	r3, r5, r3, asr #8
 80a211e:	b2d9      	uxtb	r1, r3
 80a2120:	7011      	strb	r1, [r2, #0]
 80a2122:	bd30      	pop	{r4, r5, pc}

080a2124 <_ZN9NSFastLED15hsv2rgb_rainbowERKNS_4CHSVERNS_4CRGBE>:
#define K255 255
#define K171 171
#define K85  85

void hsv2rgb_rainbow( const CHSV& hsv, CRGB& rgb)
{
 80a2124:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 80a2126:	460d      	mov	r5, r1
    // Gscale: what to scale green down by.
    // Depends GREATLY on your particular LEDs
    const uint8_t Gscale = 0;


    uint8_t hue = hsv.hue;
 80a2128:	7803      	ldrb	r3, [r0, #0]
    uint8_t sat = hsv.sat;
 80a212a:	7846      	ldrb	r6, [r0, #1]
    uint8_t val = hsv.val;
 80a212c:	7884      	ldrb	r4, [r0, #2]
//         In other words, it computes i * (scale / 256)
//         4 clocks AVR with MUL, 2 clocks ARM
LIB8STATIC uint8_t scale8( uint8_t i, fract8 scale)
{
#if SCALE8_C == 1
    return ((uint16_t)i * (uint16_t)(scale) ) >> 8;
 80a212e:	00d8      	lsls	r0, r3, #3
 80a2130:	b2c0      	uxtb	r0, r0
 80a2132:	2255      	movs	r2, #85	; 0x55
 80a2134:	4342      	muls	r2, r0
 80a2136:	f003 0140 	and.w	r1, r3, #64	; 0x40

    uint8_t third = scale8( offset8, (256 / 3));

    uint8_t r, g, b;

    if( ! (hue & 0x80) ) {
 80a213a:	f013 0f80 	tst.w	r3, #128	; 0x80
 80a213e:	f3c2 2207 	ubfx	r2, r2, #8, #8
 80a2142:	f003 0320 	and.w	r3, r3, #32
        // 0XX
        if( ! (hue & 0x40) ) {
 80a2146:	f001 07ff 	and.w	r7, r1, #255	; 0xff

    uint8_t third = scale8( offset8, (256 / 3));

    uint8_t r, g, b;

    if( ! (hue & 0x80) ) {
 80a214a:	d128      	bne.n	80a219e <_ZN9NSFastLED15hsv2rgb_rainbowERKNS_4CHSVERNS_4CRGBE+0x7a>
        // 0XX
        if( ! (hue & 0x40) ) {
 80a214c:	b979      	cbnz	r1, 80a216e <_ZN9NSFastLED15hsv2rgb_rainbowERKNS_4CHSVERNS_4CRGBE+0x4a>
            // 00X
            //section 0-1
            if( ! (hue & 0x20) ) {
 80a214e:	f003 01ff 	and.w	r1, r3, #255	; 0xff
 80a2152:	b93b      	cbnz	r3, 80a2164 <_ZN9NSFastLED15hsv2rgb_rainbowERKNS_4CHSVERNS_4CRGBE+0x40>
                // 000
                //case 0: // R -> O
                r = K255 - third;
 80a2154:	43d3      	mvns	r3, r2
                g = third;
 80a2156:	f88d 2006 	strb.w	r2, [sp, #6]
            // 00X
            //section 0-1
            if( ! (hue & 0x20) ) {
                // 000
                //case 0: // R -> O
                r = K255 - third;
 80a215a:	f88d 3005 	strb.w	r3, [sp, #5]
                g = third;
                b = 0;
 80a215e:	f88d 1007 	strb.w	r1, [sp, #7]
                FORCE_REFERENCE(b);
 80a2162:	e04c      	b.n	80a21fe <_ZN9NSFastLED15hsv2rgb_rainbowERKNS_4CHSVERNS_4CRGBE+0xda>
            } else {
                // 001
                //case 1: // O -> Y
                if( Y1 ) {
                    r = K171;
 80a2164:	23ab      	movs	r3, #171	; 0xab
 80a2166:	f88d 3005 	strb.w	r3, [sp, #5]
                    g = K85 + third ;
 80a216a:	3255      	adds	r2, #85	; 0x55
 80a216c:	e00b      	b.n	80a2186 <_ZN9NSFastLED15hsv2rgb_rainbowERKNS_4CHSVERNS_4CRGBE+0x62>
                }
            }
        } else {
            //01X
            // section 2-3
            if( !  (hue & 0x20) ) {
 80a216e:	f003 07ff 	and.w	r7, r3, #255	; 0xff
 80a2172:	b96b      	cbnz	r3, 80a2190 <_ZN9NSFastLED15hsv2rgb_rainbowERKNS_4CHSVERNS_4CRGBE+0x6c>
                // 010
                //case 2: // Y -> G
                if( Y1 ) {
                    //uint8_t twothirds = (third << 1);
                    uint8_t twothirds = scale8( offset8, ((256 * 2) / 3));
                    r = K171 - twothirds;
 80a2174:	21aa      	movs	r1, #170	; 0xaa
 80a2176:	fb01 f300 	mul.w	r3, r1, r0
 80a217a:	121b      	asrs	r3, r3, #8
 80a217c:	f1c3 03ab 	rsb	r3, r3, #171	; 0xab
 80a2180:	f88d 3005 	strb.w	r3, [sp, #5]
                    g = K171 + third;
 80a2184:	3a55      	subs	r2, #85	; 0x55
 80a2186:	f88d 2006 	strb.w	r2, [sp, #6]
                    b = 0;
 80a218a:	f88d 7007 	strb.w	r7, [sp, #7]
                    FORCE_REFERENCE(b);
 80a218e:	e036      	b.n	80a21fe <_ZN9NSFastLED15hsv2rgb_rainbowERKNS_4CHSVERNS_4CRGBE+0xda>
                    FORCE_REFERENCE(b);
                }
            } else {
                // 011
                // case 3: // G -> A
                r = 0;
 80a2190:	2300      	movs	r3, #0
 80a2192:	f88d 3005 	strb.w	r3, [sp, #5]
                FORCE_REFERENCE(r);
                g = K255 - third;
 80a2196:	43d3      	mvns	r3, r2
 80a2198:	f88d 3006 	strb.w	r3, [sp, #6]
 80a219c:	e02d      	b.n	80a21fa <_ZN9NSFastLED15hsv2rgb_rainbowERKNS_4CHSVERNS_4CRGBE+0xd6>
            }
        }
    } else {
        // section 4-7
        // 1XX
        if( ! (hue & 0x40) ) {
 80a219e:	b9b9      	cbnz	r1, 80a21d0 <_ZN9NSFastLED15hsv2rgb_rainbowERKNS_4CHSVERNS_4CRGBE+0xac>
            // 10X
            if( ! ( hue & 0x20) ) {
 80a21a0:	f003 01ff 	and.w	r1, r3, #255	; 0xff
 80a21a4:	b973      	cbnz	r3, 80a21c4 <_ZN9NSFastLED15hsv2rgb_rainbowERKNS_4CHSVERNS_4CRGBE+0xa0>
                // 100
                //case 4: // A -> B
                r = 0;
 80a21a6:	f88d 1005 	strb.w	r1, [sp, #5]
 80a21aa:	22aa      	movs	r2, #170	; 0xaa
 80a21ac:	fb02 f300 	mul.w	r3, r2, r0
 80a21b0:	f3c3 2307 	ubfx	r3, r3, #8, #8
                FORCE_REFERENCE(r);
                //uint8_t twothirds = (third << 1);
                uint8_t twothirds = scale8( offset8, ((256 * 2) / 3));
                g = K171 - twothirds;
 80a21b4:	f1c3 02ab 	rsb	r2, r3, #171	; 0xab
                b = K85  + twothirds;
 80a21b8:	3355      	adds	r3, #85	; 0x55
                //case 4: // A -> B
                r = 0;
                FORCE_REFERENCE(r);
                //uint8_t twothirds = (third << 1);
                uint8_t twothirds = scale8( offset8, ((256 * 2) / 3));
                g = K171 - twothirds;
 80a21ba:	f88d 2006 	strb.w	r2, [sp, #6]
                b = K85  + twothirds;
 80a21be:	f88d 3007 	strb.w	r3, [sp, #7]
 80a21c2:	e01c      	b.n	80a21fe <_ZN9NSFastLED15hsv2rgb_rainbowERKNS_4CHSVERNS_4CRGBE+0xda>

            } else {
                // 101
                //case 5: // B -> P
                r = third;
 80a21c4:	f88d 2005 	strb.w	r2, [sp, #5]
                g = 0;
 80a21c8:	f88d 7006 	strb.w	r7, [sp, #6]
                FORCE_REFERENCE(g);
                b = K255 - third;
 80a21cc:	43d2      	mvns	r2, r2
 80a21ce:	e014      	b.n	80a21fa <_ZN9NSFastLED15hsv2rgb_rainbowERKNS_4CHSVERNS_4CRGBE+0xd6>

            }
        } else {
            if( !  (hue & 0x20)  ) {
 80a21d0:	f003 01ff 	and.w	r1, r3, #255	; 0xff
 80a21d4:	b943      	cbnz	r3, 80a21e8 <_ZN9NSFastLED15hsv2rgb_rainbowERKNS_4CHSVERNS_4CRGBE+0xc4>
                // 110
                //case 6: // P -- K
                r = K85 + third;
 80a21d6:	f102 0355 	add.w	r3, r2, #85	; 0x55
 80a21da:	f88d 3005 	strb.w	r3, [sp, #5]
                g = 0;
 80a21de:	f88d 1006 	strb.w	r1, [sp, #6]
                FORCE_REFERENCE(g);
                b = K171 - third;
 80a21e2:	f1c2 02ab 	rsb	r2, r2, #171	; 0xab
 80a21e6:	e008      	b.n	80a21fa <_ZN9NSFastLED15hsv2rgb_rainbowERKNS_4CHSVERNS_4CRGBE+0xd6>

            } else {
                // 111
                //case 7: // K -> R
                r = K171 + third;
 80a21e8:	f1a2 0355 	sub.w	r3, r2, #85	; 0x55
 80a21ec:	f88d 3005 	strb.w	r3, [sp, #5]
                g = 0;
 80a21f0:	2300      	movs	r3, #0
 80a21f2:	f88d 3006 	strb.w	r3, [sp, #6]
                FORCE_REFERENCE(g);
                b = K85 - third;
 80a21f6:	f1c2 0255 	rsb	r2, r2, #85	; 0x55
 80a21fa:	f88d 2007 	strb.w	r2, [sp, #7]
    if( G2 ) g = g >> 1;
    if( Gscale ) g = scale8_video_LEAVING_R1_DIRTY( g, Gscale);

    // Scale down colors if we're desaturated at all
    // and add the brightness_floor to r, g, and b.
    if( sat != 255 ) {
 80a21fe:	2eff      	cmp	r6, #255	; 0xff
 80a2200:	d01c      	beq.n	80a223c <_ZN9NSFastLED15hsv2rgb_rainbowERKNS_4CHSVERNS_4CRGBE+0x118>

        nscale8x3_video( r, g, b, sat);
 80a2202:	4633      	mov	r3, r6
 80a2204:	f10d 0207 	add.w	r2, sp, #7
 80a2208:	f10d 0106 	add.w	r1, sp, #6
 80a220c:	f10d 0005 	add.w	r0, sp, #5
 80a2210:	f7ff ff6e 	bl	80a20f0 <_ZN9NSFastLEDL15nscale8x3_videoERhS0_S0_h>
 80a2214:	43f2      	mvns	r2, r6
 80a2216:	b2d2      	uxtb	r2, r2
 80a2218:	4352      	muls	r2, r2

        uint8_t desat = 255 - sat;
        desat = scale8( desat, desat);

        uint8_t brightness_floor = desat;
        r += brightness_floor;
 80a221a:	f89d 3005 	ldrb.w	r3, [sp, #5]
 80a221e:	f3c2 2207 	ubfx	r2, r2, #8, #8
 80a2222:	4413      	add	r3, r2
 80a2224:	f88d 3005 	strb.w	r3, [sp, #5]
        g += brightness_floor;
 80a2228:	f89d 3006 	ldrb.w	r3, [sp, #6]
 80a222c:	4413      	add	r3, r2
 80a222e:	f88d 3006 	strb.w	r3, [sp, #6]
        b += brightness_floor;
 80a2232:	f89d 3007 	ldrb.w	r3, [sp, #7]
 80a2236:	441a      	add	r2, r3
 80a2238:	f88d 2007 	strb.w	r2, [sp, #7]
    }

    // Now scale everything down if we're at value < 255.
    if( val != 255 ) {
 80a223c:	2cff      	cmp	r4, #255	; 0xff
 80a223e:	d00e      	beq.n	80a225e <_ZN9NSFastLED15hsv2rgb_rainbowERKNS_4CHSVERNS_4CRGBE+0x13a>

        val = scale8_video_LEAVING_R1_DIRTY( val, val);
        nscale8x3_video( r, g, b, val);
 80a2240:	fb04 f304 	mul.w	r3, r4, r4
 80a2244:	121b      	asrs	r3, r3, #8
 80a2246:	2c00      	cmp	r4, #0
 80a2248:	bf18      	it	ne
 80a224a:	3301      	addne	r3, #1
 80a224c:	f10d 0207 	add.w	r2, sp, #7
 80a2250:	b2db      	uxtb	r3, r3
 80a2252:	f10d 0106 	add.w	r1, sp, #6
 80a2256:	f10d 0005 	add.w	r0, sp, #5
 80a225a:	f7ff ff49 	bl	80a20f0 <_ZN9NSFastLEDL15nscale8x3_videoERhS0_S0_h>
    // It turns out that fixing it winds up costing more than
    // not fixing it.
    // To paraphrase Dr Bronner, profile! profile! profile!
    //asm volatile(  ""  :  :  : "r26", "r27" );
    //asm volatile (" movw r30, r26 \n" : : : "r30", "r31");
    rgb.r = r;
 80a225e:	f89d 3005 	ldrb.w	r3, [sp, #5]
 80a2262:	702b      	strb	r3, [r5, #0]
    rgb.g = g;
 80a2264:	f89d 3006 	ldrb.w	r3, [sp, #6]
 80a2268:	706b      	strb	r3, [r5, #1]
    rgb.b = b;
 80a226a:	f89d 3007 	ldrb.w	r3, [sp, #7]
 80a226e:	70ab      	strb	r3, [r5, #2]
}
 80a2270:	b003      	add	sp, #12
 80a2272:	bdf0      	pop	{r4, r5, r6, r7, pc}

080a2274 <_GLOBAL__sub_I__ZN9NSFastLED11hsv2rgb_rawERKNS_4CHSVERNS_4CRGBE>:
 80a2274:	f000 b848 	b.w	80a2308 <HAL_Pin_Map>

080a2278 <_GLOBAL__sub_I__ZN9NSFastLED10rand16seedE>:
 80a2278:	f000 b846 	b.w	80a2308 <HAL_Pin_Map>

080a227c <_GLOBAL__sub_I__ZN9NSFastLED12inoise16_rawEmmm>:
 80a227c:	f000 b844 	b.w	80a2308 <HAL_Pin_Map>

080a2280 <_GLOBAL__sub_I__ZN9NSFastLED27calculate_unscaled_power_mWEPKNS_4CRGBEt>:
 80a2280:	f000 b842 	b.w	80a2308 <HAL_Pin_Map>

080a2284 <_GLOBAL__sub_I_wiring.cpp>:
 80a2284:	f000 b840 	b.w	80a2308 <HAL_Pin_Map>

080a2288 <os_mutex_create>:
DYNALIB_FN(8, hal_concurrent, os_timer_create, int(os_timer_t*, unsigned, void(*)(os_timer_t), void*, bool, void*))
DYNALIB_FN(9, hal_concurrent, os_timer_destroy, int(os_timer_t, void*))
DYNALIB_FN(10, hal_concurrent, os_timer_get_id, int(os_timer_t, void**))
DYNALIB_FN(11, hal_concurrent, os_timer_change, int(os_timer_t, os_timer_change_t, bool, unsigned, unsigned, void*))

DYNALIB_FN(12, hal_concurrent, os_mutex_create, int(os_mutex_t*))
 80a2288:	b508      	push	{r3, lr}
 80a228a:	4b02      	ldr	r3, [pc, #8]	; (80a2294 <os_mutex_create+0xc>)
 80a228c:	681b      	ldr	r3, [r3, #0]
 80a228e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80a2290:	9301      	str	r3, [sp, #4]
 80a2292:	bd08      	pop	{r3, pc}
 80a2294:	080601d0 	.word	0x080601d0

080a2298 <HAL_Core_Get_Last_Reset_Info>:
DYNALIB_FN(22, hal_core, HAL_Set_System_Config, int(hal_system_config_t, const void*, unsigned))
DYNALIB_FN(23, hal_core, HAL_Core_Enter_Safe_Mode, void(void*))
DYNALIB_FN(24, hal_core, HAL_Feature_Get, bool(HAL_Feature))
DYNALIB_FN(25, hal_core, HAL_Feature_Set, int(HAL_Feature, bool))
DYNALIB_FN(26, hal_core, HAL_Core_System_Reset_Ex, void(int, uint32_t, void*))
DYNALIB_FN(27, hal_core, HAL_Core_Get_Last_Reset_Info, int(int*, uint32_t*, void*))
 80a2298:	b508      	push	{r3, lr}
 80a229a:	4b02      	ldr	r3, [pc, #8]	; (80a22a4 <HAL_Core_Get_Last_Reset_Info+0xc>)
 80a229c:	681b      	ldr	r3, [r3, #0]
 80a229e:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 80a22a0:	9301      	str	r3, [sp, #4]
 80a22a2:	bd08      	pop	{r3, pc}
 80a22a4:	080601b8 	.word	0x080601b8

080a22a8 <HAL_RNG_GetRandomNumber>:

DYNALIB_BEGIN(hal)

#if PLATFORM_ID > 3
DYNALIB_FN(0, hal, HAL_RNG_Configuration, void(void))
DYNALIB_FN(1, hal, HAL_RNG_GetRandomNumber, uint32_t(void))
 80a22a8:	b508      	push	{r3, lr}
 80a22aa:	4b02      	ldr	r3, [pc, #8]	; (80a22b4 <HAL_RNG_GetRandomNumber+0xc>)
 80a22ac:	681b      	ldr	r3, [r3, #0]
 80a22ae:	685b      	ldr	r3, [r3, #4]
 80a22b0:	9301      	str	r3, [sp, #4]
 80a22b2:	bd08      	pop	{r3, pc}
 80a22b4:	0806019c 	.word	0x0806019c

080a22b8 <HAL_Timer_Get_Micro_Seconds>:
#define BASE_IDX 0
#endif

DYNALIB_FN(BASE_IDX + 0, hal, HAL_Delay_Milliseconds, void(uint32_t))
DYNALIB_FN(BASE_IDX + 1, hal, HAL_Delay_Microseconds, void(uint32_t))
DYNALIB_FN(BASE_IDX + 2, hal, HAL_Timer_Get_Micro_Seconds, system_tick_t(void))
 80a22b8:	b508      	push	{r3, lr}
 80a22ba:	4b02      	ldr	r3, [pc, #8]	; (80a22c4 <HAL_Timer_Get_Micro_Seconds+0xc>)
 80a22bc:	681b      	ldr	r3, [r3, #0]
 80a22be:	691b      	ldr	r3, [r3, #16]
 80a22c0:	9301      	str	r3, [sp, #4]
 80a22c2:	bd08      	pop	{r3, pc}
 80a22c4:	0806019c 	.word	0x0806019c

080a22c8 <HAL_Timer_Get_Milli_Seconds>:
DYNALIB_FN(BASE_IDX + 3, hal, HAL_Timer_Get_Milli_Seconds, system_tick_t(void))
 80a22c8:	b508      	push	{r3, lr}
 80a22ca:	4b02      	ldr	r3, [pc, #8]	; (80a22d4 <HAL_Timer_Get_Milli_Seconds+0xc>)
 80a22cc:	681b      	ldr	r3, [r3, #0]
 80a22ce:	695b      	ldr	r3, [r3, #20]
 80a22d0:	9301      	str	r3, [sp, #4]
 80a22d2:	bd08      	pop	{r3, pc}
 80a22d4:	0806019c 	.word	0x0806019c

080a22d8 <HAL_EEPROM_Init>:
DYNALIB_FN(BASE_IDX + 4, hal, HAL_RTC_Configuration, void(void))
DYNALIB_FN(BASE_IDX + 5, hal, HAL_RTC_Get_UnixTime, time_t(void))
DYNALIB_FN(BASE_IDX + 6, hal, HAL_RTC_Set_UnixTime, void(time_t))
DYNALIB_FN(BASE_IDX + 7, hal, HAL_RTC_Set_UnixAlarm, void(time_t))

DYNALIB_FN(BASE_IDX + 8, hal, HAL_EEPROM_Init, void(void))
 80a22d8:	b508      	push	{r3, lr}
 80a22da:	4b02      	ldr	r3, [pc, #8]	; (80a22e4 <HAL_EEPROM_Init+0xc>)
 80a22dc:	681b      	ldr	r3, [r3, #0]
 80a22de:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80a22e0:	9301      	str	r3, [sp, #4]
 80a22e2:	bd08      	pop	{r3, pc}
 80a22e4:	0806019c 	.word	0x0806019c

080a22e8 <HAL_EEPROM_Read>:
DYNALIB_FN(BASE_IDX + 9, hal, HAL_EEPROM_Read, uint8_t(uint32_t))
 80a22e8:	b508      	push	{r3, lr}
 80a22ea:	4b02      	ldr	r3, [pc, #8]	; (80a22f4 <HAL_EEPROM_Read+0xc>)
 80a22ec:	681b      	ldr	r3, [r3, #0]
 80a22ee:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80a22f0:	9301      	str	r3, [sp, #4]
 80a22f2:	bd08      	pop	{r3, pc}
 80a22f4:	0806019c 	.word	0x0806019c

080a22f8 <HAL_EEPROM_Write>:
DYNALIB_FN(BASE_IDX + 10, hal, HAL_EEPROM_Write, void(uint32_t, uint8_t))
 80a22f8:	b508      	push	{r3, lr}
 80a22fa:	4b02      	ldr	r3, [pc, #8]	; (80a2304 <HAL_EEPROM_Write+0xc>)
 80a22fc:	681b      	ldr	r3, [r3, #0]
 80a22fe:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80a2300:	9301      	str	r3, [sp, #4]
 80a2302:	bd08      	pop	{r3, pc}
 80a2304:	0806019c 	.word	0x0806019c

080a2308 <HAL_Pin_Map>:
// New HAL functions must be added to the end of this list.
// GNINRAW

DYNALIB_BEGIN(hal_gpio)

DYNALIB_FN(0, hal_gpio, HAL_Pin_Map, STM32_Pin_Info*(void))
 80a2308:	b508      	push	{r3, lr}
 80a230a:	4b02      	ldr	r3, [pc, #8]	; (80a2314 <HAL_Pin_Map+0xc>)
 80a230c:	681b      	ldr	r3, [r3, #0]
 80a230e:	681b      	ldr	r3, [r3, #0]
 80a2310:	9301      	str	r3, [sp, #4]
 80a2312:	bd08      	pop	{r3, pc}
 80a2314:	080601b0 	.word	0x080601b0

080a2318 <HAL_Pin_Mode>:
DYNALIB_FN(1, hal_gpio, HAL_Validate_Pin_Function, PinFunction(pin_t, PinFunction))
DYNALIB_FN(2, hal_gpio, HAL_Pin_Mode, void(pin_t, PinMode))
 80a2318:	b508      	push	{r3, lr}
 80a231a:	4b02      	ldr	r3, [pc, #8]	; (80a2324 <HAL_Pin_Mode+0xc>)
 80a231c:	681b      	ldr	r3, [r3, #0]
 80a231e:	689b      	ldr	r3, [r3, #8]
 80a2320:	9301      	str	r3, [sp, #4]
 80a2322:	bd08      	pop	{r3, pc}
 80a2324:	080601b0 	.word	0x080601b0

080a2328 <HAL_Get_Pin_Mode>:
DYNALIB_FN(3, hal_gpio, HAL_Get_Pin_Mode, PinMode(pin_t))
 80a2328:	b508      	push	{r3, lr}
 80a232a:	4b02      	ldr	r3, [pc, #8]	; (80a2334 <HAL_Get_Pin_Mode+0xc>)
 80a232c:	681b      	ldr	r3, [r3, #0]
 80a232e:	68db      	ldr	r3, [r3, #12]
 80a2330:	9301      	str	r3, [sp, #4]
 80a2332:	bd08      	pop	{r3, pc}
 80a2334:	080601b0 	.word	0x080601b0

080a2338 <HAL_GPIO_Read>:
DYNALIB_FN(4, hal_gpio, HAL_GPIO_Write, void(pin_t, uint8_t))
DYNALIB_FN(5, hal_gpio, HAL_GPIO_Read, int32_t(pin_t))
 80a2338:	b508      	push	{r3, lr}
 80a233a:	4b02      	ldr	r3, [pc, #8]	; (80a2344 <HAL_GPIO_Read+0xc>)
 80a233c:	681b      	ldr	r3, [r3, #0]
 80a233e:	695b      	ldr	r3, [r3, #20]
 80a2340:	9301      	str	r3, [sp, #4]
 80a2342:	bd08      	pop	{r3, pc}
 80a2344:	080601b0 	.word	0x080601b0

080a2348 <HAL_I2C_Write_Data>:
DYNALIB_FN(BASE_IDX + 3, hal_i2c, HAL_I2C_Begin, void(HAL_I2C_Interface, I2C_Mode, uint8_t, void*))
DYNALIB_FN(BASE_IDX + 4, hal_i2c, HAL_I2C_End, void(HAL_I2C_Interface, void*))
DYNALIB_FN(BASE_IDX + 5, hal_i2c, HAL_I2C_Request_Data, uint32_t(HAL_I2C_Interface, uint8_t, uint8_t, uint8_t, void*))
DYNALIB_FN(BASE_IDX + 6, hal_i2c, HAL_I2C_Begin_Transmission, void(HAL_I2C_Interface, uint8_t, void*))
DYNALIB_FN(BASE_IDX + 7, hal_i2c, HAL_I2C_End_Transmission, uint8_t(HAL_I2C_Interface, uint8_t, void*))
DYNALIB_FN(BASE_IDX + 8, hal_i2c, HAL_I2C_Write_Data, uint32_t(HAL_I2C_Interface, uint8_t, void*))
 80a2348:	b508      	push	{r3, lr}
 80a234a:	4b02      	ldr	r3, [pc, #8]	; (80a2354 <HAL_I2C_Write_Data+0xc>)
 80a234c:	681b      	ldr	r3, [r3, #0]
 80a234e:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 80a2350:	9301      	str	r3, [sp, #4]
 80a2352:	bd08      	pop	{r3, pc}
 80a2354:	080601ac 	.word	0x080601ac

080a2358 <HAL_I2C_Available_Data>:
DYNALIB_FN(BASE_IDX + 9, hal_i2c, HAL_I2C_Available_Data, int32_t(HAL_I2C_Interface, void*))
 80a2358:	b508      	push	{r3, lr}
 80a235a:	4b02      	ldr	r3, [pc, #8]	; (80a2364 <HAL_I2C_Available_Data+0xc>)
 80a235c:	681b      	ldr	r3, [r3, #0]
 80a235e:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 80a2360:	9301      	str	r3, [sp, #4]
 80a2362:	bd08      	pop	{r3, pc}
 80a2364:	080601ac 	.word	0x080601ac

080a2368 <HAL_I2C_Read_Data>:
DYNALIB_FN(BASE_IDX + 10, hal_i2c, HAL_I2C_Read_Data, int32_t(HAL_I2C_Interface, void*))
 80a2368:	b508      	push	{r3, lr}
 80a236a:	4b02      	ldr	r3, [pc, #8]	; (80a2374 <HAL_I2C_Read_Data+0xc>)
 80a236c:	681b      	ldr	r3, [r3, #0]
 80a236e:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 80a2370:	9301      	str	r3, [sp, #4]
 80a2372:	bd08      	pop	{r3, pc}
 80a2374:	080601ac 	.word	0x080601ac

080a2378 <HAL_I2C_Peek_Data>:
DYNALIB_FN(BASE_IDX + 11, hal_i2c, HAL_I2C_Peek_Data, int32_t(HAL_I2C_Interface, void*))
 80a2378:	b508      	push	{r3, lr}
 80a237a:	4b02      	ldr	r3, [pc, #8]	; (80a2384 <HAL_I2C_Peek_Data+0xc>)
 80a237c:	681b      	ldr	r3, [r3, #0]
 80a237e:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 80a2380:	9301      	str	r3, [sp, #4]
 80a2382:	bd08      	pop	{r3, pc}
 80a2384:	080601ac 	.word	0x080601ac

080a2388 <HAL_I2C_Flush_Data>:
DYNALIB_FN(BASE_IDX + 12, hal_i2c, HAL_I2C_Flush_Data, void(HAL_I2C_Interface, void*))
 80a2388:	b508      	push	{r3, lr}
 80a238a:	4b02      	ldr	r3, [pc, #8]	; (80a2394 <HAL_I2C_Flush_Data+0xc>)
 80a238c:	681b      	ldr	r3, [r3, #0]
 80a238e:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 80a2390:	9301      	str	r3, [sp, #4]
 80a2392:	bd08      	pop	{r3, pc}
 80a2394:	080601ac 	.word	0x080601ac

080a2398 <HAL_I2C_Is_Enabled>:
DYNALIB_FN(BASE_IDX + 13, hal_i2c, HAL_I2C_Is_Enabled, bool(HAL_I2C_Interface, void*))
 80a2398:	b508      	push	{r3, lr}
 80a239a:	4b02      	ldr	r3, [pc, #8]	; (80a23a4 <HAL_I2C_Is_Enabled+0xc>)
 80a239c:	681b      	ldr	r3, [r3, #0]
 80a239e:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 80a23a0:	9301      	str	r3, [sp, #4]
 80a23a2:	bd08      	pop	{r3, pc}
 80a23a4:	080601ac 	.word	0x080601ac

080a23a8 <HAL_I2C_Init>:
DYNALIB_FN(BASE_IDX + 14, hal_i2c, HAL_I2C_Set_Callback_On_Receive, void(HAL_I2C_Interface, void(*)(int), void*))
DYNALIB_FN(BASE_IDX + 15, hal_i2c, HAL_I2C_Set_Callback_On_Request, void(HAL_I2C_Interface, void(*)(void), void*))
DYNALIB_FN(BASE_IDX + 16, hal_i2c, HAL_I2C_Init, void(HAL_I2C_Interface, void*))
 80a23a8:	b508      	push	{r3, lr}
 80a23aa:	4b03      	ldr	r3, [pc, #12]	; (80a23b8 <HAL_I2C_Init+0x10>)
 80a23ac:	681b      	ldr	r3, [r3, #0]
 80a23ae:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 80a23b2:	9301      	str	r3, [sp, #4]
 80a23b4:	bd08      	pop	{r3, pc}
 80a23b6:	0000      	.short	0x0000
 80a23b8:	080601ac 	.word	0x080601ac

080a23bc <HAL_SPI_Init>:
DYNALIB_FN(2, hal_spi, HAL_SPI_Set_Bit_Order, void(HAL_SPI_Interface, uint8_t))
DYNALIB_FN(3, hal_spi, HAL_SPI_Set_Data_Mode, void(HAL_SPI_Interface, uint8_t))
DYNALIB_FN(4, hal_spi, HAL_SPI_Set_Clock_Divider, void(HAL_SPI_Interface, uint8_t))
DYNALIB_FN(5, hal_spi, HAL_SPI_Send_Receive_Data, uint16_t(HAL_SPI_Interface, uint16_t))
DYNALIB_FN(6, hal_spi, HAL_SPI_Is_Enabled_Old, bool(void))
DYNALIB_FN(7, hal_spi, HAL_SPI_Init, void(HAL_SPI_Interface))
 80a23bc:	b508      	push	{r3, lr}
 80a23be:	4b02      	ldr	r3, [pc, #8]	; (80a23c8 <HAL_SPI_Init+0xc>)
 80a23c0:	681b      	ldr	r3, [r3, #0]
 80a23c2:	69db      	ldr	r3, [r3, #28]
 80a23c4:	9301      	str	r3, [sp, #4]
 80a23c6:	bd08      	pop	{r3, pc}
 80a23c8:	080601b4 	.word	0x080601b4

080a23cc <HAL_SPI_Is_Enabled>:
DYNALIB_FN(8, hal_spi, HAL_SPI_Is_Enabled, bool(HAL_SPI_Interface))
 80a23cc:	b508      	push	{r3, lr}
 80a23ce:	4b02      	ldr	r3, [pc, #8]	; (80a23d8 <HAL_SPI_Is_Enabled+0xc>)
 80a23d0:	681b      	ldr	r3, [r3, #0]
 80a23d2:	6a1b      	ldr	r3, [r3, #32]
 80a23d4:	9301      	str	r3, [sp, #4]
 80a23d6:	bd08      	pop	{r3, pc}
 80a23d8:	080601b4 	.word	0x080601b4

080a23dc <HAL_USART_Init>:
#define BASE_IDX 6 // Base index for all subsequent functions
#else
#define BASE_IDX 0
#endif

DYNALIB_FN(BASE_IDX + 0, hal_usart, HAL_USART_Init, void(HAL_USART_Serial, Ring_Buffer*, Ring_Buffer*))
 80a23dc:	b508      	push	{r3, lr}
 80a23de:	4b02      	ldr	r3, [pc, #8]	; (80a23e8 <HAL_USART_Init+0xc>)
 80a23e0:	681b      	ldr	r3, [r3, #0]
 80a23e2:	699b      	ldr	r3, [r3, #24]
 80a23e4:	9301      	str	r3, [sp, #4]
 80a23e6:	bd08      	pop	{r3, pc}
 80a23e8:	080601c4 	.word	0x080601c4

080a23ec <HAL_USART_Write_Data>:
DYNALIB_FN(BASE_IDX + 1, hal_usart, HAL_USART_Begin, void(HAL_USART_Serial, uint32_t))
DYNALIB_FN(BASE_IDX + 2, hal_usart, HAL_USART_End, void(HAL_USART_Serial))
DYNALIB_FN(BASE_IDX + 3, hal_usart, HAL_USART_Write_Data, uint32_t(HAL_USART_Serial, uint8_t))
 80a23ec:	b508      	push	{r3, lr}
 80a23ee:	4b02      	ldr	r3, [pc, #8]	; (80a23f8 <HAL_USART_Write_Data+0xc>)
 80a23f0:	681b      	ldr	r3, [r3, #0]
 80a23f2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80a23f4:	9301      	str	r3, [sp, #4]
 80a23f6:	bd08      	pop	{r3, pc}
 80a23f8:	080601c4 	.word	0x080601c4

080a23fc <HAL_USART_Available_Data>:
DYNALIB_FN(BASE_IDX + 4, hal_usart, HAL_USART_Available_Data, int32_t(HAL_USART_Serial))
 80a23fc:	b508      	push	{r3, lr}
 80a23fe:	4b02      	ldr	r3, [pc, #8]	; (80a2408 <HAL_USART_Available_Data+0xc>)
 80a2400:	681b      	ldr	r3, [r3, #0]
 80a2402:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80a2404:	9301      	str	r3, [sp, #4]
 80a2406:	bd08      	pop	{r3, pc}
 80a2408:	080601c4 	.word	0x080601c4

080a240c <HAL_USART_Read_Data>:
DYNALIB_FN(BASE_IDX + 5, hal_usart, HAL_USART_Read_Data, int32_t(HAL_USART_Serial))
 80a240c:	b508      	push	{r3, lr}
 80a240e:	4b02      	ldr	r3, [pc, #8]	; (80a2418 <HAL_USART_Read_Data+0xc>)
 80a2410:	681b      	ldr	r3, [r3, #0]
 80a2412:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80a2414:	9301      	str	r3, [sp, #4]
 80a2416:	bd08      	pop	{r3, pc}
 80a2418:	080601c4 	.word	0x080601c4

080a241c <HAL_USART_Peek_Data>:
DYNALIB_FN(BASE_IDX + 6, hal_usart, HAL_USART_Peek_Data, int32_t(HAL_USART_Serial))
 80a241c:	b508      	push	{r3, lr}
 80a241e:	4b02      	ldr	r3, [pc, #8]	; (80a2428 <HAL_USART_Peek_Data+0xc>)
 80a2420:	681b      	ldr	r3, [r3, #0]
 80a2422:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80a2424:	9301      	str	r3, [sp, #4]
 80a2426:	bd08      	pop	{r3, pc}
 80a2428:	080601c4 	.word	0x080601c4

080a242c <HAL_USART_Flush_Data>:
DYNALIB_FN(BASE_IDX + 7, hal_usart, HAL_USART_Flush_Data, void(HAL_USART_Serial))
 80a242c:	b508      	push	{r3, lr}
 80a242e:	4b02      	ldr	r3, [pc, #8]	; (80a2438 <HAL_USART_Flush_Data+0xc>)
 80a2430:	681b      	ldr	r3, [r3, #0]
 80a2432:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80a2434:	9301      	str	r3, [sp, #4]
 80a2436:	bd08      	pop	{r3, pc}
 80a2438:	080601c4 	.word	0x080601c4

080a243c <HAL_USART_Is_Enabled>:
DYNALIB_FN(BASE_IDX + 8, hal_usart, HAL_USART_Is_Enabled, bool(HAL_USART_Serial))
 80a243c:	b508      	push	{r3, lr}
 80a243e:	4b02      	ldr	r3, [pc, #8]	; (80a2448 <HAL_USART_Is_Enabled+0xc>)
 80a2440:	681b      	ldr	r3, [r3, #0]
 80a2442:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 80a2444:	9301      	str	r3, [sp, #4]
 80a2446:	bd08      	pop	{r3, pc}
 80a2448:	080601c4 	.word	0x080601c4

080a244c <HAL_USART_Available_Data_For_Write>:
DYNALIB_FN(BASE_IDX + 9, hal_usart, HAL_USART_Half_Duplex, void(HAL_USART_Serial, bool))
DYNALIB_FN(BASE_IDX + 10, hal_usart, HAL_USART_Available_Data_For_Write, int32_t(HAL_USART_Serial))
 80a244c:	b508      	push	{r3, lr}
 80a244e:	4b02      	ldr	r3, [pc, #8]	; (80a2458 <HAL_USART_Available_Data_For_Write+0xc>)
 80a2450:	681b      	ldr	r3, [r3, #0]
 80a2452:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80a2454:	9301      	str	r3, [sp, #4]
 80a2456:	bd08      	pop	{r3, pc}
 80a2458:	080601c4 	.word	0x080601c4

080a245c <HAL_USB_USART_Init>:
#endif

DYNALIB_BEGIN(hal_usb)

#ifdef USB_CDC_ENABLE
DYNALIB_FN(0, hal_usb, HAL_USB_USART_Init, void(HAL_USB_USART_Serial, const HAL_USB_USART_Config*))
 80a245c:	b508      	push	{r3, lr}
 80a245e:	4b02      	ldr	r3, [pc, #8]	; (80a2468 <HAL_USB_USART_Init+0xc>)
 80a2460:	681b      	ldr	r3, [r3, #0]
 80a2462:	681b      	ldr	r3, [r3, #0]
 80a2464:	9301      	str	r3, [sp, #4]
 80a2466:	bd08      	pop	{r3, pc}
 80a2468:	080601d8 	.word	0x080601d8

080a246c <HAL_USB_USART_Begin>:
DYNALIB_FN(1, hal_usb, HAL_USB_USART_Begin, void(HAL_USB_USART_Serial, uint32_t, void *))
 80a246c:	b508      	push	{r3, lr}
 80a246e:	4b02      	ldr	r3, [pc, #8]	; (80a2478 <HAL_USB_USART_Begin+0xc>)
 80a2470:	681b      	ldr	r3, [r3, #0]
 80a2472:	685b      	ldr	r3, [r3, #4]
 80a2474:	9301      	str	r3, [sp, #4]
 80a2476:	bd08      	pop	{r3, pc}
 80a2478:	080601d8 	.word	0x080601d8

080a247c <HAL_USB_USART_Available_Data>:
DYNALIB_FN(2, hal_usb, HAL_USB_USART_End, void(HAL_USB_USART_Serial))
DYNALIB_FN(3, hal_usb, HAL_USB_USART_Baud_Rate, unsigned int(HAL_USB_USART_Serial))
DYNALIB_FN(4, hal_usb, HAL_USB_USART_Available_Data, int32_t(HAL_USB_USART_Serial))
 80a247c:	b508      	push	{r3, lr}
 80a247e:	4b02      	ldr	r3, [pc, #8]	; (80a2488 <HAL_USB_USART_Available_Data+0xc>)
 80a2480:	681b      	ldr	r3, [r3, #0]
 80a2482:	691b      	ldr	r3, [r3, #16]
 80a2484:	9301      	str	r3, [sp, #4]
 80a2486:	bd08      	pop	{r3, pc}
 80a2488:	080601d8 	.word	0x080601d8

080a248c <HAL_USB_USART_Available_Data_For_Write>:
DYNALIB_FN(5, hal_usb, HAL_USB_USART_Available_Data_For_Write, int32_t(HAL_USB_USART_Serial))
 80a248c:	b508      	push	{r3, lr}
 80a248e:	4b02      	ldr	r3, [pc, #8]	; (80a2498 <HAL_USB_USART_Available_Data_For_Write+0xc>)
 80a2490:	681b      	ldr	r3, [r3, #0]
 80a2492:	695b      	ldr	r3, [r3, #20]
 80a2494:	9301      	str	r3, [sp, #4]
 80a2496:	bd08      	pop	{r3, pc}
 80a2498:	080601d8 	.word	0x080601d8

080a249c <HAL_USB_USART_Receive_Data>:
DYNALIB_FN(6, hal_usb, HAL_USB_USART_Receive_Data, int32_t(HAL_USB_USART_Serial, uint8_t))
 80a249c:	b508      	push	{r3, lr}
 80a249e:	4b02      	ldr	r3, [pc, #8]	; (80a24a8 <HAL_USB_USART_Receive_Data+0xc>)
 80a24a0:	681b      	ldr	r3, [r3, #0]
 80a24a2:	699b      	ldr	r3, [r3, #24]
 80a24a4:	9301      	str	r3, [sp, #4]
 80a24a6:	bd08      	pop	{r3, pc}
 80a24a8:	080601d8 	.word	0x080601d8

080a24ac <HAL_USB_USART_Send_Data>:
DYNALIB_FN(7, hal_usb, HAL_USB_USART_Send_Data, int32_t(HAL_USB_USART_Serial, uint8_t))
 80a24ac:	b508      	push	{r3, lr}
 80a24ae:	4b02      	ldr	r3, [pc, #8]	; (80a24b8 <HAL_USB_USART_Send_Data+0xc>)
 80a24b0:	681b      	ldr	r3, [r3, #0]
 80a24b2:	69db      	ldr	r3, [r3, #28]
 80a24b4:	9301      	str	r3, [sp, #4]
 80a24b6:	bd08      	pop	{r3, pc}
 80a24b8:	080601d8 	.word	0x080601d8

080a24bc <HAL_USB_USART_Flush_Data>:
DYNALIB_FN(8, hal_usb, HAL_USB_USART_Flush_Data, void(HAL_USB_USART_Serial))
 80a24bc:	b508      	push	{r3, lr}
 80a24be:	4b02      	ldr	r3, [pc, #8]	; (80a24c8 <HAL_USB_USART_Flush_Data+0xc>)
 80a24c0:	681b      	ldr	r3, [r3, #0]
 80a24c2:	6a1b      	ldr	r3, [r3, #32]
 80a24c4:	9301      	str	r3, [sp, #4]
 80a24c6:	bd08      	pop	{r3, pc}
 80a24c8:	080601d8 	.word	0x080601d8

080a24cc <set_system_mode>:
#endif

DYNALIB_BEGIN(system)

DYNALIB_FN(0, system, system_mode, System_Mode_TypeDef(void))
DYNALIB_FN(1, system, set_system_mode, void(System_Mode_TypeDef))
 80a24cc:	b508      	push	{r3, lr}
 80a24ce:	4b02      	ldr	r3, [pc, #8]	; (80a24d8 <set_system_mode+0xc>)
 80a24d0:	681b      	ldr	r3, [r3, #0]
 80a24d2:	685b      	ldr	r3, [r3, #4]
 80a24d4:	9301      	str	r3, [sp, #4]
 80a24d6:	bd08      	pop	{r3, pc}
 80a24d8:	080601a4 	.word	0x080601a4

080a24dc <system_delay_ms>:

DYNALIB_FN(2, system, set_ymodem_serial_flash_update_handler, void(ymodem_serial_flash_update_handler))
DYNALIB_FN(3, system, system_firmwareUpdate, bool(Stream*, void*))
DYNALIB_FN(4, system, system_fileTransfer, bool(system_file_transfer_t*, void*))

DYNALIB_FN(5, system, system_delay_ms, void(unsigned long, bool))
 80a24dc:	b508      	push	{r3, lr}
 80a24de:	4b02      	ldr	r3, [pc, #8]	; (80a24e8 <system_delay_ms+0xc>)
 80a24e0:	681b      	ldr	r3, [r3, #0]
 80a24e2:	695b      	ldr	r3, [r3, #20]
 80a24e4:	9301      	str	r3, [sp, #4]
 80a24e6:	bd08      	pop	{r3, pc}
 80a24e8:	080601a4 	.word	0x080601a4

080a24ec <system_ctrl_set_app_request_handler>:
DYNALIB_FN(BASE_IDX + 6, system, led_pattern_period, uint16_t(int, int, void*))
DYNALIB_FN(BASE_IDX + 7, system, system_set_tester_handlers, int(system_tester_handlers_t*, void*))
DYNALIB_FN(BASE_IDX + 8, system, system_format_diag_data, int(const uint16_t*, size_t, unsigned, appender_fn, void*, void*))

// Control requests
DYNALIB_FN(BASE_IDX + 9, system, system_ctrl_set_app_request_handler, int(ctrl_request_handler_fn, void*))
 80a24ec:	b508      	push	{r3, lr}
 80a24ee:	4b03      	ldr	r3, [pc, #12]	; (80a24fc <system_ctrl_set_app_request_handler+0x10>)
 80a24f0:	681b      	ldr	r3, [r3, #0]
 80a24f2:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 80a24f6:	9301      	str	r3, [sp, #4]
 80a24f8:	bd08      	pop	{r3, pc}
 80a24fa:	0000      	.short	0x0000
 80a24fc:	080601a4 	.word	0x080601a4

080a2500 <system_ctrl_set_result>:
DYNALIB_FN(BASE_IDX + 10, system, system_ctrl_alloc_reply_data, int(ctrl_request*, size_t, void*))
DYNALIB_FN(BASE_IDX + 11, system, system_ctrl_free_request_data, void(ctrl_request*, void*))
DYNALIB_FN(BASE_IDX + 12, system, system_ctrl_set_result, void(ctrl_request*, int, ctrl_completion_handler_fn, void*, void*))
 80a2500:	b508      	push	{r3, lr}
 80a2502:	4b03      	ldr	r3, [pc, #12]	; (80a2510 <system_ctrl_set_result+0x10>)
 80a2504:	681b      	ldr	r3, [r3, #0]
 80a2506:	f8d3 309c 	ldr.w	r3, [r3, #156]	; 0x9c
 80a250a:	9301      	str	r3, [sp, #4]
 80a250c:	bd08      	pop	{r3, pc}
 80a250e:	0000      	.short	0x0000
 80a2510:	080601a4 	.word	0x080601a4

080a2514 <system_sleep_pins>:

DYNALIB_FN(BASE_IDX + 13, system, system_pool_alloc, void*(size_t, void*))
DYNALIB_FN(BASE_IDX + 14, system, system_pool_free, void(void*, void*))
DYNALIB_FN(BASE_IDX + 15, system, system_sleep_pins, int32_t(const uint16_t*, size_t, const InterruptMode*, size_t, long, uint32_t, void*))
 80a2514:	b508      	push	{r3, lr}
 80a2516:	4b03      	ldr	r3, [pc, #12]	; (80a2524 <system_sleep_pins+0x10>)
 80a2518:	681b      	ldr	r3, [r3, #0]
 80a251a:	f8d3 30a8 	ldr.w	r3, [r3, #168]	; 0xa8
 80a251e:	9301      	str	r3, [sp, #4]
 80a2520:	bd08      	pop	{r3, pc}
 80a2522:	0000      	.short	0x0000
 80a2524:	080601a4 	.word	0x080601a4

080a2528 <spark_variable>:
#endif


DYNALIB_BEGIN(system_cloud)

DYNALIB_FN(0, system_cloud, spark_variable, bool(const char*, const void*, Spark_Data_TypeDef, spark_variable_t*))
 80a2528:	b508      	push	{r3, lr}
 80a252a:	4b02      	ldr	r3, [pc, #8]	; (80a2534 <spark_variable+0xc>)
 80a252c:	681b      	ldr	r3, [r3, #0]
 80a252e:	681b      	ldr	r3, [r3, #0]
 80a2530:	9301      	str	r3, [sp, #4]
 80a2532:	bd08      	pop	{r3, pc}
 80a2534:	080601cc 	.word	0x080601cc

080a2538 <spark_function>:
DYNALIB_FN(1, system_cloud, spark_function, bool(const char*, p_user_function_int_str_t, void*))
 80a2538:	b508      	push	{r3, lr}
 80a253a:	4b02      	ldr	r3, [pc, #8]	; (80a2544 <spark_function+0xc>)
 80a253c:	681b      	ldr	r3, [r3, #0]
 80a253e:	685b      	ldr	r3, [r3, #4]
 80a2540:	9301      	str	r3, [sp, #4]
 80a2542:	bd08      	pop	{r3, pc}
 80a2544:	080601cc 	.word	0x080601cc

080a2548 <spark_set_random_seed_from_cloud_handler>:
DYNALIB_FN(10, system_cloud, spark_unsubscribe, void(void*))
DYNALIB_FN(11, system_cloud, spark_sync_time, bool(void*))
DYNALIB_FN(12, system_cloud, spark_sync_time_pending, bool(void*))
DYNALIB_FN(13, system_cloud, spark_sync_time_last, system_tick_t(time_t*, void*))
DYNALIB_FN(14, system_cloud, spark_set_connection_property, int(unsigned, unsigned, particle::protocol::connection_properties_t*, void*))
DYNALIB_FN(15, system_cloud, spark_set_random_seed_from_cloud_handler, int(void (*handler)(unsigned int), void*))
 80a2548:	b508      	push	{r3, lr}
 80a254a:	4b02      	ldr	r3, [pc, #8]	; (80a2554 <spark_set_random_seed_from_cloud_handler+0xc>)
 80a254c:	681b      	ldr	r3, [r3, #0]
 80a254e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 80a2550:	9301      	str	r3, [sp, #4]
 80a2552:	bd08      	pop	{r3, pc}
 80a2554:	080601cc 	.word	0x080601cc

080a2558 <network_ready>:

DYNALIB_FN(0, system_net, network_config, const void*(network_handle_t, uint32_t, void*))
DYNALIB_FN(1, system_net, network_connect, void(network_handle_t, uint32_t, uint32_t, void*))
DYNALIB_FN(2, system_net, network_connecting, bool(network_handle_t, uint32_t, void*))
DYNALIB_FN(3, system_net, network_disconnect, void(network_handle_t, uint32_t, void*))
DYNALIB_FN(4, system_net, network_ready, bool(network_handle_t, uint32_t, void*))
 80a2558:	b508      	push	{r3, lr}
 80a255a:	4b02      	ldr	r3, [pc, #8]	; (80a2564 <network_ready+0xc>)
 80a255c:	681b      	ldr	r3, [r3, #0]
 80a255e:	691b      	ldr	r3, [r3, #16]
 80a2560:	9301      	str	r3, [sp, #4]
 80a2562:	bd08      	pop	{r3, pc}
 80a2564:	080601c8 	.word	0x080601c8

080a2568 <malloc>:

#include "dynalib.h"

DYNALIB_BEGIN(rt)

DYNALIB_FN(0, rt, malloc, void*(size_t))
 80a2568:	b508      	push	{r3, lr}
 80a256a:	4b02      	ldr	r3, [pc, #8]	; (80a2574 <malloc+0xc>)
 80a256c:	681b      	ldr	r3, [r3, #0]
 80a256e:	681b      	ldr	r3, [r3, #0]
 80a2570:	9301      	str	r3, [sp, #4]
 80a2572:	bd08      	pop	{r3, pc}
 80a2574:	080601a0 	.word	0x080601a0

080a2578 <free>:
DYNALIB_FN(1, rt, free, void(void*))
 80a2578:	b508      	push	{r3, lr}
 80a257a:	4b02      	ldr	r3, [pc, #8]	; (80a2584 <free+0xc>)
 80a257c:	681b      	ldr	r3, [r3, #0]
 80a257e:	685b      	ldr	r3, [r3, #4]
 80a2580:	9301      	str	r3, [sp, #4]
 80a2582:	bd08      	pop	{r3, pc}
 80a2584:	080601a0 	.word	0x080601a0

080a2588 <realloc>:
DYNALIB_FN(2, rt, realloc, void*(void*, size_t))
 80a2588:	b508      	push	{r3, lr}
 80a258a:	4b02      	ldr	r3, [pc, #8]	; (80a2594 <realloc+0xc>)
 80a258c:	681b      	ldr	r3, [r3, #0]
 80a258e:	689b      	ldr	r3, [r3, #8]
 80a2590:	9301      	str	r3, [sp, #4]
 80a2592:	bd08      	pop	{r3, pc}
 80a2594:	080601a0 	.word	0x080601a0

080a2598 <delay>:
    return (value - fromStart) * (toEnd - toStart) / (fromEnd - fromStart) + toStart;
}

void delay(unsigned long ms)
{
    system_delay_ms(ms, false);
 80a2598:	2100      	movs	r1, #0
 80a259a:	f7ff bf9f 	b.w	80a24dc <system_delay_ms>

080a259e <_ZNSt14_Function_baseD1Ev>:
	}
      };

    _Function_base() : _M_manager(nullptr) { }

    ~_Function_base()
 80a259e:	b510      	push	{r4, lr}
    {
      if (_M_manager)
 80a25a0:	6883      	ldr	r3, [r0, #8]
	}
      };

    _Function_base() : _M_manager(nullptr) { }

    ~_Function_base()
 80a25a2:	4604      	mov	r4, r0
    {
      if (_M_manager)
 80a25a4:	b113      	cbz	r3, 80a25ac <_ZNSt14_Function_baseD1Ev+0xe>
	_M_manager(_M_functor, _M_functor, __destroy_functor);
 80a25a6:	2203      	movs	r2, #3
 80a25a8:	4601      	mov	r1, r0
 80a25aa:	4798      	blx	r3
    }
 80a25ac:	4620      	mov	r0, r4
 80a25ae:	bd10      	pop	{r4, pc}

080a25b0 <_ZN10CloudClass22call_raw_user_functionEPvPKcS0_>:
}
#endif
} // namespace

int CloudClass::call_raw_user_function(void* data, const char* param, void* reserved)
{
 80a25b0:	b510      	push	{r4, lr}
 80a25b2:	b088      	sub	sp, #32
 80a25b4:	4604      	mov	r4, r0
    user_function_int_str_t* fn = (user_function_int_str_t*)(data);
    String p(param);
 80a25b6:	4668      	mov	r0, sp
 80a25b8:	f000 f99a 	bl	80a28f0 <_ZN6StringC1EPK19__FlashStringHelper>
    return (*fn)(p);
 80a25bc:	4669      	mov	r1, sp
 80a25be:	a804      	add	r0, sp, #16
 80a25c0:	f000 f9b8 	bl	80a2934 <_ZN6StringC1ERKS_>
 80a25c4:	a804      	add	r0, sp, #16
 80a25c6:	47a0      	blx	r4
 80a25c8:	4604      	mov	r4, r0
 80a25ca:	a804      	add	r0, sp, #16
 80a25cc:	f000 f949 	bl	80a2862 <_ZN6StringD1Ev>
} // namespace

int CloudClass::call_raw_user_function(void* data, const char* param, void* reserved)
{
    user_function_int_str_t* fn = (user_function_int_str_t*)(data);
    String p(param);
 80a25d0:	4668      	mov	r0, sp
 80a25d2:	f000 f946 	bl	80a2862 <_ZN6StringD1Ev>
    return (*fn)(p);
}
 80a25d6:	4620      	mov	r0, r4
 80a25d8:	b008      	add	sp, #32
 80a25da:	bd10      	pop	{r4, pc}

080a25dc <_ZN10CloudClass17register_functionEPFiPvPKcS0_ES0_S2_>:
    wiring_event_handler_t* fn = (wiring_event_handler_t*)(handler_data);
    (*fn)(event_name, data);
}

bool CloudClass::register_function(cloud_function_t fn, void* data, const char* funcKey)
{
 80a25dc:	b5f0      	push	{r4, r5, r6, r7, lr}
 80a25de:	4607      	mov	r7, r0
 80a25e0:	460e      	mov	r6, r1
 80a25e2:	4615      	mov	r5, r2
 80a25e4:	b085      	sub	sp, #20
    cloud_function_descriptor desc;
    memset(&desc, 0, sizeof(desc));
 80a25e6:	2410      	movs	r4, #16
 80a25e8:	4622      	mov	r2, r4
 80a25ea:	2100      	movs	r1, #0
 80a25ec:	4668      	mov	r0, sp
 80a25ee:	f001 fa3c 	bl	80a3a6a <memset>
    desc.size = sizeof(desc);
    desc.fn = fn;
    desc.data = (void*)data;
    desc.funcKey = funcKey;
    return spark_function(NULL, (user_function_int_str_t*)&desc, NULL);
 80a25f2:	2200      	movs	r2, #0
 80a25f4:	4669      	mov	r1, sp
 80a25f6:	4610      	mov	r0, r2

bool CloudClass::register_function(cloud_function_t fn, void* data, const char* funcKey)
{
    cloud_function_descriptor desc;
    memset(&desc, 0, sizeof(desc));
    desc.size = sizeof(desc);
 80a25f8:	f8ad 4000 	strh.w	r4, [sp]
    desc.fn = fn;
 80a25fc:	9702      	str	r7, [sp, #8]
    desc.data = (void*)data;
 80a25fe:	9603      	str	r6, [sp, #12]
    desc.funcKey = funcKey;
 80a2600:	9501      	str	r5, [sp, #4]
    return spark_function(NULL, (user_function_int_str_t*)&desc, NULL);
 80a2602:	f7ff ff99 	bl	80a2538 <spark_function>
}
 80a2606:	b005      	add	sp, #20
 80a2608:	bdf0      	pop	{r4, r5, r6, r7, pc}

080a260a <_ZN7TwoWireD1Ev>:
private:
  HAL_I2C_Interface _i2c;

public:
  TwoWire(HAL_I2C_Interface i2c);
  virtual ~TwoWire() {};
 80a260a:	4770      	bx	lr

080a260c <_ZN7TwoWire5writeEPKhj>:

// must be called in:
// slave tx event callback
// or after beginTransmission(address)
size_t TwoWire::write(const uint8_t *data, size_t quantity)
{
 80a260c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80a260e:	4606      	mov	r6, r0
 80a2610:	4615      	mov	r5, r2
 80a2612:	460c      	mov	r4, r1
 80a2614:	188f      	adds	r7, r1, r2
  // in master/slave transmitter mode
  for(size_t i = 0; i < quantity; ++i)
 80a2616:	42bc      	cmp	r4, r7
 80a2618:	d006      	beq.n	80a2628 <_ZN7TwoWire5writeEPKhj+0x1c>
  {
    write(data[i]);
 80a261a:	6833      	ldr	r3, [r6, #0]
 80a261c:	f814 1b01 	ldrb.w	r1, [r4], #1
 80a2620:	689b      	ldr	r3, [r3, #8]
 80a2622:	4630      	mov	r0, r6
 80a2624:	4798      	blx	r3
// slave tx event callback
// or after beginTransmission(address)
size_t TwoWire::write(const uint8_t *data, size_t quantity)
{
  // in master/slave transmitter mode
  for(size_t i = 0; i < quantity; ++i)
 80a2626:	e7f6      	b.n	80a2616 <_ZN7TwoWire5writeEPKhj+0xa>
  {
    write(data[i]);
  }

  return quantity;
}
 80a2628:	4628      	mov	r0, r5
 80a262a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

080a262c <_ZN7TwoWire5writeEh>:
// must be called in:
// slave tx event callback
// or after beginTransmission(address)
size_t TwoWire::write(uint8_t data)
{
  return HAL_I2C_Write_Data(_i2c, data, NULL);
 80a262c:	2200      	movs	r2, #0
 80a262e:	7c00      	ldrb	r0, [r0, #16]
 80a2630:	f7ff be8a 	b.w	80a2348 <HAL_I2C_Write_Data>

080a2634 <_ZN7TwoWire9availableEv>:
// must be called in:
// slave rx event callback
// or after requestFrom(address, numBytes)
int TwoWire::available(void)
{
  return HAL_I2C_Available_Data(_i2c, NULL);
 80a2634:	2100      	movs	r1, #0
 80a2636:	7c00      	ldrb	r0, [r0, #16]
 80a2638:	f7ff be8e 	b.w	80a2358 <HAL_I2C_Available_Data>

080a263c <_ZN7TwoWire4readEv>:
// must be called in:
// slave rx event callback
// or after requestFrom(address, numBytes)
int TwoWire::read(void)
{
  return HAL_I2C_Read_Data(_i2c, NULL);
 80a263c:	2100      	movs	r1, #0
 80a263e:	7c00      	ldrb	r0, [r0, #16]
 80a2640:	f7ff be92 	b.w	80a2368 <HAL_I2C_Read_Data>

080a2644 <_ZN7TwoWire4peekEv>:
// must be called in:
// slave rx event callback
// or after requestFrom(address, numBytes)
int TwoWire::peek(void)
{
  return HAL_I2C_Peek_Data(_i2c, NULL);
 80a2644:	2100      	movs	r1, #0
 80a2646:	7c00      	ldrb	r0, [r0, #16]
 80a2648:	f7ff be96 	b.w	80a2378 <HAL_I2C_Peek_Data>

080a264c <_ZN7TwoWire5flushEv>:
}

void TwoWire::flush(void)
{
  HAL_I2C_Flush_Data(_i2c, NULL);
 80a264c:	2100      	movs	r1, #0
 80a264e:	7c00      	ldrb	r0, [r0, #16]
 80a2650:	f7ff be9a 	b.w	80a2388 <HAL_I2C_Flush_Data>

080a2654 <_ZN7TwoWireD0Ev>:
 80a2654:	b510      	push	{r4, lr}
 80a2656:	4604      	mov	r4, r0
 80a2658:	f7fd fd1f 	bl	80a009a <_ZdlPv>
 80a265c:	4620      	mov	r0, r4
 80a265e:	bd10      	pop	{r4, pc}

080a2660 <_ZN7TwoWireC1E17HAL_I2C_Interface>:
#include "i2c_hal.h"
#include "spark_wiring_thread.h"

// Constructors ////////////////////////////////////////////////////////////////

TwoWire::TwoWire(HAL_I2C_Interface i2c)
 80a2660:	b510      	push	{r4, lr}
 80a2662:	4604      	mov	r4, r0
 80a2664:	4608      	mov	r0, r1
    virtual int available() = 0;
    virtual int read() = 0;
    virtual int peek() = 0;
    virtual void flush() = 0;

    Stream() {_timeout=1000;}
 80a2666:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 80a266a:	60a3      	str	r3, [r4, #8]
 80a266c:	4b04      	ldr	r3, [pc, #16]	; (80a2680 <_ZN7TwoWireC1E17HAL_I2C_Interface+0x20>)
  protected:
    void setWriteError(int err = 1) { write_error = err; }
    size_t printf_impl(bool newline, const char* format, ...);

  public:
    Print() : write_error(0) {}
 80a266e:	2100      	movs	r1, #0
{
  _i2c = i2c;
 80a2670:	7420      	strb	r0, [r4, #16]
 80a2672:	6061      	str	r1, [r4, #4]
#include "i2c_hal.h"
#include "spark_wiring_thread.h"

// Constructors ////////////////////////////////////////////////////////////////

TwoWire::TwoWire(HAL_I2C_Interface i2c)
 80a2674:	6023      	str	r3, [r4, #0]
{
  _i2c = i2c;
  HAL_I2C_Init(_i2c, NULL);
 80a2676:	f7ff fe97 	bl	80a23a8 <HAL_I2C_Init>

}
 80a267a:	4620      	mov	r0, r4
 80a267c:	bd10      	pop	{r4, pc}
 80a267e:	bf00      	nop
 80a2680:	080a4110 	.word	0x080a4110

080a2684 <_ZN7TwoWire9isEnabledEv>:
  HAL_I2C_Set_Callback_On_Request(_i2c, function, NULL);
}

bool TwoWire::isEnabled()
{
  return HAL_I2C_Is_Enabled(_i2c, NULL);
 80a2684:	2100      	movs	r1, #0
 80a2686:	7c00      	ldrb	r0, [r0, #16]
 80a2688:	f7ff be86 	b.w	80a2398 <HAL_I2C_Is_Enabled>

080a268c <_ZN9IPAddressD1Ev>:
    IPAddress(uint8_t first_octet, uint8_t second_octet, uint8_t third_octet, uint8_t fourth_octet);
    IPAddress(uint32_t address);
    IPAddress(const uint8_t* address);
    IPAddress(const HAL_IPAddress& address);

    virtual ~IPAddress() {}
 80a268c:	4770      	bx	lr

080a268e <_ZN9IPAddressD0Ev>:
 80a268e:	b510      	push	{r4, lr}
 80a2690:	4604      	mov	r4, r0
 80a2692:	f7fd fd02 	bl	80a009a <_ZdlPv>
 80a2696:	4620      	mov	r0, r4
 80a2698:	bd10      	pop	{r4, pc}

080a269a <_ZNK9IPAddress7printToER5Print>:
#endif
	return address.ipv4==that.address.ipv4;
}

size_t IPAddress::printTo(Print& p) const
{
 80a269a:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80a269c:	460f      	mov	r7, r1
 80a269e:	f100 0608 	add.w	r6, r0, #8
 80a26a2:	1d05      	adds	r5, r0, #4
 80a26a4:	2400      	movs	r4, #0
    size_t n = 0;
    for (int i = 0; i < 4; i++)
    {
        if (n)
            n += p.print('.');
        n += p.print((*this)[i], DEC);
 80a26a6:	f816 1d01 	ldrb.w	r1, [r6, #-1]!
 80a26aa:	220a      	movs	r2, #10
 80a26ac:	4638      	mov	r0, r7
 80a26ae:	f000 f898 	bl	80a27e2 <_ZN5Print5printEhi>
}

size_t IPAddress::printTo(Print& p) const
{
    size_t n = 0;
    for (int i = 0; i < 4; i++)
 80a26b2:	42ae      	cmp	r6, r5
    {
        if (n)
            n += p.print('.');
        n += p.print((*this)[i], DEC);
 80a26b4:	4404      	add	r4, r0
}

size_t IPAddress::printTo(Print& p) const
{
    size_t n = 0;
    for (int i = 0; i < 4; i++)
 80a26b6:	d007      	beq.n	80a26c8 <_ZNK9IPAddress7printToER5Print+0x2e>
    {
        if (n)
 80a26b8:	2c00      	cmp	r4, #0
 80a26ba:	d0f4      	beq.n	80a26a6 <_ZNK9IPAddress7printToER5Print+0xc>
            n += p.print('.');
 80a26bc:	212e      	movs	r1, #46	; 0x2e
 80a26be:	4638      	mov	r0, r7
 80a26c0:	f000 f84c 	bl	80a275c <_ZN5Print5printEc>
 80a26c4:	4404      	add	r4, r0
 80a26c6:	e7ee      	b.n	80a26a6 <_ZNK9IPAddress7printToER5Print+0xc>
        n += p.print((*this)[i], DEC);
    }
    return n;
}
 80a26c8:	4620      	mov	r0, r4
 80a26ca:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

080a26cc <_ZN9IPAddress8set_ipv4Ehhhh>:
    return address.ipv4!=0;
#endif
}

void IPAddress::set_ipv4(uint8_t b0, uint8_t b1, uint8_t b2, uint8_t b3)
{
 80a26cc:	b510      	push	{r4, lr}
    address.ipv4 = b0<<24 | b1 << 16 | b2 << 8 | b3;
 80a26ce:	f89d 4008 	ldrb.w	r4, [sp, #8]
 80a26d2:	ea44 2303 	orr.w	r3, r4, r3, lsl #8
 80a26d6:	ea43 4202 	orr.w	r2, r3, r2, lsl #16
 80a26da:	ea42 6101 	orr.w	r1, r2, r1, lsl #24
        return &address;
    }

    inline void setVersion(uint8_t version) {
#if HAL_IPv6
        address.v = version;
 80a26de:	2304      	movs	r3, #4
 80a26e0:	6041      	str	r1, [r0, #4]
 80a26e2:	7503      	strb	r3, [r0, #20]
 80a26e4:	bd10      	pop	{r4, pc}
	...

080a26e8 <_ZN9IPAddressC1Ehhhh>:
{
    memcpy(&this->address, &address, sizeof(address));
}


IPAddress::IPAddress(uint8_t first_octet, uint8_t second_octet, uint8_t third_octet, uint8_t fourth_octet)
 80a26e8:	b537      	push	{r0, r1, r2, r4, r5, lr}
 80a26ea:	4d04      	ldr	r5, [pc, #16]	; (80a26fc <_ZN9IPAddressC1Ehhhh+0x14>)
 80a26ec:	6005      	str	r5, [r0, #0]
{
    set_ipv4(first_octet, second_octet, third_octet, fourth_octet);
 80a26ee:	f89d 5018 	ldrb.w	r5, [sp, #24]
 80a26f2:	9500      	str	r5, [sp, #0]
 80a26f4:	f7ff ffea 	bl	80a26cc <_ZN9IPAddress8set_ipv4Ehhhh>
}
 80a26f8:	b003      	add	sp, #12
 80a26fa:	bd30      	pop	{r4, r5, pc}
 80a26fc:	080a4138 	.word	0x080a4138

080a2700 <_GLOBAL__sub_I__ZN5spark3LogE>:
    // This handler doesn't support direct logging
}

// spark::Logger
inline spark::Logger::Logger(const char *name) :
        name_(name) {
 80a2700:	4a01      	ldr	r2, [pc, #4]	; (80a2708 <_GLOBAL__sub_I__ZN5spark3LogE+0x8>)
 80a2702:	4b02      	ldr	r3, [pc, #8]	; (80a270c <_GLOBAL__sub_I__ZN5spark3LogE+0xc>)
 80a2704:	601a      	str	r2, [r3, #0]
 80a2706:	4770      	bx	lr
 80a2708:	080a41ff 	.word	0x080a41ff
 80a270c:	20000be4 	.word	0x20000be4

080a2710 <_ZN5Print5writeEPKhj>:

// Public Methods //////////////////////////////////////////////////////////////

/* default implementation: may be overridden */
size_t Print::write(const uint8_t *buffer, size_t size)
{
 80a2710:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80a2712:	4606      	mov	r6, r0
 80a2714:	460d      	mov	r5, r1
 80a2716:	188f      	adds	r7, r1, r2
  size_t n = 0;
 80a2718:	2400      	movs	r4, #0
  while (size--) {
 80a271a:	42bd      	cmp	r5, r7
 80a271c:	d00c      	beq.n	80a2738 <_ZN5Print5writeEPKhj+0x28>
     int chunk = write(*buffer++);
 80a271e:	6833      	ldr	r3, [r6, #0]
 80a2720:	f815 1b01 	ldrb.w	r1, [r5], #1
 80a2724:	689b      	ldr	r3, [r3, #8]
 80a2726:	4630      	mov	r0, r6
 80a2728:	4798      	blx	r3
     if (chunk>=0)
 80a272a:	2800      	cmp	r0, #0
 80a272c:	db01      	blt.n	80a2732 <_ZN5Print5writeEPKhj+0x22>
         n += chunk;
 80a272e:	4404      	add	r4, r0

/* default implementation: may be overridden */
size_t Print::write(const uint8_t *buffer, size_t size)
{
  size_t n = 0;
  while (size--) {
 80a2730:	e7f3      	b.n	80a271a <_ZN5Print5writeEPKhj+0xa>
     int chunk = write(*buffer++);
 80a2732:	2c00      	cmp	r4, #0
 80a2734:	bf08      	it	eq
 80a2736:	4604      	moveq	r4, r0
             n = chunk;
         break;
     }
  }
  return n;
}
 80a2738:	4620      	mov	r0, r4
 80a273a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

080a273c <_ZN5Print5writeEPKc>:

    int getWriteError() { return write_error; }
    void clearWriteError() { setWriteError(0); }

    virtual size_t write(uint8_t) = 0;
    size_t write(const char *str) {
 80a273c:	b570      	push	{r4, r5, r6, lr}
 80a273e:	4605      	mov	r5, r0
      if (str == NULL) return 0;
 80a2740:	460c      	mov	r4, r1
      return write((const uint8_t *)str, strlen(str));
    }
 80a2742:	4608      	mov	r0, r1
    int getWriteError() { return write_error; }
    void clearWriteError() { setWriteError(0); }

    virtual size_t write(uint8_t) = 0;
    size_t write(const char *str) {
      if (str == NULL) return 0;
 80a2744:	b149      	cbz	r1, 80a275a <_ZN5Print5writeEPKc+0x1e>
      return write((const uint8_t *)str, strlen(str));
 80a2746:	f001 fa03 	bl	80a3b50 <strlen>
 80a274a:	682b      	ldr	r3, [r5, #0]
 80a274c:	4602      	mov	r2, r0
 80a274e:	4621      	mov	r1, r4
 80a2750:	4628      	mov	r0, r5
    }
 80a2752:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    void clearWriteError() { setWriteError(0); }

    virtual size_t write(uint8_t) = 0;
    size_t write(const char *str) {
      if (str == NULL) return 0;
      return write((const uint8_t *)str, strlen(str));
 80a2756:	68db      	ldr	r3, [r3, #12]
 80a2758:	4718      	bx	r3
    }
 80a275a:	bd70      	pop	{r4, r5, r6, pc}

080a275c <_ZN5Print5printEc>:
  return write(str);
}

size_t Print::print(char c)
{
  return write(c);
 80a275c:	6803      	ldr	r3, [r0, #0]
 80a275e:	689b      	ldr	r3, [r3, #8]
 80a2760:	4718      	bx	r3

080a2762 <_ZN5Print7printlnEv>:
{
  return print(reinterpret_cast<const char*>(str));
}

size_t Print::println(void)
{
 80a2762:	b538      	push	{r3, r4, r5, lr}
  size_t n = print('\r');
 80a2764:	210d      	movs	r1, #13
{
  return print(reinterpret_cast<const char*>(str));
}

size_t Print::println(void)
{
 80a2766:	4605      	mov	r5, r0
  size_t n = print('\r');
 80a2768:	f7ff fff8 	bl	80a275c <_ZN5Print5printEc>
  n += print('\n');
 80a276c:	210a      	movs	r1, #10
  return print(reinterpret_cast<const char*>(str));
}

size_t Print::println(void)
{
  size_t n = print('\r');
 80a276e:	4604      	mov	r4, r0
  n += print('\n');
 80a2770:	4628      	mov	r0, r5
 80a2772:	f7ff fff3 	bl	80a275c <_ZN5Print5printEc>
  return n;
}
 80a2776:	4420      	add	r0, r4
 80a2778:	bd38      	pop	{r3, r4, r5, pc}

080a277a <_ZN5Print7printlnEPKc>:

size_t Print::println(const char c[])
{
 80a277a:	b538      	push	{r3, r4, r5, lr}
 80a277c:	4605      	mov	r5, r0
  return n;
}

size_t Print::print(const char str[])
{
  return write(str);
 80a277e:	f7ff ffdd 	bl	80a273c <_ZN5Print5writeEPKc>
 80a2782:	4604      	mov	r4, r0
}

size_t Print::println(const char c[])
{
  size_t n = print(c);
  n += println();
 80a2784:	4628      	mov	r0, r5
 80a2786:	f7ff ffec 	bl	80a2762 <_ZN5Print7printlnEv>
  return n;
}
 80a278a:	4420      	add	r0, r4
 80a278c:	bd38      	pop	{r3, r4, r5, pc}

080a278e <_ZN5Print11printNumberEmh>:
  char *str = &buf[sizeof(buf) - 1];

  *str = '\0';

  // prevent crash if called with base == 1
  if (base < 2) base = 10;
 80a278e:	2a01      	cmp	r2, #1
 80a2790:	bf98      	it	ls
 80a2792:	220a      	movls	r2, #10
  return println(reinterpret_cast<const char*>(str));
}

// Private Methods /////////////////////////////////////////////////////////////

size_t Print::printNumber(unsigned long n, uint8_t base) {
 80a2794:	b530      	push	{r4, r5, lr}
 80a2796:	460b      	mov	r3, r1
 80a2798:	b08b      	sub	sp, #44	; 0x2c
  char buf[8 * sizeof(long) + 1]; // Assumes 8-bit chars plus zero byte.
  char *str = &buf[sizeof(buf) - 1];

  *str = '\0';
 80a279a:	2100      	movs	r1, #0
 80a279c:	f88d 1024 	strb.w	r1, [sp, #36]	; 0x24
 80a27a0:	f10d 0423 	add.w	r4, sp, #35	; 0x23
  // prevent crash if called with base == 1
  if (base < 2) base = 10;

  do {
    unsigned long m = n;
    n /= base;
 80a27a4:	fbb3 f5f2 	udiv	r5, r3, r2
    char c = m - base * n;
 80a27a8:	fb05 3312 	mls	r3, r5, r2, r3
 80a27ac:	b2db      	uxtb	r3, r3
    *--str = c < 10 ? c + '0' : c + 'A' - 10;
 80a27ae:	2b09      	cmp	r3, #9
 80a27b0:	bf94      	ite	ls
 80a27b2:	3330      	addls	r3, #48	; 0x30
 80a27b4:	3337      	addhi	r3, #55	; 0x37
 80a27b6:	b2db      	uxtb	r3, r3
 80a27b8:	4621      	mov	r1, r4
 80a27ba:	f804 3901 	strb.w	r3, [r4], #-1
 80a27be:	462b      	mov	r3, r5
  *str = '\0';

  // prevent crash if called with base == 1
  if (base < 2) base = 10;

  do {
 80a27c0:	2d00      	cmp	r5, #0
 80a27c2:	d1ef      	bne.n	80a27a4 <_ZN5Print11printNumberEmh+0x16>
    n /= base;
    char c = m - base * n;
    *--str = c < 10 ? c + '0' : c + 'A' - 10;
  } while(n);

  return write(str);
 80a27c4:	f7ff ffba 	bl	80a273c <_ZN5Print5writeEPKc>
}
 80a27c8:	b00b      	add	sp, #44	; 0x2c
 80a27ca:	bd30      	pop	{r4, r5, pc}

080a27cc <_ZN5Print5printEmi>:
    return printNumber(n, base);
  }
}

size_t Print::print(unsigned long n, int base)
{
 80a27cc:	b410      	push	{r4}
  if (base == 0) return write(n);
 80a27ce:	b922      	cbnz	r2, 80a27da <_ZN5Print5printEmi+0xe>
 80a27d0:	6803      	ldr	r3, [r0, #0]
 80a27d2:	b2c9      	uxtb	r1, r1
 80a27d4:	689b      	ldr	r3, [r3, #8]
  else return printNumber(n, base);
}
 80a27d6:	bc10      	pop	{r4}
  }
}

size_t Print::print(unsigned long n, int base)
{
  if (base == 0) return write(n);
 80a27d8:	4718      	bx	r3
  else return printNumber(n, base);
 80a27da:	b2d2      	uxtb	r2, r2
}
 80a27dc:	bc10      	pop	{r4}
}

size_t Print::print(unsigned long n, int base)
{
  if (base == 0) return write(n);
  else return printNumber(n, base);
 80a27de:	f7ff bfd6 	b.w	80a278e <_ZN5Print11printNumberEmh>

080a27e2 <_ZN5Print5printEhi>:
  return write(c);
}

size_t Print::print(unsigned char b, int base)
{
  return print((unsigned long) b, base);
 80a27e2:	f7ff bff3 	b.w	80a27cc <_ZN5Print5printEmi>

080a27e6 <_Z6randomi>:
#include "spark_wiring_random.h"
#include <stdlib.h>

int random(int max)
{
 80a27e6:	b510      	push	{r4, lr}
  if (0 == max) {
 80a27e8:	4604      	mov	r4, r0
 80a27ea:	b130      	cbz	r0, 80a27fa <_Z6randomi+0x14>
    return 0;
  }
  return rand() % max;
 80a27ec:	f001 f96e 	bl	80a3acc <rand>
 80a27f0:	fb90 f3f4 	sdiv	r3, r0, r4
 80a27f4:	fb03 0014 	mls	r0, r3, r4, r0
 80a27f8:	bd10      	pop	{r4, pc}
}
 80a27fa:	bd10      	pop	{r4, pc}

080a27fc <_ZN8RGBClassD1Ev>:
#include "rgbled.h"

typedef void (raw_rgb_change_handler_t)(uint8_t, uint8_t, uint8_t);
typedef std::function<raw_rgb_change_handler_t> wiring_rgb_change_handler_t;

class RGBClass {
 80a27fc:	b510      	push	{r4, lr}
 80a27fe:	4604      	mov	r4, r0
   *  @ingroup functors
   *
   *  Polymorphic function wrapper.
   */
  template<typename _Res, typename... _ArgTypes>
    class function<_Res(_ArgTypes...)>
 80a2800:	f7ff fecd 	bl	80a259e <_ZNSt14_Function_baseD1Ev>
 80a2804:	4620      	mov	r0, r4
 80a2806:	bd10      	pop	{r4, pc}

080a2808 <_GLOBAL__sub_I_RGB>:
	{
	  _Base::_M_init_functor(__functor, std::__addressof(__f.get()));
	}
      };

    _Function_base() : _M_manager(nullptr) { }
 80a2808:	4803      	ldr	r0, [pc, #12]	; (80a2818 <_GLOBAL__sub_I_RGB+0x10>)
 80a280a:	2300      	movs	r3, #0
 80a280c:	6083      	str	r3, [r0, #8]
#include "spark_wiring_rgb.h"
#include "spark_wiring_interrupts.h"

#include "core_hal.h"

RGBClass RGB;
 80a280e:	4a03      	ldr	r2, [pc, #12]	; (80a281c <_GLOBAL__sub_I_RGB+0x14>)
 80a2810:	4903      	ldr	r1, [pc, #12]	; (80a2820 <_GLOBAL__sub_I_RGB+0x18>)
 80a2812:	f000 bcc1 	b.w	80a3198 <__aeabi_atexit>
 80a2816:	bf00      	nop
 80a2818:	20000be8 	.word	0x20000be8
 80a281c:	200003ac 	.word	0x200003ac
 80a2820:	080a27fd 	.word	0x080a27fd

080a2824 <_ZN8SPIClassD1Ev>:
  Mutex mutex_;
#endif

public:
  SPIClass(HAL_SPI_Interface spi);
  virtual ~SPIClass() {};
 80a2824:	4770      	bx	lr

080a2826 <_ZN8SPIClassD0Ev>:
 80a2826:	b510      	push	{r4, lr}
 80a2828:	4604      	mov	r4, r0
 80a282a:	f7fd fc36 	bl	80a009a <_ZdlPv>
 80a282e:	4620      	mov	r0, r4
 80a2830:	bd10      	pop	{r4, pc}
	...

080a2834 <_ZN8SPIClassC1E17HAL_SPI_Interface>:
  if (!info->enabled || info->default_settings)
    return particle::__SPISettings();
  return particle::__SPISettings(info->clock, info->bit_order, info->data_mode);
}

SPIClass::SPIClass(HAL_SPI_Interface spi)
 80a2834:	b570      	push	{r4, r5, r6, lr}
 80a2836:	4604      	mov	r4, r0
 80a2838:	460e      	mov	r6, r1
 80a283a:	4b07      	ldr	r3, [pc, #28]	; (80a2858 <_ZN8SPIClassC1E17HAL_SPI_Interface+0x24>)
    Mutex(os_mutex_t handle) : handle_(handle) {}

    /**
     * Creates a new mutex.
     */
    Mutex() : handle_(nullptr)
 80a283c:	2500      	movs	r5, #0
 80a283e:	6003      	str	r3, [r0, #0]
 80a2840:	f840 5f0c 	str.w	r5, [r0, #12]!
    {
        os_mutex_create(&handle_);
 80a2844:	f7ff fd20 	bl	80a2288 <os_mutex_create>
{
  _spi = spi;
  HAL_SPI_Init(_spi);
 80a2848:	4630      	mov	r0, r6
  return particle::__SPISettings(info->clock, info->bit_order, info->data_mode);
}

SPIClass::SPIClass(HAL_SPI_Interface spi)
{
  _spi = spi;
 80a284a:	7126      	strb	r6, [r4, #4]
  HAL_SPI_Init(_spi);
 80a284c:	f7ff fdb6 	bl	80a23bc <HAL_SPI_Init>
  dividerReference = SPI_CLK_SYSTEM;     // 0 indicates the system clock
 80a2850:	60a5      	str	r5, [r4, #8]
}
 80a2852:	4620      	mov	r0, r4
 80a2854:	bd70      	pop	{r4, r5, r6, pc}
 80a2856:	bf00      	nop
 80a2858:	080a4230 	.word	0x080a4230

080a285c <_ZN8SPIClass9isEnabledEv>:
  //To Do
}

bool SPIClass::isEnabled()
{
  return HAL_SPI_Is_Enabled(_spi);
 80a285c:	7900      	ldrb	r0, [r0, #4]
 80a285e:	f7ff bdb5 	b.w	80a23cc <HAL_SPI_Is_Enabled>

080a2862 <_ZN6StringD1Ev>:
	init();
	char buf[33];
	dtoa(value, decimalPlaces, buf);
        *this = buf;
}
String::~String()
 80a2862:	b510      	push	{r4, lr}
 80a2864:	4604      	mov	r4, r0
{
	free(buffer);
 80a2866:	6800      	ldr	r0, [r0, #0]
 80a2868:	f7ff fe86 	bl	80a2578 <free>
}
 80a286c:	4620      	mov	r0, r4
 80a286e:	bd10      	pop	{r4, pc}

080a2870 <_ZN6String10invalidateEv>:
	len = 0;
	flags = 0;
}

void String::invalidate(void)
{
 80a2870:	b510      	push	{r4, lr}
 80a2872:	4604      	mov	r4, r0
	if (buffer) free(buffer);
 80a2874:	6800      	ldr	r0, [r0, #0]
 80a2876:	b108      	cbz	r0, 80a287c <_ZN6String10invalidateEv+0xc>
 80a2878:	f7ff fe7e 	bl	80a2578 <free>
	buffer = NULL;
 80a287c:	2300      	movs	r3, #0
 80a287e:	6023      	str	r3, [r4, #0]
	capacity = len = 0;
 80a2880:	60a3      	str	r3, [r4, #8]
 80a2882:	6063      	str	r3, [r4, #4]
 80a2884:	bd10      	pop	{r4, pc}

080a2886 <_ZN6String12changeBufferEj>:
	}
	return 0;
}

unsigned char String::changeBuffer(unsigned int maxStrLen)
{
 80a2886:	b538      	push	{r3, r4, r5, lr}
 80a2888:	4604      	mov	r4, r0
 80a288a:	460d      	mov	r5, r1
	char *newbuffer = (char *)realloc(buffer, maxStrLen + 1);
 80a288c:	6800      	ldr	r0, [r0, #0]
 80a288e:	3101      	adds	r1, #1
 80a2890:	f7ff fe7a 	bl	80a2588 <realloc>
	if (newbuffer) {
 80a2894:	b110      	cbz	r0, 80a289c <_ZN6String12changeBufferEj+0x16>
		buffer = newbuffer;
		capacity = maxStrLen;
 80a2896:	e884 0021 	stmia.w	r4, {r0, r5}
		return 1;
 80a289a:	2001      	movs	r0, #1
	}
	return 0;
}
 80a289c:	bd38      	pop	{r3, r4, r5, pc}

080a289e <_ZN6String7reserveEj>:
	buffer = NULL;
	capacity = len = 0;
}

unsigned char String::reserve(unsigned int size)
{
 80a289e:	b510      	push	{r4, lr}
	if (buffer && capacity >= size) return 1;
 80a28a0:	6803      	ldr	r3, [r0, #0]
	buffer = NULL;
	capacity = len = 0;
}

unsigned char String::reserve(unsigned int size)
{
 80a28a2:	4604      	mov	r4, r0
	if (buffer && capacity >= size) return 1;
 80a28a4:	b113      	cbz	r3, 80a28ac <_ZN6String7reserveEj+0xe>
 80a28a6:	6843      	ldr	r3, [r0, #4]
 80a28a8:	428b      	cmp	r3, r1
 80a28aa:	d207      	bcs.n	80a28bc <_ZN6String7reserveEj+0x1e>
	if (changeBuffer(size)) {
 80a28ac:	4620      	mov	r0, r4
 80a28ae:	f7ff ffea 	bl	80a2886 <_ZN6String12changeBufferEj>
 80a28b2:	b120      	cbz	r0, 80a28be <_ZN6String7reserveEj+0x20>
		if (len == 0) buffer[0] = 0;
 80a28b4:	68a3      	ldr	r3, [r4, #8]
 80a28b6:	b90b      	cbnz	r3, 80a28bc <_ZN6String7reserveEj+0x1e>
 80a28b8:	6822      	ldr	r2, [r4, #0]
 80a28ba:	7013      	strb	r3, [r2, #0]
 80a28bc:	2001      	movs	r0, #1
		return 1;
	}
	return 0;
}
 80a28be:	bd10      	pop	{r4, pc}

080a28c0 <_ZN6String4copyEPKcj>:
/*********************************************/
/*  Copy and Move                            */
/*********************************************/

String & String::copy(const char *cstr, unsigned int length)
{
 80a28c0:	b570      	push	{r4, r5, r6, lr}
 80a28c2:	460e      	mov	r6, r1
	if (!reserve(length)) {
 80a28c4:	4611      	mov	r1, r2
/*********************************************/
/*  Copy and Move                            */
/*********************************************/

String & String::copy(const char *cstr, unsigned int length)
{
 80a28c6:	4604      	mov	r4, r0
 80a28c8:	4615      	mov	r5, r2
	if (!reserve(length)) {
 80a28ca:	f7ff ffe8 	bl	80a289e <_ZN6String7reserveEj>
 80a28ce:	b918      	cbnz	r0, 80a28d8 <_ZN6String4copyEPKcj+0x18>
		invalidate();
 80a28d0:	4620      	mov	r0, r4
 80a28d2:	f7ff ffcd 	bl	80a2870 <_ZN6String10invalidateEv>
		return *this;
 80a28d6:	e009      	b.n	80a28ec <_ZN6String4copyEPKcj+0x2c>
	}
	len = length;
	memcpy(buffer, cstr, length);
 80a28d8:	462a      	mov	r2, r5
 80a28da:	4631      	mov	r1, r6
{
	if (!reserve(length)) {
		invalidate();
		return *this;
	}
	len = length;
 80a28dc:	60a5      	str	r5, [r4, #8]
	memcpy(buffer, cstr, length);
 80a28de:	6820      	ldr	r0, [r4, #0]
 80a28e0:	f001 f8b8 	bl	80a3a54 <memcpy>
	buffer[len] = 0;
 80a28e4:	6822      	ldr	r2, [r4, #0]
 80a28e6:	68a3      	ldr	r3, [r4, #8]
 80a28e8:	2100      	movs	r1, #0
 80a28ea:	54d1      	strb	r1, [r2, r3]
	return *this;
}
 80a28ec:	4620      	mov	r0, r4
 80a28ee:	bd70      	pop	{r4, r5, r6, pc}

080a28f0 <_ZN6StringC1EPK19__FlashStringHelper>:
{
	init();
	*this = value;
}

String::String(const __FlashStringHelper *pstr)
 80a28f0:	b538      	push	{r3, r4, r5, lr}
/*  Memory Management                        */
/*********************************************/

inline void String::init(void)
{
	buffer = NULL;
 80a28f2:	2300      	movs	r3, #0
{
	init();
	*this = value;
}

String::String(const __FlashStringHelper *pstr)
 80a28f4:	4604      	mov	r4, r0
/*  Memory Management                        */
/*********************************************/

inline void String::init(void)
{
	buffer = NULL;
 80a28f6:	6003      	str	r3, [r0, #0]
	capacity = 0;
 80a28f8:	6043      	str	r3, [r0, #4]
	len = 0;
 80a28fa:	6083      	str	r3, [r0, #8]
	flags = 0;
 80a28fc:	7303      	strb	r3, [r0, #12]

String::String(const __FlashStringHelper *pstr)
{
	init();
	const char* cstr = reinterpret_cast<const char*>(pstr);
	if (cstr) copy(cstr, strlen(cstr));
 80a28fe:	460d      	mov	r5, r1
 80a2900:	b139      	cbz	r1, 80a2912 <_ZN6StringC1EPK19__FlashStringHelper+0x22>
 80a2902:	4608      	mov	r0, r1
 80a2904:	f001 f924 	bl	80a3b50 <strlen>
 80a2908:	4629      	mov	r1, r5
 80a290a:	4602      	mov	r2, r0
 80a290c:	4620      	mov	r0, r4
 80a290e:	f7ff ffd7 	bl	80a28c0 <_ZN6String4copyEPKcj>
}
 80a2912:	4620      	mov	r0, r4
 80a2914:	bd38      	pop	{r3, r4, r5, pc}

080a2916 <_ZN6StringaSERKS_>:
}
#endif

String & String::operator = (const String &rhs)
{
	if (this == &rhs) return *this;
 80a2916:	4288      	cmp	r0, r1
	rhs.len = 0;
}
#endif

String & String::operator = (const String &rhs)
{
 80a2918:	b510      	push	{r4, lr}
 80a291a:	460b      	mov	r3, r1
 80a291c:	4604      	mov	r4, r0
	if (this == &rhs) return *this;
 80a291e:	d007      	beq.n	80a2930 <_ZN6StringaSERKS_+0x1a>

	if (rhs.buffer) copy(rhs.buffer, rhs.len);
 80a2920:	6809      	ldr	r1, [r1, #0]
 80a2922:	b119      	cbz	r1, 80a292c <_ZN6StringaSERKS_+0x16>
 80a2924:	689a      	ldr	r2, [r3, #8]
 80a2926:	f7ff ffcb 	bl	80a28c0 <_ZN6String4copyEPKcj>
 80a292a:	e001      	b.n	80a2930 <_ZN6StringaSERKS_+0x1a>
	else invalidate();
 80a292c:	f7ff ffa0 	bl	80a2870 <_ZN6String10invalidateEv>

	return *this;
}
 80a2930:	4620      	mov	r0, r4
 80a2932:	bd10      	pop	{r4, pc}

080a2934 <_ZN6StringC1ERKS_>:
{
	init();
	if (cstr) copy(cstr, length);
}

String::String(const String &value)
 80a2934:	b510      	push	{r4, lr}
 80a2936:	4604      	mov	r4, r0
/*  Memory Management                        */
/*********************************************/

inline void String::init(void)
{
	buffer = NULL;
 80a2938:	2300      	movs	r3, #0
 80a293a:	6003      	str	r3, [r0, #0]
	capacity = 0;
 80a293c:	6043      	str	r3, [r0, #4]
	len = 0;
 80a293e:	6083      	str	r3, [r0, #8]
	flags = 0;
 80a2940:	7303      	strb	r3, [r0, #12]
}

String::String(const String &value)
{
	init();
	*this = value;
 80a2942:	f7ff ffe8 	bl	80a2916 <_ZN6StringaSERKS_>
}
 80a2946:	4620      	mov	r0, r4
 80a2948:	bd10      	pop	{r4, pc}

080a294a <_ZN6StringaSEPKc>:
	return *this;
}
#endif

String & String::operator = (const char *cstr)
{
 80a294a:	b538      	push	{r3, r4, r5, lr}
 80a294c:	4605      	mov	r5, r0
	if (cstr) copy(cstr, strlen(cstr));
 80a294e:	460c      	mov	r4, r1
 80a2950:	b141      	cbz	r1, 80a2964 <_ZN6StringaSEPKc+0x1a>
 80a2952:	4608      	mov	r0, r1
 80a2954:	f001 f8fc 	bl	80a3b50 <strlen>
 80a2958:	4621      	mov	r1, r4
 80a295a:	4602      	mov	r2, r0
 80a295c:	4628      	mov	r0, r5
 80a295e:	f7ff ffaf 	bl	80a28c0 <_ZN6String4copyEPKcj>
 80a2962:	e001      	b.n	80a2968 <_ZN6StringaSEPKc+0x1e>
	else invalidate();
 80a2964:	f7ff ff84 	bl	80a2870 <_ZN6String10invalidateEv>

	return *this;
}
 80a2968:	4628      	mov	r0, r5
 80a296a:	bd38      	pop	{r3, r4, r5, pc}

080a296c <_ZN6StringC1Eih>:
	char buf[9];
	utoa(value, buf, base);
	*this = buf;
}

String::String(int value, unsigned char base)
 80a296c:	b510      	push	{r4, lr}
 80a296e:	4604      	mov	r4, r0
/*  Memory Management                        */
/*********************************************/

inline void String::init(void)
{
	buffer = NULL;
 80a2970:	2300      	movs	r3, #0
	char buf[9];
	utoa(value, buf, base);
	*this = buf;
}

String::String(int value, unsigned char base)
 80a2972:	b08a      	sub	sp, #40	; 0x28
/*  Memory Management                        */
/*********************************************/

inline void String::init(void)
{
	buffer = NULL;
 80a2974:	6023      	str	r3, [r4, #0]
	capacity = 0;
 80a2976:	6063      	str	r3, [r4, #4]
	len = 0;
 80a2978:	60a3      	str	r3, [r4, #8]
	flags = 0;
 80a297a:	7323      	strb	r3, [r4, #12]
	char buf[9];
	utoa(value, buf, base);
	*this = buf;
}

String::String(int value, unsigned char base)
 80a297c:	4608      	mov	r0, r1
{
	init();
	char buf[34];
	itoa(value, buf, base);
 80a297e:	a901      	add	r1, sp, #4
 80a2980:	f000 faa1 	bl	80a2ec6 <itoa>
	*this = buf;
 80a2984:	a901      	add	r1, sp, #4
 80a2986:	4620      	mov	r0, r4
 80a2988:	f7ff ffdf 	bl	80a294a <_ZN6StringaSEPKc>
}
 80a298c:	4620      	mov	r0, r4
 80a298e:	b00a      	add	sp, #40	; 0x28
 80a2990:	bd10      	pop	{r4, pc}

080a2992 <_ZN6String6concatEPKcj>:
{
	return concat(s.buffer, s.len);
}

unsigned char String::concat(const char *cstr, unsigned int length)
{
 80a2992:	b570      	push	{r4, r5, r6, lr}
 80a2994:	4604      	mov	r4, r0
	unsigned int newlen = len + length;
	if (!cstr) return 0;
 80a2996:	460e      	mov	r6, r1
 80a2998:	b909      	cbnz	r1, 80a299e <_ZN6String6concatEPKcj+0xc>
 80a299a:	2000      	movs	r0, #0
 80a299c:	bd70      	pop	{r4, r5, r6, pc}
	if (length == 0) return 1;
 80a299e:	b16a      	cbz	r2, 80a29bc <_ZN6String6concatEPKcj+0x2a>
	return concat(s.buffer, s.len);
}

unsigned char String::concat(const char *cstr, unsigned int length)
{
	unsigned int newlen = len + length;
 80a29a0:	6883      	ldr	r3, [r0, #8]
 80a29a2:	18d5      	adds	r5, r2, r3
	if (!cstr) return 0;
	if (length == 0) return 1;
	if (!reserve(newlen)) return 0;
 80a29a4:	4629      	mov	r1, r5
 80a29a6:	f7ff ff7a 	bl	80a289e <_ZN6String7reserveEj>
 80a29aa:	2800      	cmp	r0, #0
 80a29ac:	d0f5      	beq.n	80a299a <_ZN6String6concatEPKcj+0x8>
	strcpy(buffer + len, cstr);
 80a29ae:	6820      	ldr	r0, [r4, #0]
 80a29b0:	68a3      	ldr	r3, [r4, #8]
 80a29b2:	4631      	mov	r1, r6
 80a29b4:	4418      	add	r0, r3
 80a29b6:	f001 f8c3 	bl	80a3b40 <strcpy>
	len = newlen;
 80a29ba:	60a5      	str	r5, [r4, #8]

unsigned char String::concat(const char *cstr, unsigned int length)
{
	unsigned int newlen = len + length;
	if (!cstr) return 0;
	if (length == 0) return 1;
 80a29bc:	2001      	movs	r0, #1
	if (!reserve(newlen)) return 0;
	strcpy(buffer + len, cstr);
	len = newlen;
	return 1;
}
 80a29be:	bd70      	pop	{r4, r5, r6, pc}

080a29c0 <_ZN6String6concatERKS_>:
/*  concat                                   */
/*********************************************/

unsigned char String::concat(const String &s)
{
	return concat(s.buffer, s.len);
 80a29c0:	688a      	ldr	r2, [r1, #8]
 80a29c2:	6809      	ldr	r1, [r1, #0]
 80a29c4:	f7ff bfe5 	b.w	80a2992 <_ZN6String6concatEPKcj>

080a29c8 <_ZN6String6concatEPKc>:
	len = newlen;
	return 1;
}

unsigned char String::concat(const char *cstr)
{
 80a29c8:	b538      	push	{r3, r4, r5, lr}
 80a29ca:	4605      	mov	r5, r0
	if (!cstr) return 0;
 80a29cc:	460c      	mov	r4, r1
	return concat(cstr, strlen(cstr));
}
 80a29ce:	4608      	mov	r0, r1
	return 1;
}

unsigned char String::concat(const char *cstr)
{
	if (!cstr) return 0;
 80a29d0:	b141      	cbz	r1, 80a29e4 <_ZN6String6concatEPKc+0x1c>
	return concat(cstr, strlen(cstr));
 80a29d2:	f001 f8bd 	bl	80a3b50 <strlen>
 80a29d6:	4621      	mov	r1, r4
 80a29d8:	4602      	mov	r2, r0
 80a29da:	4628      	mov	r0, r5
}
 80a29dc:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
}

unsigned char String::concat(const char *cstr)
{
	if (!cstr) return 0;
	return concat(cstr, strlen(cstr));
 80a29e0:	f7ff bfd7 	b.w	80a2992 <_ZN6String6concatEPKcj>
}
 80a29e4:	bd38      	pop	{r3, r4, r5, pc}

080a29e6 <_ZplRK15StringSumHelperRK6String>:
/*********************************************/
/*  Concatenate                              */
/*********************************************/

StringSumHelper & operator + (const StringSumHelper &lhs, const String &rhs)
{
 80a29e6:	b510      	push	{r4, lr}
	StringSumHelper &a = const_cast<StringSumHelper&>(lhs);
	if (!a.concat(rhs.buffer, rhs.len)) a.invalidate();
 80a29e8:	688a      	ldr	r2, [r1, #8]
 80a29ea:	6809      	ldr	r1, [r1, #0]
/*********************************************/
/*  Concatenate                              */
/*********************************************/

StringSumHelper & operator + (const StringSumHelper &lhs, const String &rhs)
{
 80a29ec:	4604      	mov	r4, r0
	StringSumHelper &a = const_cast<StringSumHelper&>(lhs);
	if (!a.concat(rhs.buffer, rhs.len)) a.invalidate();
 80a29ee:	f7ff ffd0 	bl	80a2992 <_ZN6String6concatEPKcj>
 80a29f2:	b910      	cbnz	r0, 80a29fa <_ZplRK15StringSumHelperRK6String+0x14>
 80a29f4:	4620      	mov	r0, r4
 80a29f6:	f7ff ff3b 	bl	80a2870 <_ZN6String10invalidateEv>
	return a;
}
 80a29fa:	4620      	mov	r0, r4
 80a29fc:	bd10      	pop	{r4, pc}

080a29fe <_ZNK6String10startsWithERKS_j>:
	if (len < s2.len) return 0;
	return startsWith(s2, 0);
}

unsigned char String::startsWith( const String &s2, unsigned int offset ) const
{
 80a29fe:	b510      	push	{r4, lr}
 80a2a00:	4614      	mov	r4, r2
	if (offset > len - s2.len || !buffer || !s2.buffer) return 0;
 80a2a02:	6883      	ldr	r3, [r0, #8]
 80a2a04:	688a      	ldr	r2, [r1, #8]
 80a2a06:	1a9b      	subs	r3, r3, r2
 80a2a08:	42a3      	cmp	r3, r4
 80a2a0a:	d30a      	bcc.n	80a2a22 <_ZNK6String10startsWithERKS_j+0x24>
 80a2a0c:	6800      	ldr	r0, [r0, #0]
 80a2a0e:	b158      	cbz	r0, 80a2a28 <_ZNK6String10startsWithERKS_j+0x2a>
 80a2a10:	6809      	ldr	r1, [r1, #0]
 80a2a12:	b141      	cbz	r1, 80a2a26 <_ZNK6String10startsWithERKS_j+0x28>
	return strncmp( &buffer[offset], s2.buffer, s2.len ) == 0;
 80a2a14:	4420      	add	r0, r4
 80a2a16:	f001 f8a3 	bl	80a3b60 <strncmp>
 80a2a1a:	fab0 f080 	clz	r0, r0
 80a2a1e:	0940      	lsrs	r0, r0, #5
 80a2a20:	bd10      	pop	{r4, pc}
	return startsWith(s2, 0);
}

unsigned char String::startsWith( const String &s2, unsigned int offset ) const
{
	if (offset > len - s2.len || !buffer || !s2.buffer) return 0;
 80a2a22:	2000      	movs	r0, #0
 80a2a24:	bd10      	pop	{r4, pc}
 80a2a26:	4608      	mov	r0, r1
	return strncmp( &buffer[offset], s2.buffer, s2.len ) == 0;
}
 80a2a28:	bd10      	pop	{r4, pc}

080a2a2a <_ZNK6String10startsWithERKS_>:
	return 1;
}

unsigned char String::startsWith( const String &s2 ) const
{
	if (len < s2.len) return 0;
 80a2a2a:	6882      	ldr	r2, [r0, #8]
 80a2a2c:	688b      	ldr	r3, [r1, #8]
 80a2a2e:	429a      	cmp	r2, r3
 80a2a30:	d302      	bcc.n	80a2a38 <_ZNK6String10startsWithERKS_+0xe>
	return startsWith(s2, 0);
 80a2a32:	2200      	movs	r2, #0
 80a2a34:	f7ff bfe3 	b.w	80a29fe <_ZNK6String10startsWithERKS_j>
}
 80a2a38:	2000      	movs	r0, #0
 80a2a3a:	4770      	bx	lr

080a2a3c <_ZNK6String8getBytesEPhjj>:
	if (index >= len || !buffer) return 0;
	return buffer[index];
}

void String::getBytes(unsigned char *buf, unsigned int bufsize, unsigned int index) const
{
 80a2a3c:	b570      	push	{r4, r5, r6, lr}
 80a2a3e:	460e      	mov	r6, r1
	if (!bufsize || !buf) return;
 80a2a40:	b19a      	cbz	r2, 80a2a6a <_ZNK6String8getBytesEPhjj+0x2e>
 80a2a42:	b191      	cbz	r1, 80a2a6a <_ZNK6String8getBytesEPhjj+0x2e>
	if (index >= len) {
 80a2a44:	6885      	ldr	r5, [r0, #8]
 80a2a46:	429d      	cmp	r5, r3
 80a2a48:	d802      	bhi.n	80a2a50 <_ZNK6String8getBytesEPhjj+0x14>
		buf[0] = 0;
 80a2a4a:	2300      	movs	r3, #0
 80a2a4c:	700b      	strb	r3, [r1, #0]
		return;
 80a2a4e:	bd70      	pop	{r4, r5, r6, pc}
	}
	unsigned int n = bufsize - 1;
 80a2a50:	1e54      	subs	r4, r2, #1
	if (n > len - index) n = len - index;
 80a2a52:	1aed      	subs	r5, r5, r3
 80a2a54:	42ac      	cmp	r4, r5
 80a2a56:	bf28      	it	cs
 80a2a58:	462c      	movcs	r4, r5
	strncpy((char *)buf, buffer + index, n);
 80a2a5a:	6801      	ldr	r1, [r0, #0]
 80a2a5c:	4622      	mov	r2, r4
 80a2a5e:	4419      	add	r1, r3
 80a2a60:	4630      	mov	r0, r6
 80a2a62:	f001 f892 	bl	80a3b8a <strncpy>
	buf[n] = 0;
 80a2a66:	2300      	movs	r3, #0
 80a2a68:	5533      	strb	r3, [r6, r4]
 80a2a6a:	bd70      	pop	{r4, r5, r6, pc}

080a2a6c <_ZNK6String9substringEjj>:
{
	return substring(left, len);
}

String String::substring(unsigned int left, unsigned int right) const
{
 80a2a6c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80a2a70:	461c      	mov	r4, r3
	if (left > right) {
 80a2a72:	429a      	cmp	r2, r3
 80a2a74:	bf88      	it	hi
 80a2a76:	4613      	movhi	r3, r2
{
	return substring(left, len);
}

String String::substring(unsigned int left, unsigned int right) const
{
 80a2a78:	460e      	mov	r6, r1
 80a2a7a:	4615      	mov	r5, r2
	if (left > right) {
 80a2a7c:	bf88      	it	hi
 80a2a7e:	4625      	movhi	r5, r4
		unsigned int temp = right;
		right = left;
		left = temp;
	}
	String out;
 80a2a80:	490d      	ldr	r1, [pc, #52]	; (80a2ab8 <_ZNK6String9substringEjj+0x4c>)
	return substring(left, len);
}

String String::substring(unsigned int left, unsigned int right) const
{
	if (left > right) {
 80a2a82:	bf88      	it	hi
 80a2a84:	461c      	movhi	r4, r3
{
	return substring(left, len);
}

String String::substring(unsigned int left, unsigned int right) const
{
 80a2a86:	4607      	mov	r7, r0
	if (left > right) {
		unsigned int temp = right;
		right = left;
		left = temp;
	}
	String out;
 80a2a88:	f7ff ff32 	bl	80a28f0 <_ZN6StringC1EPK19__FlashStringHelper>
	if (left > len) return out;
 80a2a8c:	68b1      	ldr	r1, [r6, #8]
 80a2a8e:	428d      	cmp	r5, r1
 80a2a90:	d80f      	bhi.n	80a2ab2 <_ZNK6String9substringEjj+0x46>
 80a2a92:	428c      	cmp	r4, r1
 80a2a94:	bf28      	it	cs
 80a2a96:	460c      	movcs	r4, r1
	if (right > len) right = len;
	char temp = buffer[right];  // save the replaced character
 80a2a98:	6833      	ldr	r3, [r6, #0]
	buffer[right] = '\0';
 80a2a9a:	2200      	movs	r2, #0
		left = temp;
	}
	String out;
	if (left > len) return out;
	if (right > len) right = len;
	char temp = buffer[right];  // save the replaced character
 80a2a9c:	f813 8004 	ldrb.w	r8, [r3, r4]
	buffer[right] = '\0';
 80a2aa0:	551a      	strb	r2, [r3, r4]
	out = buffer + left;  // pointer arithmetic
 80a2aa2:	6831      	ldr	r1, [r6, #0]
 80a2aa4:	4638      	mov	r0, r7
 80a2aa6:	4429      	add	r1, r5
 80a2aa8:	f7ff ff4f 	bl	80a294a <_ZN6StringaSEPKc>
	buffer[right] = temp;  //restore character
 80a2aac:	6833      	ldr	r3, [r6, #0]
 80a2aae:	f803 8004 	strb.w	r8, [r3, r4]
	return out;
}
 80a2ab2:	4638      	mov	r0, r7
 80a2ab4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80a2ab8:	080a415a 	.word	0x080a415a

080a2abc <_ZNK6String9substringEj>:
	}
	return found;
}

String String::substring( unsigned int left ) const
{
 80a2abc:	b510      	push	{r4, lr}
 80a2abe:	4604      	mov	r4, r0
	return substring(left, len);
 80a2ac0:	688b      	ldr	r3, [r1, #8]
 80a2ac2:	f7ff ffd3 	bl	80a2a6c <_ZNK6String9substringEjj>
}
 80a2ac6:	4620      	mov	r0, r4
 80a2ac8:	bd10      	pop	{r4, pc}

080a2aca <_ZNK6String5toIntEv>:
/*  Parsing / Conversion                     */
/*********************************************/

long String::toInt(void) const
{
	if (buffer) return atol(buffer);
 80a2aca:	6800      	ldr	r0, [r0, #0]
 80a2acc:	b108      	cbz	r0, 80a2ad2 <_ZNK6String5toIntEv+0x8>
 80a2ace:	f000 bfaf 	b.w	80a3a30 <atol>
	return 0;
}
 80a2ad2:	4770      	bx	lr

080a2ad4 <_ZN11SleepResultC1EiPKtj>:
bool SystemClass::enableFeature(const WiFiTesterFeature feature) {
    WiFiTester::init();
    return true;
}

SleepResult::SleepResult(int ret, const pin_t* pins, size_t pinsSize) {
 80a2ad4:	b530      	push	{r4, r5, lr}
 80a2ad6:	f64f 759c 	movw	r5, #65436	; 0xff9c
 80a2ada:	8045      	strh	r5, [r0, #2]
 80a2adc:	f64f 75ff 	movw	r5, #65535	; 0xffff
 80a2ae0:	2400      	movs	r4, #0
    if (ret > 0) {
 80a2ae2:	2900      	cmp	r1, #0
bool SystemClass::enableFeature(const WiFiTesterFeature feature) {
    WiFiTester::init();
    return true;
}

SleepResult::SleepResult(int ret, const pin_t* pins, size_t pinsSize) {
 80a2ae4:	7004      	strb	r4, [r0, #0]
 80a2ae6:	8085      	strh	r5, [r0, #4]
    if (ret > 0) {
 80a2ae8:	dd09      	ble.n	80a2afe <_ZN11SleepResultC1EiPKtj+0x2a>
        // pin
        --ret;
        if ((size_t)ret < pinsSize) {
 80a2aea:	3901      	subs	r1, #1
 80a2aec:	4299      	cmp	r1, r3
 80a2aee:	d20a      	bcs.n	80a2b06 <_ZN11SleepResultC1EiPKtj+0x32>
            pin_ = pins[ret];
 80a2af0:	f832 3011 	ldrh.w	r3, [r2, r1, lsl #1]
            reason_ = WAKEUP_REASON_PIN;
            err_ = SYSTEM_ERROR_NONE;
 80a2af4:	8044      	strh	r4, [r0, #2]
SleepResult::SleepResult(int ret, const pin_t* pins, size_t pinsSize) {
    if (ret > 0) {
        // pin
        --ret;
        if ((size_t)ret < pinsSize) {
            pin_ = pins[ret];
 80a2af6:	8083      	strh	r3, [r0, #4]
            reason_ = WAKEUP_REASON_PIN;
 80a2af8:	2301      	movs	r3, #1
 80a2afa:	7003      	strb	r3, [r0, #0]
 80a2afc:	bd30      	pop	{r4, r5, pc}
            err_ = SYSTEM_ERROR_NONE;
        }
    } else if (ret == 0) {
        reason_ = WAKEUP_REASON_RTC;
 80a2afe:	bf04      	itt	eq
 80a2b00:	2302      	moveq	r3, #2
 80a2b02:	7003      	strbeq	r3, [r0, #0]
        err_ = SYSTEM_ERROR_NONE;
    } else {
        err_ = static_cast<system_error_t>(ret);
 80a2b04:	8041      	strh	r1, [r0, #2]
    }
}
 80a2b06:	bd30      	pop	{r4, r5, pc}

080a2b08 <_ZN11SystemClass12sleepPinImplEPKtjPK13InterruptModejlN8particle5FlagsI19SleepOptionFlagTypemEE>:
    system_sleep(sleepMode, seconds, flags.value(), NULL);
    System.sleepResult_ = SleepResult();
    return System.sleepResult_;
}

SleepResult SystemClass::sleepPinImpl(const uint16_t* pins, size_t pins_count, const InterruptMode* modes, size_t modes_count, long seconds, SleepOptionFlags flags) {
 80a2b08:	b570      	push	{r4, r5, r6, lr}
 80a2b0a:	460d      	mov	r5, r1
 80a2b0c:	4616      	mov	r6, r2
 80a2b0e:	b086      	sub	sp, #24
 80a2b10:	461a      	mov	r2, r3
    int ret = system_sleep_pins(pins, pins_count, modes, modes_count, seconds, flags.value(), nullptr);
 80a2b12:	2300      	movs	r3, #0
 80a2b14:	9302      	str	r3, [sp, #8]
 80a2b16:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    system_sleep(sleepMode, seconds, flags.value(), NULL);
    System.sleepResult_ = SleepResult();
    return System.sleepResult_;
}

SleepResult SystemClass::sleepPinImpl(const uint16_t* pins, size_t pins_count, const InterruptMode* modes, size_t modes_count, long seconds, SleepOptionFlags flags) {
 80a2b18:	4604      	mov	r4, r0
    int ret = system_sleep_pins(pins, pins_count, modes, modes_count, seconds, flags.value(), nullptr);
 80a2b1a:	9301      	str	r3, [sp, #4]
 80a2b1c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 80a2b1e:	4631      	mov	r1, r6
 80a2b20:	9300      	str	r3, [sp, #0]
 80a2b22:	4628      	mov	r0, r5
 80a2b24:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80a2b26:	f7ff fcf5 	bl	80a2514 <system_sleep_pins>
    System.sleepResult_ = SleepResult(ret, pins, pins_count);
 80a2b2a:	4633      	mov	r3, r6
 80a2b2c:	462a      	mov	r2, r5
 80a2b2e:	4601      	mov	r1, r0
 80a2b30:	a804      	add	r0, sp, #16
 80a2b32:	f7ff ffcf 	bl	80a2ad4 <_ZN11SleepResultC1EiPKtj>
 80a2b36:	4b06      	ldr	r3, [pc, #24]	; (80a2b50 <_ZN11SystemClass12sleepPinImplEPKtjPK13InterruptModejlN8particle5FlagsI19SleepOptionFlagTypemEE+0x48>)
 80a2b38:	9804      	ldr	r0, [sp, #16]
 80a2b3a:	f8bd 2014 	ldrh.w	r2, [sp, #20]
 80a2b3e:	6018      	str	r0, [r3, #0]
    return System.sleepResult_;
}
 80a2b40:	4620      	mov	r0, r4
    return System.sleepResult_;
}

SleepResult SystemClass::sleepPinImpl(const uint16_t* pins, size_t pins_count, const InterruptMode* modes, size_t modes_count, long seconds, SleepOptionFlags flags) {
    int ret = system_sleep_pins(pins, pins_count, modes, modes_count, seconds, flags.value(), nullptr);
    System.sleepResult_ = SleepResult(ret, pins, pins_count);
 80a2b42:	809a      	strh	r2, [r3, #4]
    return System.sleepResult_;
 80a2b44:	681a      	ldr	r2, [r3, #0]
 80a2b46:	889b      	ldrh	r3, [r3, #4]
 80a2b48:	6022      	str	r2, [r4, #0]
 80a2b4a:	80a3      	strh	r3, [r4, #4]
}
 80a2b4c:	b006      	add	sp, #24
 80a2b4e:	bd70      	pop	{r4, r5, r6, pc}
 80a2b50:	20000bf8 	.word	0x20000bf8

080a2b54 <_GLOBAL__sub_I_System>:
    WAKEUP_REASON_RTC = 2,
    WAKEUP_REASON_PIN_OR_RTC = 3
};

struct SleepResult {
    SleepResult() {}
 80a2b54:	f64f 739c 	movw	r3, #65436	; 0xff9c
    return wokenUpByRtc();
}

system_error_t SleepResult::error() const {
    return err_;
}
 80a2b58:	b537      	push	{r0, r1, r2, r4, r5, lr}
 80a2b5a:	4c0d      	ldr	r4, [pc, #52]	; (80a2b90 <_GLOBAL__sub_I_System+0x3c>)
 80a2b5c:	2500      	movs	r5, #0
 80a2b5e:	8063      	strh	r3, [r4, #2]
 80a2b60:	f64f 73ff 	movw	r3, #65535	; 0xffff

class SystemClass {
public:

    SystemClass(System_Mode_TypeDef mode = DEFAULT) {
        set_system_mode(mode);
 80a2b64:	4628      	mov	r0, r5
    WAKEUP_REASON_RTC = 2,
    WAKEUP_REASON_PIN_OR_RTC = 3
};

struct SleepResult {
    SleepResult() {}
 80a2b66:	80a3      	strh	r3, [r4, #4]
 80a2b68:	7025      	strb	r5, [r4, #0]

class SystemClass {
public:

    SystemClass(System_Mode_TypeDef mode = DEFAULT) {
        set_system_mode(mode);
 80a2b6a:	f7ff fcaf 	bl	80a24cc <set_system_mode>
        return get_flag(flag) != 0;
    }

    inline int resetReason() const
    {
        int reason = RESET_REASON_NONE;
 80a2b6e:	a802      	add	r0, sp, #8
 80a2b70:	f840 5d04 	str.w	r5, [r0, #-4]!
        HAL_Core_Get_Last_Reset_Info(&reason, nullptr, nullptr);
 80a2b74:	462a      	mov	r2, r5
 80a2b76:	4629      	mov	r1, r5
 80a2b78:	f7ff fb8e 	bl	80a2298 <HAL_Core_Get_Last_Reset_Info>
        return reason;
 80a2b7c:	9b01      	ldr	r3, [sp, #4]
class SystemClass {
public:

    SystemClass(System_Mode_TypeDef mode = DEFAULT) {
        set_system_mode(mode);
        if (resetReason() == RESET_REASON_POWER_MANAGEMENT) {
 80a2b7e:	2b1e      	cmp	r3, #30
 80a2b80:	d104      	bne.n	80a2b8c <_GLOBAL__sub_I_System+0x38>
            // Woken up from standby mode
            sleepResult_ = SleepResult(WAKEUP_REASON_PIN_OR_RTC, SYSTEM_ERROR_NONE, WKP);
 80a2b82:	2303      	movs	r3, #3
 80a2b84:	7023      	strb	r3, [r4, #0]
 80a2b86:	2311      	movs	r3, #17
 80a2b88:	8065      	strh	r5, [r4, #2]
 80a2b8a:	80a3      	strh	r3, [r4, #4]
 80a2b8c:	b003      	add	sp, #12
 80a2b8e:	bd30      	pop	{r4, r5, pc}
 80a2b90:	20000bf8 	.word	0x20000bf8

080a2b94 <_ZN9TimeClass4zoneEf>:
	return HAL_RTC_Get_UnixTime()+time_zone_cache+dst_current_cache;
}

/* set the time zone (+/-) offset from GMT */
void TimeClass::zone(float GMT_Offset)
{
 80a2b94:	b510      	push	{r4, lr}
	if(GMT_Offset < -12 || GMT_Offset > 14)
 80a2b96:	4909      	ldr	r1, [pc, #36]	; (80a2bbc <_ZN9TimeClass4zoneEf+0x28>)
	return HAL_RTC_Get_UnixTime()+time_zone_cache+dst_current_cache;
}

/* set the time zone (+/-) offset from GMT */
void TimeClass::zone(float GMT_Offset)
{
 80a2b98:	4604      	mov	r4, r0
	if(GMT_Offset < -12 || GMT_Offset > 14)
 80a2b9a:	f000 fef7 	bl	80a398c <__aeabi_fcmplt>
 80a2b9e:	b960      	cbnz	r0, 80a2bba <_ZN9TimeClass4zoneEf+0x26>
 80a2ba0:	4907      	ldr	r1, [pc, #28]	; (80a2bc0 <_ZN9TimeClass4zoneEf+0x2c>)
 80a2ba2:	4620      	mov	r0, r4
 80a2ba4:	f000 ff10 	bl	80a39c8 <__aeabi_fcmpgt>
 80a2ba8:	b938      	cbnz	r0, 80a2bba <_ZN9TimeClass4zoneEf+0x26>
	{
		return;
	}
	time_zone_cache = GMT_Offset * 3600;
 80a2baa:	4906      	ldr	r1, [pc, #24]	; (80a2bc4 <_ZN9TimeClass4zoneEf+0x30>)
 80a2bac:	4620      	mov	r0, r4
 80a2bae:	f000 fd4f 	bl	80a3650 <__aeabi_fmul>
 80a2bb2:	f000 ff13 	bl	80a39dc <__aeabi_f2iz>
 80a2bb6:	4b04      	ldr	r3, [pc, #16]	; (80a2bc8 <_ZN9TimeClass4zoneEf+0x34>)
 80a2bb8:	6018      	str	r0, [r3, #0]
 80a2bba:	bd10      	pop	{r4, pc}
 80a2bbc:	c1400000 	.word	0xc1400000
 80a2bc0:	41600000 	.word	0x41600000
 80a2bc4:	45610000 	.word	0x45610000
 80a2bc8:	20000c04 	.word	0x20000c04

080a2bcc <_GLOBAL__sub_I_TIME_FORMAT_DEFAULT>:
            calendar_time_cache = Convert_UnixTime_To_CalendarTime(unix_time);
            unix_time_cache = unix_time;
    }
}

const char* TimeClass::format_spec = TIME_FORMAT_DEFAULT;
 80a2bcc:	4b02      	ldr	r3, [pc, #8]	; (80a2bd8 <_GLOBAL__sub_I_TIME_FORMAT_DEFAULT+0xc>)
 80a2bce:	681a      	ldr	r2, [r3, #0]
 80a2bd0:	4b02      	ldr	r3, [pc, #8]	; (80a2bdc <_GLOBAL__sub_I_TIME_FORMAT_DEFAULT+0x10>)
 80a2bd2:	601a      	str	r2, [r3, #0]
 80a2bd4:	4770      	bx	lr
 80a2bd6:	bf00      	nop
 80a2bd8:	20000340 	.word	0x20000340
 80a2bdc:	20000c00 	.word	0x20000c00

080a2be0 <_ZN11USARTSerialD1Ev>:
private:
  HAL_USART_Serial _serial;
  bool _blocking;
public:
  USARTSerial(HAL_USART_Serial serial, Ring_Buffer *rx_buffer, Ring_Buffer *tx_buffer);
  virtual ~USARTSerial() {};
 80a2be0:	4770      	bx	lr

080a2be2 <_ZN11USARTSerial14blockOnOverrunEb>:
    HAL_USART_Half_Duplex(_serial, Enable);
}

void USARTSerial::blockOnOverrun(bool block)
{
  _blocking = block;
 80a2be2:	7441      	strb	r1, [r0, #17]
 80a2be4:	4770      	bx	lr

080a2be6 <_ZN11USARTSerial17availableForWriteEv>:
}


int USARTSerial::availableForWrite(void)
{
  return HAL_USART_Available_Data_For_Write(_serial);
 80a2be6:	7c00      	ldrb	r0, [r0, #16]
 80a2be8:	f7ff bc30 	b.w	80a244c <HAL_USART_Available_Data_For_Write>

080a2bec <_ZN11USARTSerial9availableEv>:
}

int USARTSerial::available(void)
{
  return HAL_USART_Available_Data(_serial);
 80a2bec:	7c00      	ldrb	r0, [r0, #16]
 80a2bee:	f7ff bc05 	b.w	80a23fc <HAL_USART_Available_Data>

080a2bf2 <_ZN11USARTSerial4peekEv>:
}

int USARTSerial::peek(void)
{
  return HAL_USART_Peek_Data(_serial);
 80a2bf2:	7c00      	ldrb	r0, [r0, #16]
 80a2bf4:	f7ff bc12 	b.w	80a241c <HAL_USART_Peek_Data>

080a2bf8 <_ZN11USARTSerial4readEv>:
}

int USARTSerial::read(void)
{
  return HAL_USART_Read_Data(_serial);
 80a2bf8:	7c00      	ldrb	r0, [r0, #16]
 80a2bfa:	f7ff bc07 	b.w	80a240c <HAL_USART_Read_Data>

080a2bfe <_ZN11USARTSerial5flushEv>:
}

void USARTSerial::flush()
{
  HAL_USART_Flush_Data(_serial);
 80a2bfe:	7c00      	ldrb	r0, [r0, #16]
 80a2c00:	f7ff bc14 	b.w	80a242c <HAL_USART_Flush_Data>

080a2c04 <_ZN11USARTSerialD0Ev>:
 80a2c04:	b510      	push	{r4, lr}
 80a2c06:	4604      	mov	r4, r0
 80a2c08:	f7fd fa47 	bl	80a009a <_ZdlPv>
 80a2c0c:	4620      	mov	r0, r4
 80a2c0e:	bd10      	pop	{r4, pc}

080a2c10 <_ZN11USARTSerial5writeEh>:
}

size_t USARTSerial::write(uint8_t c)
{
 80a2c10:	b570      	push	{r4, r5, r6, lr}
  // attempt a write if blocking, or for non-blocking if there is room.
  if (_blocking || HAL_USART_Available_Data_For_Write(_serial) > 0) {
 80a2c12:	7c45      	ldrb	r5, [r0, #17]
{
  HAL_USART_Flush_Data(_serial);
}

size_t USARTSerial::write(uint8_t c)
{
 80a2c14:	4604      	mov	r4, r0
 80a2c16:	460e      	mov	r6, r1
  // attempt a write if blocking, or for non-blocking if there is room.
  if (_blocking || HAL_USART_Available_Data_For_Write(_serial) > 0) {
 80a2c18:	b925      	cbnz	r5, 80a2c24 <_ZN11USARTSerial5writeEh+0x14>
 80a2c1a:	7c00      	ldrb	r0, [r0, #16]
 80a2c1c:	f7ff fc16 	bl	80a244c <HAL_USART_Available_Data_For_Write>
 80a2c20:	2800      	cmp	r0, #0
 80a2c22:	dd05      	ble.n	80a2c30 <_ZN11USARTSerial5writeEh+0x20>
    // the HAL always blocks.
	  return HAL_USART_Write_Data(_serial, c);
 80a2c24:	4631      	mov	r1, r6
 80a2c26:	7c20      	ldrb	r0, [r4, #16]
  }
  return 0;
}
 80a2c28:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
size_t USARTSerial::write(uint8_t c)
{
  // attempt a write if blocking, or for non-blocking if there is room.
  if (_blocking || HAL_USART_Available_Data_For_Write(_serial) > 0) {
    // the HAL always blocks.
	  return HAL_USART_Write_Data(_serial, c);
 80a2c2c:	f7ff bbde 	b.w	80a23ec <HAL_USART_Write_Data>
  }
  return 0;
}
 80a2c30:	4628      	mov	r0, r5
 80a2c32:	bd70      	pop	{r4, r5, r6, pc}

080a2c34 <_ZN11USARTSerialC1E16HAL_USART_SerialP11Ring_BufferS2_>:
#include "spark_wiring_constants.h"
#include "module_info.h"

// Constructors ////////////////////////////////////////////////////////////////

USARTSerial::USARTSerial(HAL_USART_Serial serial, Ring_Buffer *rx_buffer, Ring_Buffer *tx_buffer)
 80a2c34:	b510      	push	{r4, lr}
 80a2c36:	4604      	mov	r4, r0
 80a2c38:	4608      	mov	r0, r1
 80a2c3a:	4611      	mov	r1, r2
  protected:
    void setWriteError(int err = 1) { write_error = err; }
    size_t printf_impl(bool newline, const char* format, ...);

  public:
    Print() : write_error(0) {}
 80a2c3c:	2200      	movs	r2, #0
 80a2c3e:	6062      	str	r2, [r4, #4]
 80a2c40:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 80a2c44:	60a2      	str	r2, [r4, #8]
 80a2c46:	4a05      	ldr	r2, [pc, #20]	; (80a2c5c <_ZN11USARTSerialC1E16HAL_USART_SerialP11Ring_BufferS2_+0x28>)
{
  _serial = serial;
 80a2c48:	7420      	strb	r0, [r4, #16]
#include "spark_wiring_constants.h"
#include "module_info.h"

// Constructors ////////////////////////////////////////////////////////////////

USARTSerial::USARTSerial(HAL_USART_Serial serial, Ring_Buffer *rx_buffer, Ring_Buffer *tx_buffer)
 80a2c4a:	6022      	str	r2, [r4, #0]
{
  _serial = serial;
  // Default is blocking mode
  _blocking = true;
 80a2c4c:	2201      	movs	r2, #1
 80a2c4e:	7462      	strb	r2, [r4, #17]
  HAL_USART_Init(serial, rx_buffer, tx_buffer);
 80a2c50:	461a      	mov	r2, r3
 80a2c52:	f7ff fbc3 	bl	80a23dc <HAL_USART_Init>
}
 80a2c56:	4620      	mov	r0, r4
 80a2c58:	bd10      	pop	{r4, pc}
 80a2c5a:	bf00      	nop
 80a2c5c:	080a426c 	.word	0x080a426c

080a2c60 <_ZN11USARTSerial9isEnabledEv>:
USARTSerial::operator bool() {
  return true;
}

bool USARTSerial::isEnabled() {
  return HAL_USART_Is_Enabled(_serial);
 80a2c60:	7c00      	ldrb	r0, [r0, #16]
 80a2c62:	f7ff bbeb 	b.w	80a243c <HAL_USART_Is_Enabled>
	...

080a2c68 <_Z22__fetch_global_Serial1v>:
static Ring_Buffer* serial1_rx_buffer = NULL;
static Ring_Buffer* serial1_tx_buffer = NULL;
#endif

USARTSerial& __fetch_global_Serial1()
{
 80a2c68:	b538      	push	{r3, r4, r5, lr}
#if ((MODULE_FUNCTION == MOD_FUNC_USER_PART) || (MODULE_FUNCTION == MOD_FUNC_MONO_FIRMWARE))
	static USARTSerial serial1(HAL_USART_SERIAL1, &serial1_rx_buffer, &serial1_tx_buffer);
 80a2c6a:	4d0c      	ldr	r5, [pc, #48]	; (80a2c9c <_Z22__fetch_global_Serial1v+0x34>)
 80a2c6c:	6829      	ldr	r1, [r5, #0]
 80a2c6e:	f011 0401 	ands.w	r4, r1, #1
 80a2c72:	d111      	bne.n	80a2c98 <_Z22__fetch_global_Serial1v+0x30>
 80a2c74:	4628      	mov	r0, r5
 80a2c76:	f7fd fa12 	bl	80a009e <__cxa_guard_acquire>
 80a2c7a:	b168      	cbz	r0, 80a2c98 <_Z22__fetch_global_Serial1v+0x30>
 80a2c7c:	4a08      	ldr	r2, [pc, #32]	; (80a2ca0 <_Z22__fetch_global_Serial1v+0x38>)
 80a2c7e:	4621      	mov	r1, r4
 80a2c80:	4b08      	ldr	r3, [pc, #32]	; (80a2ca4 <_Z22__fetch_global_Serial1v+0x3c>)
 80a2c82:	4809      	ldr	r0, [pc, #36]	; (80a2ca8 <_Z22__fetch_global_Serial1v+0x40>)
 80a2c84:	f7ff ffd6 	bl	80a2c34 <_ZN11USARTSerialC1E16HAL_USART_SerialP11Ring_BufferS2_>
 80a2c88:	4628      	mov	r0, r5
 80a2c8a:	f7fd fa0d 	bl	80a00a8 <__cxa_guard_release>
 80a2c8e:	4a07      	ldr	r2, [pc, #28]	; (80a2cac <_Z22__fetch_global_Serial1v+0x44>)
 80a2c90:	4907      	ldr	r1, [pc, #28]	; (80a2cb0 <_Z22__fetch_global_Serial1v+0x48>)
 80a2c92:	4805      	ldr	r0, [pc, #20]	; (80a2ca8 <_Z22__fetch_global_Serial1v+0x40>)
 80a2c94:	f000 fa80 	bl	80a3198 <__aeabi_atexit>
    serial1_tx_buffer = new Ring_Buffer();
  }
  static USARTSerial serial1(HAL_USART_SERIAL1, serial1_rx_buffer, serial1_tx_buffer);
#endif
	return serial1;
}
 80a2c98:	4803      	ldr	r0, [pc, #12]	; (80a2ca8 <_Z22__fetch_global_Serial1v+0x40>)
 80a2c9a:	bd38      	pop	{r3, r4, r5, pc}
 80a2c9c:	20000ca0 	.word	0x20000ca0
 80a2ca0:	20000ca4 	.word	0x20000ca4
 80a2ca4:	20000c1c 	.word	0x20000c1c
 80a2ca8:	20000c08 	.word	0x20000c08
 80a2cac:	200003ac 	.word	0x200003ac
 80a2cb0:	080a2be1 	.word	0x080a2be1

080a2cb4 <_ZN9USBSerial14blockOnOverrunEb>:
  HAL_USB_USART_Flush_Data(_serial);
}

void USBSerial::blockOnOverrun(bool block)
{
  _blocking = block;
 80a2cb4:	7441      	strb	r1, [r0, #17]
 80a2cb6:	4770      	bx	lr

080a2cb8 <_ZN9USBSerialD1Ev>:
#include "spark_wiring_platform.h"
#include "usb_hal.h"
#include "system_task.h"
#include "spark_wiring_startup.h"

class USBSerial : public Stream
 80a2cb8:	4770      	bx	lr

080a2cba <_ZN9USBSerial4readEv>:


// Read data from buffer
int USBSerial::read()
{
	return HAL_USB_USART_Receive_Data(_serial, false);
 80a2cba:	2100      	movs	r1, #0
 80a2cbc:	7c00      	ldrb	r0, [r0, #16]
 80a2cbe:	f7ff bbed 	b.w	80a249c <HAL_USB_USART_Receive_Data>

080a2cc2 <_ZN9USBSerial4peekEv>:
  _blocking = block;
}

int USBSerial::peek()
{
	return HAL_USB_USART_Receive_Data(_serial, true);
 80a2cc2:	2101      	movs	r1, #1
 80a2cc4:	7c00      	ldrb	r0, [r0, #16]
 80a2cc6:	f7ff bbe9 	b.w	80a249c <HAL_USB_USART_Receive_Data>

080a2cca <_ZN9USBSerial17availableForWriteEv>:
	return HAL_USB_USART_Receive_Data(_serial, false);
}

int USBSerial::availableForWrite()
{
  return HAL_USB_USART_Available_Data_For_Write(_serial);
 80a2cca:	7c00      	ldrb	r0, [r0, #16]
 80a2ccc:	f7ff bbde 	b.w	80a248c <HAL_USB_USART_Available_Data_For_Write>

080a2cd0 <_ZN9USBSerial9availableEv>:
}

int USBSerial::available()
{
	return HAL_USB_USART_Available_Data(_serial);
 80a2cd0:	7c00      	ldrb	r0, [r0, #16]
 80a2cd2:	f7ff bbd3 	b.w	80a247c <HAL_USB_USART_Available_Data>

080a2cd6 <_ZN9USBSerial5writeEh>:
}

size_t USBSerial::write(uint8_t byte)
{
 80a2cd6:	b538      	push	{r3, r4, r5, lr}
 80a2cd8:	4604      	mov	r4, r0
  if (HAL_USB_USART_Available_Data_For_Write(_serial) > 0 || _blocking) {
 80a2cda:	7c00      	ldrb	r0, [r0, #16]
{
	return HAL_USB_USART_Available_Data(_serial);
}

size_t USBSerial::write(uint8_t byte)
{
 80a2cdc:	460d      	mov	r5, r1
  if (HAL_USB_USART_Available_Data_For_Write(_serial) > 0 || _blocking) {
 80a2cde:	f7ff fbd5 	bl	80a248c <HAL_USB_USART_Available_Data_For_Write>
 80a2ce2:	2800      	cmp	r0, #0
 80a2ce4:	dc01      	bgt.n	80a2cea <_ZN9USBSerial5writeEh+0x14>
 80a2ce6:	7c60      	ldrb	r0, [r4, #17]
 80a2ce8:	b120      	cbz	r0, 80a2cf4 <_ZN9USBSerial5writeEh+0x1e>
    HAL_USB_USART_Send_Data(_serial, byte);
 80a2cea:	4629      	mov	r1, r5
 80a2cec:	7c20      	ldrb	r0, [r4, #16]
 80a2cee:	f7ff fbdd 	bl	80a24ac <HAL_USB_USART_Send_Data>
    return 1;
 80a2cf2:	2001      	movs	r0, #1
  }
  return 0;
}
 80a2cf4:	bd38      	pop	{r3, r4, r5, pc}

080a2cf6 <_ZN9USBSerial5flushEv>:

void USBSerial::flush()
{
  HAL_USB_USART_Flush_Data(_serial);
 80a2cf6:	7c00      	ldrb	r0, [r0, #16]
 80a2cf8:	f7ff bbe0 	b.w	80a24bc <HAL_USB_USART_Flush_Data>

080a2cfc <_ZN9USBSerialD0Ev>:
 80a2cfc:	b510      	push	{r4, lr}
 80a2cfe:	4604      	mov	r4, r0
 80a2d00:	f7fd f9cb 	bl	80a009a <_ZdlPv>
 80a2d04:	4620      	mov	r0, r4
 80a2d06:	bd10      	pop	{r4, pc}

080a2d08 <_ZN9USBSerialC1E20HAL_USB_USART_SerialRK20HAL_USB_USART_Config>:

  HAL_USB_USART_Config conf = acquireSerialBuffer();
  HAL_USB_USART_Init(_serial, &conf);
}

USBSerial::USBSerial(HAL_USB_USART_Serial serial, const HAL_USB_USART_Config& conf)
 80a2d08:	b510      	push	{r4, lr}
 80a2d0a:	4604      	mov	r4, r0
 80a2d0c:	2300      	movs	r3, #0
 80a2d0e:	6063      	str	r3, [r4, #4]
 80a2d10:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 80a2d14:	60a3      	str	r3, [r4, #8]
 80a2d16:	4b05      	ldr	r3, [pc, #20]	; (80a2d2c <_ZN9USBSerialC1E20HAL_USB_USART_SerialRK20HAL_USB_USART_Config+0x24>)
 80a2d18:	4608      	mov	r0, r1
 80a2d1a:	6023      	str	r3, [r4, #0]
{
  _serial = serial;
  _blocking = true;
 80a2d1c:	2301      	movs	r3, #1
  HAL_USB_USART_Init(_serial, &conf);
}

USBSerial::USBSerial(HAL_USB_USART_Serial serial, const HAL_USB_USART_Config& conf)
{
  _serial = serial;
 80a2d1e:	7421      	strb	r1, [r4, #16]
  _blocking = true;
 80a2d20:	7463      	strb	r3, [r4, #17]

  HAL_USB_USART_Init(_serial, &conf);
 80a2d22:	4611      	mov	r1, r2
 80a2d24:	f7ff fb9a 	bl	80a245c <HAL_USB_USART_Init>
}
 80a2d28:	4620      	mov	r0, r4
 80a2d2a:	bd10      	pop	{r4, pc}
 80a2d2c:	080a429c 	.word	0x080a429c

080a2d30 <_ZN9USBSerial5beginEl>:
// Public methods
//

void USBSerial::begin(long speed)
{
    HAL_USB_USART_Begin(_serial, speed, NULL);
 80a2d30:	2200      	movs	r2, #0
 80a2d32:	7c00      	ldrb	r0, [r0, #16]
 80a2d34:	f7ff bb9a 	b.w	80a246c <HAL_USB_USART_Begin>

080a2d38 <_Z19acquireSerialBufferv>:

// Preinstantiate Objects //////////////////////////////////////////////////////
#ifdef SPARK_USB_SERIAL

HAL_USB_USART_Config __attribute__((weak)) acquireSerialBuffer()
{
 80a2d38:	b510      	push	{r4, lr}
 80a2d3a:	4604      	mov	r4, r0
  HAL_USB_USART_Config conf = {0};
 80a2d3c:	2214      	movs	r2, #20
 80a2d3e:	2100      	movs	r1, #0
 80a2d40:	f000 fe93 	bl	80a3a6a <memset>

#if defined(USB_SERIAL_USERSPACE_BUFFERS) && ((MODULE_FUNCTION == MOD_FUNC_USER_PART) || (MODULE_FUNCTION == MOD_FUNC_MONO_FIRMWARE))
  static uint8_t serial_rx_buffer[USB_RX_BUFFER_SIZE];
  static uint8_t serial_tx_buffer[USB_TX_BUFFER_SIZE];

  conf.rx_buffer = serial_rx_buffer;
 80a2d44:	4b05      	ldr	r3, [pc, #20]	; (80a2d5c <_Z19acquireSerialBufferv+0x24>)
  conf.rx_buffer_size = USB_RX_BUFFER_SIZE;
  conf.tx_buffer_size = USB_TX_BUFFER_SIZE;
#endif

  return conf;
}
 80a2d46:	4620      	mov	r0, r4

#if defined(USB_SERIAL_USERSPACE_BUFFERS) && ((MODULE_FUNCTION == MOD_FUNC_USER_PART) || (MODULE_FUNCTION == MOD_FUNC_MONO_FIRMWARE))
  static uint8_t serial_rx_buffer[USB_RX_BUFFER_SIZE];
  static uint8_t serial_tx_buffer[USB_TX_BUFFER_SIZE];

  conf.rx_buffer = serial_rx_buffer;
 80a2d48:	6063      	str	r3, [r4, #4]
  conf.tx_buffer = serial_tx_buffer;
 80a2d4a:	4b05      	ldr	r3, [pc, #20]	; (80a2d60 <_Z19acquireSerialBufferv+0x28>)
 80a2d4c:	60e3      	str	r3, [r4, #12]
  conf.rx_buffer_size = USB_RX_BUFFER_SIZE;
 80a2d4e:	f240 1301 	movw	r3, #257	; 0x101
 80a2d52:	8123      	strh	r3, [r4, #8]
  conf.tx_buffer_size = USB_TX_BUFFER_SIZE;
 80a2d54:	2381      	movs	r3, #129	; 0x81
 80a2d56:	8223      	strh	r3, [r4, #16]
#endif

  return conf;
}
 80a2d58:	bd10      	pop	{r4, pc}
 80a2d5a:	bf00      	nop
 80a2d5c:	20000dad 	.word	0x20000dad
 80a2d60:	20000d2c 	.word	0x20000d2c

080a2d64 <_Z16_fetch_usbserialv>:

USBSerial& _fetch_usbserial()
{
 80a2d64:	b530      	push	{r4, r5, lr}
  HAL_USB_USART_Config conf = acquireSerialBuffer();
	static USBSerial _usbserial(HAL_USB_USART_SERIAL, conf);
 80a2d66:	4d0e      	ldr	r5, [pc, #56]	; (80a2da0 <_Z16_fetch_usbserialv+0x3c>)

  return conf;
}

USBSerial& _fetch_usbserial()
{
 80a2d68:	b087      	sub	sp, #28
  HAL_USB_USART_Config conf = acquireSerialBuffer();
 80a2d6a:	a801      	add	r0, sp, #4
 80a2d6c:	f7ff ffe4 	bl	80a2d38 <_Z19acquireSerialBufferv>
	static USBSerial _usbserial(HAL_USB_USART_SERIAL, conf);
 80a2d70:	6829      	ldr	r1, [r5, #0]
 80a2d72:	f011 0401 	ands.w	r4, r1, #1
 80a2d76:	d110      	bne.n	80a2d9a <_Z16_fetch_usbserialv+0x36>
 80a2d78:	4628      	mov	r0, r5
 80a2d7a:	f7fd f990 	bl	80a009e <__cxa_guard_acquire>
 80a2d7e:	b160      	cbz	r0, 80a2d9a <_Z16_fetch_usbserialv+0x36>
 80a2d80:	aa01      	add	r2, sp, #4
 80a2d82:	4621      	mov	r1, r4
 80a2d84:	4807      	ldr	r0, [pc, #28]	; (80a2da4 <_Z16_fetch_usbserialv+0x40>)
 80a2d86:	f7ff ffbf 	bl	80a2d08 <_ZN9USBSerialC1E20HAL_USB_USART_SerialRK20HAL_USB_USART_Config>
 80a2d8a:	4628      	mov	r0, r5
 80a2d8c:	f7fd f98c 	bl	80a00a8 <__cxa_guard_release>
 80a2d90:	4a05      	ldr	r2, [pc, #20]	; (80a2da8 <_Z16_fetch_usbserialv+0x44>)
 80a2d92:	4906      	ldr	r1, [pc, #24]	; (80a2dac <_Z16_fetch_usbserialv+0x48>)
 80a2d94:	4803      	ldr	r0, [pc, #12]	; (80a2da4 <_Z16_fetch_usbserialv+0x40>)
 80a2d96:	f000 f9ff 	bl	80a3198 <__aeabi_atexit>
	return _usbserial;
}
 80a2d9a:	4802      	ldr	r0, [pc, #8]	; (80a2da4 <_Z16_fetch_usbserialv+0x40>)
 80a2d9c:	b007      	add	sp, #28
 80a2d9e:	bd30      	pop	{r4, r5, pc}
 80a2da0:	20000d28 	.word	0x20000d28
 80a2da4:	20000eb0 	.word	0x20000eb0
 80a2da8:	200003ac 	.word	0x200003ac
 80a2dac:	080a2cb9 	.word	0x080a2cb9

080a2db0 <_Z23acquireUSBSerial1Bufferv>:

#if Wiring_USBSerial1

HAL_USB_USART_Config __attribute__((weak)) acquireUSBSerial1Buffer()
{
 80a2db0:	b510      	push	{r4, lr}
 80a2db2:	4604      	mov	r4, r0
  HAL_USB_USART_Config conf = {0};
 80a2db4:	2214      	movs	r2, #20
 80a2db6:	2100      	movs	r1, #0
 80a2db8:	f000 fe57 	bl	80a3a6a <memset>

#if defined(USB_SERIAL_USERSPACE_BUFFERS) && ((MODULE_FUNCTION == MOD_FUNC_USER_PART) || (MODULE_FUNCTION == MOD_FUNC_MONO_FIRMWARE))
  static uint8_t usbserial1_rx_buffer[USB_RX_BUFFER_SIZE];
  static uint8_t usbserial1_tx_buffer[USB_TX_BUFFER_SIZE];

  conf.rx_buffer = usbserial1_rx_buffer;
 80a2dbc:	4b05      	ldr	r3, [pc, #20]	; (80a2dd4 <_Z23acquireUSBSerial1Bufferv+0x24>)
  conf.rx_buffer_size = USB_RX_BUFFER_SIZE;
  conf.tx_buffer_size = USB_TX_BUFFER_SIZE;
#endif

  return conf;
}
 80a2dbe:	4620      	mov	r0, r4

#if defined(USB_SERIAL_USERSPACE_BUFFERS) && ((MODULE_FUNCTION == MOD_FUNC_USER_PART) || (MODULE_FUNCTION == MOD_FUNC_MONO_FIRMWARE))
  static uint8_t usbserial1_rx_buffer[USB_RX_BUFFER_SIZE];
  static uint8_t usbserial1_tx_buffer[USB_TX_BUFFER_SIZE];

  conf.rx_buffer = usbserial1_rx_buffer;
 80a2dc0:	6063      	str	r3, [r4, #4]
  conf.tx_buffer = usbserial1_tx_buffer;
 80a2dc2:	4b05      	ldr	r3, [pc, #20]	; (80a2dd8 <_Z23acquireUSBSerial1Bufferv+0x28>)
 80a2dc4:	60e3      	str	r3, [r4, #12]
  conf.rx_buffer_size = USB_RX_BUFFER_SIZE;
 80a2dc6:	f240 1301 	movw	r3, #257	; 0x101
 80a2dca:	8123      	strh	r3, [r4, #8]
  conf.tx_buffer_size = USB_TX_BUFFER_SIZE;
 80a2dcc:	2381      	movs	r3, #129	; 0x81
 80a2dce:	8223      	strh	r3, [r4, #16]
#endif

  return conf;
}
 80a2dd0:	bd10      	pop	{r4, pc}
 80a2dd2:	bf00      	nop
 80a2dd4:	20000f60 	.word	0x20000f60
 80a2dd8:	20000ec8 	.word	0x20000ec8

080a2ddc <_Z17_fetch_usbserial1v>:

USBSerial& _fetch_usbserial1()
{
 80a2ddc:	b510      	push	{r4, lr}
  HAL_USB_USART_Config conf = acquireUSBSerial1Buffer();
  static USBSerial _usbserial1(HAL_USB_USART_SERIAL1, conf);
 80a2dde:	4c0e      	ldr	r4, [pc, #56]	; (80a2e18 <_Z17_fetch_usbserial1v+0x3c>)

  return conf;
}

USBSerial& _fetch_usbserial1()
{
 80a2de0:	b086      	sub	sp, #24
  HAL_USB_USART_Config conf = acquireUSBSerial1Buffer();
 80a2de2:	a801      	add	r0, sp, #4
 80a2de4:	f7ff ffe4 	bl	80a2db0 <_Z23acquireUSBSerial1Bufferv>
  static USBSerial _usbserial1(HAL_USB_USART_SERIAL1, conf);
 80a2de8:	6823      	ldr	r3, [r4, #0]
 80a2dea:	07db      	lsls	r3, r3, #31
 80a2dec:	d410      	bmi.n	80a2e10 <_Z17_fetch_usbserial1v+0x34>
 80a2dee:	4620      	mov	r0, r4
 80a2df0:	f7fd f955 	bl	80a009e <__cxa_guard_acquire>
 80a2df4:	b160      	cbz	r0, 80a2e10 <_Z17_fetch_usbserial1v+0x34>
 80a2df6:	aa01      	add	r2, sp, #4
 80a2df8:	2101      	movs	r1, #1
 80a2dfa:	4808      	ldr	r0, [pc, #32]	; (80a2e1c <_Z17_fetch_usbserial1v+0x40>)
 80a2dfc:	f7ff ff84 	bl	80a2d08 <_ZN9USBSerialC1E20HAL_USB_USART_SerialRK20HAL_USB_USART_Config>
 80a2e00:	4620      	mov	r0, r4
 80a2e02:	f7fd f951 	bl	80a00a8 <__cxa_guard_release>
 80a2e06:	4a06      	ldr	r2, [pc, #24]	; (80a2e20 <_Z17_fetch_usbserial1v+0x44>)
 80a2e08:	4906      	ldr	r1, [pc, #24]	; (80a2e24 <_Z17_fetch_usbserial1v+0x48>)
 80a2e0a:	4804      	ldr	r0, [pc, #16]	; (80a2e1c <_Z17_fetch_usbserial1v+0x40>)
 80a2e0c:	f000 f9c4 	bl	80a3198 <__aeabi_atexit>
  return _usbserial1;
}
 80a2e10:	4802      	ldr	r0, [pc, #8]	; (80a2e1c <_Z17_fetch_usbserial1v+0x40>)
 80a2e12:	b006      	add	sp, #24
 80a2e14:	bd10      	pop	{r4, pc}
 80a2e16:	bf00      	nop
 80a2e18:	20000ec4 	.word	0x20000ec4
 80a2e1c:	20000f4c 	.word	0x20000f4c
 80a2e20:	200003ac 	.word	0x200003ac
 80a2e24:	080a2cb9 	.word	0x080a2cb9

080a2e28 <_ZN5spark9WiFiClassD1Ev>:
        wlan_set_ipaddress_source(source, true, NULL);
    }

public:
    WiFiClass() {}
    ~WiFiClass() {}
 80a2e28:	4770      	bx	lr

080a2e2a <_ZN5spark9WiFiClass5readyEv>:
    bool connecting(void) {
        return network_connecting(*this, 0, NULL);
    }

    bool ready(void) {
        return network_ready(*this, 0, NULL);
 80a2e2a:	2200      	movs	r2, #0
 80a2e2c:	4611      	mov	r1, r2
 80a2e2e:	4610      	mov	r0, r2
 80a2e30:	f7ff bb92 	b.w	80a2558 <network_ready>

080a2e34 <_GLOBAL__sub_I__ZN10WiFiSignalC2ERK21wlan_connected_info_t>:
    void setIPAddressSource(IPAddressSource source) {
        wlan_set_ipaddress_source(source, true, NULL);
    }

public:
    WiFiClass() {}
 80a2e34:	4803      	ldr	r0, [pc, #12]	; (80a2e44 <_GLOBAL__sub_I__ZN10WiFiSignalC2ERK21wlan_connected_info_t+0x10>)
 80a2e36:	4b04      	ldr	r3, [pc, #16]	; (80a2e48 <_GLOBAL__sub_I__ZN10WiFiSignalC2ERK21wlan_connected_info_t+0x14>)
one second timeout is reached). If the aforementioned "bug" is ever fixed by
TI, no changes need to be made to this function, as it would be implemented
the same way.
*****************************************************************************/

    WiFiClass WiFi;
 80a2e38:	4a04      	ldr	r2, [pc, #16]	; (80a2e4c <_GLOBAL__sub_I__ZN10WiFiSignalC2ERK21wlan_connected_info_t+0x18>)
 80a2e3a:	4905      	ldr	r1, [pc, #20]	; (80a2e50 <_GLOBAL__sub_I__ZN10WiFiSignalC2ERK21wlan_connected_info_t+0x1c>)
 80a2e3c:	6003      	str	r3, [r0, #0]
 80a2e3e:	f000 b9ab 	b.w	80a3198 <__aeabi_atexit>
 80a2e42:	bf00      	nop
 80a2e44:	20001064 	.word	0x20001064
 80a2e48:	080a42cc 	.word	0x080a42cc
 80a2e4c:	200003ac 	.word	0x200003ac
 80a2e50:	080a2e29 	.word	0x080a2e29

080a2e54 <_Z11str_reversePc>:

//------------------------------------------------------------------------------------------
#define BUFSIZE (sizeof(long) * 8 + 1)

//utility function used by ultoa()
__attribute__((weak)) void str_reverse(char* buffer){
 80a2e54:	b510      	push	{r4, lr}
 80a2e56:	4604      	mov	r4, r0
	char *i, *j;
	char c;
	i=buffer;
	j=buffer + strlen(buffer)-1;
 80a2e58:	f000 fe7a 	bl	80a3b50 <strlen>
 80a2e5c:	3801      	subs	r0, #1
 80a2e5e:	1823      	adds	r3, r4, r0
 80a2e60:	4620      	mov	r0, r4
	while(i<j){
 80a2e62:	4298      	cmp	r0, r3
 80a2e64:	d206      	bcs.n	80a2e74 <_Z11str_reversePc+0x20>
		c = *i;
 80a2e66:	7802      	ldrb	r2, [r0, #0]
		*i = *j;
 80a2e68:	7819      	ldrb	r1, [r3, #0]
 80a2e6a:	f800 1b01 	strb.w	r1, [r0], #1
		*j = c;
 80a2e6e:	f803 2901 	strb.w	r2, [r3], #-1
__attribute__((weak)) void str_reverse(char* buffer){
	char *i, *j;
	char c;
	i=buffer;
	j=buffer + strlen(buffer)-1;
	while(i<j){
 80a2e72:	e7f6      	b.n	80a2e62 <_Z11str_reversePc+0xe>
 80a2e74:	bd10      	pop	{r4, pc}

080a2e76 <ultoa>:
      memcpy(head, ++tail, i);
      return str;
}

//convert unsigned long to string
__attribute__((weak)) char* ultoa(unsigned long a, char* buffer, int radix, char pad){
 80a2e76:	b570      	push	{r4, r5, r6, lr}
 80a2e78:	460c      	mov	r4, r1
	if(radix<2 || radix>36){
 80a2e7a:	1e91      	subs	r1, r2, #2
 80a2e7c:	2922      	cmp	r1, #34	; 0x22
 80a2e7e:	d820      	bhi.n	80a2ec2 <ultoa+0x4c>
 80a2e80:	4625      	mov	r5, r4
 80a2e82:	4629      	mov	r1, r5
		return NULL;
	}
	char* ptr=buffer;

	div_t result;
	while(a){
 80a2e84:	b910      	cbnz	r0, 80a2e8c <ultoa+0x16>
                *ptr += 'a'-10;
            }
            ++ptr;
            a = result.quot;
	}
        while (ptr < buffer+pad)
 80a2e86:	4423      	add	r3, r4
            *ptr++ = '0';
 80a2e88:	2230      	movs	r2, #48	; 0x30
 80a2e8a:	e00e      	b.n	80a2eaa <ultoa+0x34>
	div_t result;
	while(a){
            /* toolchain bug??
            result = div(a, radix);
            */
            result.quot = a/radix;
 80a2e8c:	fbb0 f6f2 	udiv	r6, r0, r2
            result.rem = a%radix;
 80a2e90:	fb02 0016 	mls	r0, r2, r6, r0
            *ptr = result.rem;
 80a2e94:	b2c1      	uxtb	r1, r0
            if(result.rem<10){
 80a2e96:	2809      	cmp	r0, #9
            /* toolchain bug??
            result = div(a, radix);
            */
            result.quot = a/radix;
            result.rem = a%radix;
            *ptr = result.rem;
 80a2e98:	f805 1b01 	strb.w	r1, [r5], #1
            if(result.rem<10){
                *ptr += '0';
 80a2e9c:	bf94      	ite	ls
 80a2e9e:	3130      	addls	r1, #48	; 0x30
            }else{
                *ptr += 'a'-10;
 80a2ea0:	3157      	addhi	r1, #87	; 0x57
 80a2ea2:	f805 1c01 	strb.w	r1, [r5, #-1]
            }
            ++ptr;
            a = result.quot;
 80a2ea6:	4630      	mov	r0, r6
		return NULL;
	}
	char* ptr=buffer;

	div_t result;
	while(a){
 80a2ea8:	e7eb      	b.n	80a2e82 <ultoa+0xc>
                *ptr += 'a'-10;
            }
            ++ptr;
            a = result.quot;
	}
        while (ptr < buffer+pad)
 80a2eaa:	4299      	cmp	r1, r3
 80a2eac:	d202      	bcs.n	80a2eb4 <ultoa+0x3e>
            *ptr++ = '0';
 80a2eae:	f801 2b01 	strb.w	r2, [r1], #1
                *ptr += 'a'-10;
            }
            ++ptr;
            a = result.quot;
	}
        while (ptr < buffer+pad)
 80a2eb2:	e7fa      	b.n	80a2eaa <ultoa+0x34>
            *ptr++ = '0';

	*ptr = '\0';
 80a2eb4:	2300      	movs	r3, #0
	str_reverse(buffer);
 80a2eb6:	4620      	mov	r0, r4
            a = result.quot;
	}
        while (ptr < buffer+pad)
            *ptr++ = '0';

	*ptr = '\0';
 80a2eb8:	700b      	strb	r3, [r1, #0]
	str_reverse(buffer);
 80a2eba:	f7ff ffcb 	bl	80a2e54 <_Z11str_reversePc>
	return buffer;
 80a2ebe:	4620      	mov	r0, r4
 80a2ec0:	bd70      	pop	{r4, r5, r6, pc}
}

//convert unsigned long to string
__attribute__((weak)) char* ultoa(unsigned long a, char* buffer, int radix, char pad){
	if(radix<2 || radix>36){
		return NULL;
 80a2ec2:	2000      	movs	r0, #0
            *ptr++ = '0';

	*ptr = '\0';
	str_reverse(buffer);
	return buffer;
}
 80a2ec4:	bd70      	pop	{r4, r5, r6, pc}

080a2ec6 <itoa>:

__attribute__((weak)) char* itoa(int a, char* buffer, int radix){
 80a2ec6:	b538      	push	{r3, r4, r5, lr}
	if(a<0){
 80a2ec8:	1e03      	subs	r3, r0, #0
	*ptr = '\0';
	str_reverse(buffer);
	return buffer;
}

__attribute__((weak)) char* itoa(int a, char* buffer, int radix){
 80a2eca:	460c      	mov	r4, r1
 80a2ecc:	4615      	mov	r5, r2
	if(a<0){
 80a2ece:	da0b      	bge.n	80a2ee8 <itoa+0x22>
		*buffer = '-';
		unsigned v = a==INT_MIN ? ((unsigned)INT_MAX+1) : -a;
 80a2ed0:	f1b3 4f00 	cmp.w	r3, #2147483648	; 0x80000000
	return buffer;
}

__attribute__((weak)) char* itoa(int a, char* buffer, int radix){
	if(a<0){
		*buffer = '-';
 80a2ed4:	f04f 022d 	mov.w	r2, #45	; 0x2d
		unsigned v = a==INT_MIN ? ((unsigned)INT_MAX+1) : -a;
 80a2ed8:	bf14      	ite	ne
 80a2eda:	4258      	negne	r0, r3
 80a2edc:	4618      	moveq	r0, r3
		ultoa((unsigned)v, buffer + 1, radix);
 80a2ede:	2301      	movs	r3, #1
	return buffer;
}

__attribute__((weak)) char* itoa(int a, char* buffer, int radix){
	if(a<0){
		*buffer = '-';
 80a2ee0:	700a      	strb	r2, [r1, #0]
		unsigned v = a==INT_MIN ? ((unsigned)INT_MAX+1) : -a;
		ultoa((unsigned)v, buffer + 1, radix);
 80a2ee2:	462a      	mov	r2, r5
 80a2ee4:	4419      	add	r1, r3
 80a2ee6:	e000      	b.n	80a2eea <itoa+0x24>
	}else{
		ultoa(a, buffer, radix);
 80a2ee8:	2301      	movs	r3, #1
 80a2eea:	f7ff ffc4 	bl	80a2e76 <ultoa>
	}
	return buffer;
}
 80a2eee:	4620      	mov	r0, r4
 80a2ef0:	bd38      	pop	{r3, r4, r5, pc}
	...

080a2ef4 <serialEventRun>:

/**
 * Provides background processing of serial data.
 */
void serialEventRun()
{
 80a2ef4:	b508      	push	{r3, lr}
    if (serialEvent && Serial.available()>0)
 80a2ef6:	4b14      	ldr	r3, [pc, #80]	; (80a2f48 <serialEventRun+0x54>)
 80a2ef8:	b133      	cbz	r3, 80a2f08 <serialEventRun+0x14>
 80a2efa:	f7ff ff33 	bl	80a2d64 <_Z16_fetch_usbserialv>
 80a2efe:	6803      	ldr	r3, [r0, #0]
 80a2f00:	691b      	ldr	r3, [r3, #16]
 80a2f02:	4798      	blx	r3
 80a2f04:	2800      	cmp	r0, #0
 80a2f06:	dc16      	bgt.n	80a2f36 <serialEventRun+0x42>
        serialEvent();

    if (serialEvent1 && Serial1.available()>0)
 80a2f08:	4b10      	ldr	r3, [pc, #64]	; (80a2f4c <serialEventRun+0x58>)
 80a2f0a:	b133      	cbz	r3, 80a2f1a <serialEventRun+0x26>
 80a2f0c:	f7ff feac 	bl	80a2c68 <_Z22__fetch_global_Serial1v>
 80a2f10:	6803      	ldr	r3, [r0, #0]
 80a2f12:	691b      	ldr	r3, [r3, #16]
 80a2f14:	4798      	blx	r3
 80a2f16:	2800      	cmp	r0, #0
 80a2f18:	dc10      	bgt.n	80a2f3c <serialEventRun+0x48>
        serialEvent1();

#if Wiring_Serial2
    if (serialEventRun2) serialEventRun2();
 80a2f1a:	4b0d      	ldr	r3, [pc, #52]	; (80a2f50 <serialEventRun+0x5c>)
 80a2f1c:	b10b      	cbz	r3, 80a2f22 <serialEventRun+0x2e>
 80a2f1e:	f3af 8000 	nop.w
#if Wiring_Serial5
    if (serialEventRun5) serialEventRun5();
#endif

#if Wiring_USBSerial1
    if (usbSerialEvent1 && USBSerial1.available()>0)
 80a2f22:	4b0c      	ldr	r3, [pc, #48]	; (80a2f54 <serialEventRun+0x60>)
 80a2f24:	b17b      	cbz	r3, 80a2f46 <serialEventRun+0x52>
 80a2f26:	f7ff ff59 	bl	80a2ddc <_Z17_fetch_usbserial1v>
 80a2f2a:	6803      	ldr	r3, [r0, #0]
 80a2f2c:	691b      	ldr	r3, [r3, #16]
 80a2f2e:	4798      	blx	r3
 80a2f30:	2800      	cmp	r0, #0
 80a2f32:	dc06      	bgt.n	80a2f42 <serialEventRun+0x4e>
 80a2f34:	bd08      	pop	{r3, pc}
 * Provides background processing of serial data.
 */
void serialEventRun()
{
    if (serialEvent && Serial.available()>0)
        serialEvent();
 80a2f36:	f3af 8000 	nop.w
 80a2f3a:	e7e5      	b.n	80a2f08 <serialEventRun+0x14>

    if (serialEvent1 && Serial1.available()>0)
        serialEvent1();
 80a2f3c:	f3af 8000 	nop.w
 80a2f40:	e7eb      	b.n	80a2f1a <serialEventRun+0x26>
    if (serialEventRun5) serialEventRun5();
#endif

#if Wiring_USBSerial1
    if (usbSerialEvent1 && USBSerial1.available()>0)
        usbSerialEvent1();
 80a2f42:	f3af 8000 	nop.w
 80a2f46:	bd08      	pop	{r3, pc}
	...

080a2f58 <_post_loop>:
#if Wiring_Serial5
void serialEvent5() __attribute__((weak));
#endif

void _post_loop()
{
 80a2f58:	b508      	push	{r3, lr}
	serialEventRun();
 80a2f5a:	f7ff ffcb 	bl	80a2ef4 <serialEventRun>
		return !timeout_fn;
	}

	static inline system_tick_t current_time()
	{
		return HAL_Timer_Get_Milli_Seconds();
 80a2f5e:	f7ff f9b3 	bl	80a22c8 <HAL_Timer_Get_Milli_Seconds>
	/**
	 * Lifesign that the application is still working normally.
	 */
	static void checkin()
	{
		last_checkin = current_time();
 80a2f62:	4b01      	ldr	r3, [pc, #4]	; (80a2f68 <_post_loop+0x10>)
 80a2f64:	6018      	str	r0, [r3, #0]
 80a2f66:	bd08      	pop	{r3, pc}
 80a2f68:	20001070 	.word	0x20001070

080a2f6c <_Z33system_initialize_user_backup_ramv>:
 * the dynamically linked application module.
 */
void system_initialize_user_backup_ram()
{
    size_t len = &link_global_retained_end-&link_global_retained_start;
    memcpy(&link_global_retained_start, &link_global_retained_initial_values, len);
 80a2f6c:	4802      	ldr	r0, [pc, #8]	; (80a2f78 <_Z33system_initialize_user_backup_ramv+0xc>)
 80a2f6e:	4a03      	ldr	r2, [pc, #12]	; (80a2f7c <_Z33system_initialize_user_backup_ramv+0x10>)
 80a2f70:	4903      	ldr	r1, [pc, #12]	; (80a2f80 <_Z33system_initialize_user_backup_ramv+0x14>)
 80a2f72:	1a12      	subs	r2, r2, r0
 80a2f74:	f000 bd6e 	b.w	80a3a54 <memcpy>
 80a2f78:	40024000 	.word	0x40024000
 80a2f7c:	40024004 	.word	0x40024004
 80a2f80:	080a4490 	.word	0x080a4490

080a2f84 <_Z27ctrl_request_custom_handlerP12ctrl_request>:
bool __backup_ram_was_valid() { return false; }

#endif

// Default handler for CTRL_REQUEST_APP_CUSTOM requests
void __attribute((weak)) ctrl_request_custom_handler(ctrl_request* req) {
 80a2f84:	b507      	push	{r0, r1, r2, lr}
    system_ctrl_set_result(req, SYSTEM_ERROR_NOT_SUPPORTED, nullptr, nullptr, nullptr);
 80a2f86:	2300      	movs	r3, #0
 80a2f88:	9300      	str	r3, [sp, #0]
 80a2f8a:	461a      	mov	r2, r3
 80a2f8c:	f06f 0177 	mvn.w	r1, #119	; 0x77
 80a2f90:	f7ff fab6 	bl	80a2500 <system_ctrl_set_result>
}
 80a2f94:	b003      	add	sp, #12
 80a2f96:	f85d fb04 	ldr.w	pc, [sp], #4
	...

080a2f9c <_ZL20ctrl_request_handlerP12ctrl_request>:
// Callback invoked to process a logging configuration request
void(*log_process_ctrl_request_callback)(ctrl_request* req) = nullptr;
#endif

// Application handler for control requests
static void ctrl_request_handler(ctrl_request* req) {
 80a2f9c:	b507      	push	{r0, r1, r2, lr}
    switch (req->type) {
 80a2f9e:	8843      	ldrh	r3, [r0, #2]
 80a2fa0:	2b0a      	cmp	r3, #10
 80a2fa2:	d008      	beq.n	80a2fb6 <_ZL20ctrl_request_handlerP12ctrl_request+0x1a>
 80a2fa4:	2b50      	cmp	r3, #80	; 0x50
 80a2fa6:	d109      	bne.n	80a2fbc <_ZL20ctrl_request_handlerP12ctrl_request+0x20>
#if Wiring_LogConfig
    case CTRL_REQUEST_LOG_CONFIG: {
        if (log_process_ctrl_request_callback) {
 80a2fa8:	4b09      	ldr	r3, [pc, #36]	; (80a2fd0 <_ZL20ctrl_request_handlerP12ctrl_request+0x34>)
 80a2faa:	681b      	ldr	r3, [r3, #0]
 80a2fac:	b13b      	cbz	r3, 80a2fbe <_ZL20ctrl_request_handlerP12ctrl_request+0x22>
    }
    default:
        system_ctrl_set_result(req, SYSTEM_ERROR_NOT_SUPPORTED, nullptr, nullptr, nullptr);
        break;
    }
}
 80a2fae:	b003      	add	sp, #12
 80a2fb0:	f85d eb04 	ldr.w	lr, [sp], #4
static void ctrl_request_handler(ctrl_request* req) {
    switch (req->type) {
#if Wiring_LogConfig
    case CTRL_REQUEST_LOG_CONFIG: {
        if (log_process_ctrl_request_callback) {
            log_process_ctrl_request_callback(req);
 80a2fb4:	4718      	bx	r3
        }
        break;
    }
#endif
    case CTRL_REQUEST_APP_CUSTOM: {
        ctrl_request_custom_handler(req);
 80a2fb6:	f7ff ffe5 	bl	80a2f84 <_Z27ctrl_request_custom_handlerP12ctrl_request>
        break;
 80a2fba:	e006      	b.n	80a2fca <_ZL20ctrl_request_handlerP12ctrl_request+0x2e>
    }
    default:
        system_ctrl_set_result(req, SYSTEM_ERROR_NOT_SUPPORTED, nullptr, nullptr, nullptr);
 80a2fbc:	2300      	movs	r3, #0
 80a2fbe:	9300      	str	r3, [sp, #0]
 80a2fc0:	461a      	mov	r2, r3
 80a2fc2:	f06f 0177 	mvn.w	r1, #119	; 0x77
 80a2fc6:	f7ff fa9b 	bl	80a2500 <system_ctrl_set_result>
        break;
    }
}
 80a2fca:	b003      	add	sp, #12
 80a2fcc:	f85d fb04 	ldr.w	pc, [sp], #4
 80a2fd0:	20001068 	.word	0x20001068

080a2fd4 <module_user_init_hook>:

void module_user_init_hook()
{
 80a2fd4:	b538      	push	{r3, r4, r5, lr}
#if PLATFORM_BACKUP_RAM
    backup_ram_was_valid_ =  __backup_sram_signature==signature;
 80a2fd6:	4c10      	ldr	r4, [pc, #64]	; (80a3018 <module_user_init_hook+0x44>)
 80a2fd8:	4d10      	ldr	r5, [pc, #64]	; (80a301c <module_user_init_hook+0x48>)
 80a2fda:	6823      	ldr	r3, [r4, #0]
 80a2fdc:	42ab      	cmp	r3, r5
 80a2fde:	4b10      	ldr	r3, [pc, #64]	; (80a3020 <module_user_init_hook+0x4c>)
 80a2fe0:	bf0c      	ite	eq
 80a2fe2:	2201      	moveq	r2, #1
 80a2fe4:	2200      	movne	r2, #0
 80a2fe6:	701a      	strb	r2, [r3, #0]
    if (!backup_ram_was_valid_) {
 80a2fe8:	d002      	beq.n	80a2ff0 <module_user_init_hook+0x1c>
        system_initialize_user_backup_ram();
 80a2fea:	f7ff ffbf 	bl	80a2f6c <_Z33system_initialize_user_backup_ramv>
        __backup_sram_signature = signature;
 80a2fee:	6025      	str	r5, [r4, #0]
#endif

    // todo - add a RNG define for that capability
#if defined(STM32F2XX)
    // Initialize the default stdlib PRNG using hardware RNG as a seed
    srand(HAL_RNG_GetRandomNumber());
 80a2ff0:	f7ff f95a 	bl	80a22a8 <HAL_RNG_GetRandomNumber>
 80a2ff4:	f000 fd42 	bl	80a3a7c <srand>

    // If the user defines random_seed_from_cloud, call it with a seed value
    // generated by a hardware RNG as well.
    if (random_seed_from_cloud) {
 80a2ff8:	4b0a      	ldr	r3, [pc, #40]	; (80a3024 <module_user_init_hook+0x50>)
 80a2ffa:	b11b      	cbz	r3, 80a3004 <module_user_init_hook+0x30>
        uint32_t seed = HAL_RNG_GetRandomNumber();
 80a2ffc:	f7ff f954 	bl	80a22a8 <HAL_RNG_GetRandomNumber>
        random_seed_from_cloud(seed);
 80a3000:	f3af 8000 	nop.w
    }
#endif
    // Register the random_seed_from_cloud handler
    spark_set_random_seed_from_cloud_handler(&random_seed_from_cloud, nullptr);
 80a3004:	2100      	movs	r1, #0
 80a3006:	4807      	ldr	r0, [pc, #28]	; (80a3024 <module_user_init_hook+0x50>)
 80a3008:	f7ff fa9e 	bl	80a2548 <spark_set_random_seed_from_cloud_handler>

    // Register application handler for the control requests
    system_ctrl_set_app_request_handler(ctrl_request_handler, nullptr);
}
 80a300c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
#endif
    // Register the random_seed_from_cloud handler
    spark_set_random_seed_from_cloud_handler(&random_seed_from_cloud, nullptr);

    // Register application handler for the control requests
    system_ctrl_set_app_request_handler(ctrl_request_handler, nullptr);
 80a3010:	2100      	movs	r1, #0
 80a3012:	4805      	ldr	r0, [pc, #20]	; (80a3028 <module_user_init_hook+0x54>)
 80a3014:	f7ff ba6a 	b.w	80a24ec <system_ctrl_set_app_request_handler>
 80a3018:	40024000 	.word	0x40024000
 80a301c:	9a271c1e 	.word	0x9a271c1e
 80a3020:	2000106c 	.word	0x2000106c
 80a3024:	00000000 	.word	0x00000000
 80a3028:	080a2f9d 	.word	0x080a2f9d

080a302c <pinAvailable>:

/*
 * @brief Perform safety check on desired pin to see if it's already
 * being used.  Return 0 if used, otherwise return 1 if available.
 */
bool pinAvailable(uint16_t pin) {
 80a302c:	b510      	push	{r4, lr}
 80a302e:	4604      	mov	r4, r0

  // SPI safety check
#ifndef SPARK_WIRING_NO_SPI
  if(SPI.isEnabled() == true && (pin == SCK || pin == MOSI || pin == MISO))
 80a3030:	480f      	ldr	r0, [pc, #60]	; (80a3070 <pinAvailable+0x44>)
 80a3032:	f7ff fc13 	bl	80a285c <_ZN8SPIClass9isEnabledEv>
 80a3036:	b128      	cbz	r0, 80a3044 <pinAvailable+0x18>
 80a3038:	f1a4 030d 	sub.w	r3, r4, #13
 80a303c:	2b02      	cmp	r3, #2
 80a303e:	d801      	bhi.n	80a3044 <pinAvailable+0x18>
  {
    return 0; // 'pin' is used
 80a3040:	2000      	movs	r0, #0
 80a3042:	bd10      	pop	{r4, pc}
  }
#endif
  // I2C safety check
#ifndef SPARK_WIRING_NO_I2C
  if(Wire.isEnabled() == true && (pin == SCL || pin == SDA))
 80a3044:	f000 f84e 	bl	80a30e4 <_Z19__fetch_global_Wirev>
 80a3048:	f7ff fb1c 	bl	80a2684 <_ZN7TwoWire9isEnabledEv>
 80a304c:	b108      	cbz	r0, 80a3052 <pinAvailable+0x26>
 80a304e:	2c01      	cmp	r4, #1
 80a3050:	d9f6      	bls.n	80a3040 <pinAvailable+0x14>
    return 0; // 'pin' is used
  }
#endif
#ifndef SPARK_WIRING_NO_USART_SERIAL
  // Serial1 safety check
  if(Serial1.isEnabled() == true && (pin == RX || pin == TX))
 80a3052:	f7ff fe09 	bl	80a2c68 <_Z22__fetch_global_Serial1v>
 80a3056:	f7ff fe03 	bl	80a2c60 <_ZN11USARTSerial9isEnabledEv>
 80a305a:	b118      	cbz	r0, 80a3064 <pinAvailable+0x38>
 80a305c:	f1a4 0312 	sub.w	r3, r4, #18
 80a3060:	2b01      	cmp	r3, #1
 80a3062:	d9ed      	bls.n	80a3040 <pinAvailable+0x14>
  {
    return 0; // 'pin' is used
  }
#endif

  if (pin >= TOTAL_PINS)
 80a3064:	2c17      	cmp	r4, #23
 80a3066:	bf8c      	ite	hi
 80a3068:	2000      	movhi	r0, #0
 80a306a:	2001      	movls	r0, #1
    return 0;
  else
    return 1; // 'pin' is available
}
 80a306c:	bd10      	pop	{r4, pc}
 80a306e:	bf00      	nop
 80a3070:	200010ac 	.word	0x200010ac

080a3074 <pinMode>:
 * or INPUT_PULLDOWN
 */
void pinMode(uint16_t pin, PinMode setMode)
{

  if(pin >= TOTAL_PINS || setMode == PIN_MODE_NONE )
 80a3074:	2817      	cmp	r0, #23
/*
 * @brief Set the mode of the pin to OUTPUT, INPUT, INPUT_PULLUP,
 * or INPUT_PULLDOWN
 */
void pinMode(uint16_t pin, PinMode setMode)
{
 80a3076:	b538      	push	{r3, r4, r5, lr}
 80a3078:	4604      	mov	r4, r0
 80a307a:	460d      	mov	r5, r1

  if(pin >= TOTAL_PINS || setMode == PIN_MODE_NONE )
 80a307c:	d80a      	bhi.n	80a3094 <pinMode+0x20>
 80a307e:	29ff      	cmp	r1, #255	; 0xff
 80a3080:	d008      	beq.n	80a3094 <pinMode+0x20>
  {
    return;
  }

  // Safety check
  if( !pinAvailable(pin) ) {
 80a3082:	f7ff ffd3 	bl	80a302c <pinAvailable>
 80a3086:	b128      	cbz	r0, 80a3094 <pinMode+0x20>
    return;
  }

  HAL_Pin_Mode(pin, setMode);
 80a3088:	4629      	mov	r1, r5
 80a308a:	4620      	mov	r0, r4
}
 80a308c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  // Safety check
  if( !pinAvailable(pin) ) {
    return;
  }

  HAL_Pin_Mode(pin, setMode);
 80a3090:	f7ff b942 	b.w	80a2318 <HAL_Pin_Mode>
 80a3094:	bd38      	pop	{r3, r4, r5, pc}

080a3096 <digitalRead>:

/*
 * @brief Reads the value of a GPIO pin. Should return either 1 (HIGH) or 0 (LOW).
 */
int32_t digitalRead(pin_t pin)
{
 80a3096:	b510      	push	{r4, lr}
 80a3098:	4604      	mov	r4, r0
    PinMode mode = HAL_Get_Pin_Mode(pin);
 80a309a:	f7ff f945 	bl	80a2328 <HAL_Get_Pin_Mode>
    if (is_af_output_mode(mode))
 80a309e:	3804      	subs	r0, #4
 80a30a0:	b2c0      	uxtb	r0, r0
 80a30a2:	2801      	cmp	r0, #1
 80a30a4:	d908      	bls.n	80a30b8 <digitalRead+0x22>
        return LOW;

    // Safety check
    if( !pinAvailable(pin) ) {
 80a30a6:	4620      	mov	r0, r4
 80a30a8:	f7ff ffc0 	bl	80a302c <pinAvailable>
 80a30ac:	b120      	cbz	r0, 80a30b8 <digitalRead+0x22>
      return LOW;
    }

    return HAL_GPIO_Read(pin);
 80a30ae:	4620      	mov	r0, r4
}
 80a30b0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    // Safety check
    if( !pinAvailable(pin) ) {
      return LOW;
    }

    return HAL_GPIO_Read(pin);
 80a30b4:	f7ff b940 	b.w	80a2338 <HAL_GPIO_Read>
}
 80a30b8:	2000      	movs	r0, #0
 80a30ba:	bd10      	pop	{r4, pc}

080a30bc <_Z21__fetch_global_EEPROMv>:

// we don't use this global instance since there's no actual instance data
// Having this keeps the unoptimized build happy

EEPROMClass& __fetch_global_EEPROM()
{
 80a30bc:	b510      	push	{r4, lr}
	static EEPROMClass eeprom;
 80a30be:	4c07      	ldr	r4, [pc, #28]	; (80a30dc <_Z21__fetch_global_EEPROMv+0x20>)
 80a30c0:	6823      	ldr	r3, [r4, #0]
 80a30c2:	07db      	lsls	r3, r3, #31
 80a30c4:	d408      	bmi.n	80a30d8 <_Z21__fetch_global_EEPROMv+0x1c>
 80a30c6:	4620      	mov	r0, r4
 80a30c8:	f7fc ffe9 	bl	80a009e <__cxa_guard_acquire>
 80a30cc:	b120      	cbz	r0, 80a30d8 <_Z21__fetch_global_EEPROMv+0x1c>

struct EEPROMClass{

	EEPROMClass()
    {
    		HAL_EEPROM_Init();
 80a30ce:	f7ff f903 	bl	80a22d8 <HAL_EEPROM_Init>
 80a30d2:	4620      	mov	r0, r4
 80a30d4:	f7fc ffe8 	bl	80a00a8 <__cxa_guard_release>
	return eeprom;
}
 80a30d8:	4801      	ldr	r0, [pc, #4]	; (80a30e0 <_Z21__fetch_global_EEPROMv+0x24>)
 80a30da:	bd10      	pop	{r4, pc}
 80a30dc:	20001074 	.word	0x20001074
 80a30e0:	20001078 	.word	0x20001078

080a30e4 <_Z19__fetch_global_Wirev>:
#include "i2c_hal.h"

#ifndef SPARK_WIRING_NO_I2C

TwoWire& __fetch_global_Wire()
{
 80a30e4:	b538      	push	{r3, r4, r5, lr}
	static TwoWire wire(HAL_I2C_INTERFACE1);
 80a30e6:	4d0b      	ldr	r5, [pc, #44]	; (80a3114 <_Z19__fetch_global_Wirev+0x30>)
 80a30e8:	6829      	ldr	r1, [r5, #0]
 80a30ea:	f011 0401 	ands.w	r4, r1, #1
 80a30ee:	d10f      	bne.n	80a3110 <_Z19__fetch_global_Wirev+0x2c>
 80a30f0:	4628      	mov	r0, r5
 80a30f2:	f7fc ffd4 	bl	80a009e <__cxa_guard_acquire>
 80a30f6:	b158      	cbz	r0, 80a3110 <_Z19__fetch_global_Wirev+0x2c>
 80a30f8:	4621      	mov	r1, r4
 80a30fa:	4807      	ldr	r0, [pc, #28]	; (80a3118 <_Z19__fetch_global_Wirev+0x34>)
 80a30fc:	f7ff fab0 	bl	80a2660 <_ZN7TwoWireC1E17HAL_I2C_Interface>
 80a3100:	4628      	mov	r0, r5
 80a3102:	f7fc ffd1 	bl	80a00a8 <__cxa_guard_release>
 80a3106:	4a05      	ldr	r2, [pc, #20]	; (80a311c <_Z19__fetch_global_Wirev+0x38>)
 80a3108:	4905      	ldr	r1, [pc, #20]	; (80a3120 <_Z19__fetch_global_Wirev+0x3c>)
 80a310a:	4803      	ldr	r0, [pc, #12]	; (80a3118 <_Z19__fetch_global_Wirev+0x34>)
 80a310c:	f000 f844 	bl	80a3198 <__aeabi_atexit>
	return wire;
}
 80a3110:	4801      	ldr	r0, [pc, #4]	; (80a3118 <_Z19__fetch_global_Wirev+0x34>)
 80a3112:	bd38      	pop	{r3, r4, r5, pc}
 80a3114:	2000107c 	.word	0x2000107c
 80a3118:	20001080 	.word	0x20001080
 80a311c:	200003ac 	.word	0x200003ac
 80a3120:	080a260b 	.word	0x080a260b

080a3124 <_GLOBAL__sub_I_INADDR_NONE>:
#include "spark_wiring_ipaddress.h"

const IPAddress INADDR_NONE(0, 0, 0, 0);
 80a3124:	b513      	push	{r0, r1, r4, lr}
 80a3126:	4c08      	ldr	r4, [pc, #32]	; (80a3148 <_GLOBAL__sub_I_INADDR_NONE+0x24>)
 80a3128:	2300      	movs	r3, #0
 80a312a:	461a      	mov	r2, r3
 80a312c:	4619      	mov	r1, r3
 80a312e:	9300      	str	r3, [sp, #0]
 80a3130:	4620      	mov	r0, r4
 80a3132:	f7ff fad9 	bl	80a26e8 <_ZN9IPAddressC1Ehhhh>
 80a3136:	4620      	mov	r0, r4
 80a3138:	4a04      	ldr	r2, [pc, #16]	; (80a314c <_GLOBAL__sub_I_INADDR_NONE+0x28>)
 80a313a:	4905      	ldr	r1, [pc, #20]	; (80a3150 <_GLOBAL__sub_I_INADDR_NONE+0x2c>)
 80a313c:	b002      	add	sp, #8
 80a313e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 80a3142:	f000 b829 	b.w	80a3198 <__aeabi_atexit>
 80a3146:	bf00      	nop
 80a3148:	20001094 	.word	0x20001094
 80a314c:	200003ac 	.word	0x200003ac
 80a3150:	080a268d 	.word	0x080a268d

080a3154 <_GLOBAL__sub_I_SPI>:
#ifndef SPARK_WIRING_NO_SPI

SPIClass SPI(HAL_SPI_INTERFACE1);

#if Wiring_SPI1
SPIClass SPI1(HAL_SPI_INTERFACE2);
 80a3154:	b570      	push	{r4, r5, r6, lr}
#include "core_hal.h"
#include "spark_macros.h"

#ifndef SPARK_WIRING_NO_SPI

SPIClass SPI(HAL_SPI_INTERFACE1);
 80a3156:	4c0c      	ldr	r4, [pc, #48]	; (80a3188 <_GLOBAL__sub_I_SPI+0x34>)
 80a3158:	4e0c      	ldr	r6, [pc, #48]	; (80a318c <_GLOBAL__sub_I_SPI+0x38>)
 80a315a:	4d0d      	ldr	r5, [pc, #52]	; (80a3190 <_GLOBAL__sub_I_SPI+0x3c>)
 80a315c:	2100      	movs	r1, #0
 80a315e:	4620      	mov	r0, r4
 80a3160:	f7ff fb68 	bl	80a2834 <_ZN8SPIClassC1E17HAL_SPI_Interface>
 80a3164:	4620      	mov	r0, r4

#if Wiring_SPI1
SPIClass SPI1(HAL_SPI_INTERFACE2);
 80a3166:	4c0b      	ldr	r4, [pc, #44]	; (80a3194 <_GLOBAL__sub_I_SPI+0x40>)
#include "core_hal.h"
#include "spark_macros.h"

#ifndef SPARK_WIRING_NO_SPI

SPIClass SPI(HAL_SPI_INTERFACE1);
 80a3168:	4632      	mov	r2, r6
 80a316a:	4629      	mov	r1, r5
 80a316c:	f000 f814 	bl	80a3198 <__aeabi_atexit>

#if Wiring_SPI1
SPIClass SPI1(HAL_SPI_INTERFACE2);
 80a3170:	2101      	movs	r1, #1
 80a3172:	4620      	mov	r0, r4
 80a3174:	f7ff fb5e 	bl	80a2834 <_ZN8SPIClassC1E17HAL_SPI_Interface>
 80a3178:	4632      	mov	r2, r6
 80a317a:	4629      	mov	r1, r5
 80a317c:	4620      	mov	r0, r4
 80a317e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
 80a3182:	f000 b809 	b.w	80a3198 <__aeabi_atexit>
 80a3186:	bf00      	nop
 80a3188:	200010ac 	.word	0x200010ac
 80a318c:	200003ac 	.word	0x200003ac
 80a3190:	080a2825 	.word	0x080a2825
 80a3194:	200010bc 	.word	0x200010bc

080a3198 <__aeabi_atexit>:
 80a3198:	460b      	mov	r3, r1
 80a319a:	4601      	mov	r1, r0
 80a319c:	4618      	mov	r0, r3
 80a319e:	f000 bc4b 	b.w	80a3a38 <__cxa_atexit>
	...

080a31a4 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKSsj>:
 80a31a4:	4b24      	ldr	r3, [pc, #144]	; (80a3238 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKSsj+0x94>)
 80a31a6:	681a      	ldr	r2, [r3, #0]
 80a31a8:	07d0      	lsls	r0, r2, #31
 80a31aa:	bf5c      	itt	pl
 80a31ac:	2201      	movpl	r2, #1
 80a31ae:	601a      	strpl	r2, [r3, #0]
 80a31b0:	4b22      	ldr	r3, [pc, #136]	; (80a323c <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKSsj+0x98>)
 80a31b2:	681a      	ldr	r2, [r3, #0]
 80a31b4:	07d1      	lsls	r1, r2, #31
 80a31b6:	bf5c      	itt	pl
 80a31b8:	2201      	movpl	r2, #1
 80a31ba:	601a      	strpl	r2, [r3, #0]
 80a31bc:	4b20      	ldr	r3, [pc, #128]	; (80a3240 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKSsj+0x9c>)
 80a31be:	681a      	ldr	r2, [r3, #0]
 80a31c0:	07d2      	lsls	r2, r2, #31
 80a31c2:	bf5c      	itt	pl
 80a31c4:	2201      	movpl	r2, #1
 80a31c6:	601a      	strpl	r2, [r3, #0]
 80a31c8:	4b1e      	ldr	r3, [pc, #120]	; (80a3244 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKSsj+0xa0>)
 80a31ca:	681a      	ldr	r2, [r3, #0]
 80a31cc:	07d0      	lsls	r0, r2, #31
 80a31ce:	bf5c      	itt	pl
 80a31d0:	2201      	movpl	r2, #1
 80a31d2:	601a      	strpl	r2, [r3, #0]
 80a31d4:	4b1c      	ldr	r3, [pc, #112]	; (80a3248 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKSsj+0xa4>)
 80a31d6:	681a      	ldr	r2, [r3, #0]
 80a31d8:	07d1      	lsls	r1, r2, #31
 80a31da:	bf5c      	itt	pl
 80a31dc:	2201      	movpl	r2, #1
 80a31de:	601a      	strpl	r2, [r3, #0]
 80a31e0:	4b1a      	ldr	r3, [pc, #104]	; (80a324c <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKSsj+0xa8>)
 80a31e2:	681a      	ldr	r2, [r3, #0]
 80a31e4:	07d2      	lsls	r2, r2, #31
 80a31e6:	bf5c      	itt	pl
 80a31e8:	2201      	movpl	r2, #1
 80a31ea:	601a      	strpl	r2, [r3, #0]
 80a31ec:	4b18      	ldr	r3, [pc, #96]	; (80a3250 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKSsj+0xac>)
 80a31ee:	681a      	ldr	r2, [r3, #0]
 80a31f0:	07d0      	lsls	r0, r2, #31
 80a31f2:	bf5c      	itt	pl
 80a31f4:	2201      	movpl	r2, #1
 80a31f6:	601a      	strpl	r2, [r3, #0]
 80a31f8:	4b16      	ldr	r3, [pc, #88]	; (80a3254 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKSsj+0xb0>)
 80a31fa:	681a      	ldr	r2, [r3, #0]
 80a31fc:	07d1      	lsls	r1, r2, #31
 80a31fe:	bf5c      	itt	pl
 80a3200:	2201      	movpl	r2, #1
 80a3202:	601a      	strpl	r2, [r3, #0]
 80a3204:	4b14      	ldr	r3, [pc, #80]	; (80a3258 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKSsj+0xb4>)
 80a3206:	681a      	ldr	r2, [r3, #0]
 80a3208:	07d2      	lsls	r2, r2, #31
 80a320a:	bf5c      	itt	pl
 80a320c:	2201      	movpl	r2, #1
 80a320e:	601a      	strpl	r2, [r3, #0]
 80a3210:	4b12      	ldr	r3, [pc, #72]	; (80a325c <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKSsj+0xb8>)
 80a3212:	681a      	ldr	r2, [r3, #0]
 80a3214:	07d0      	lsls	r0, r2, #31
 80a3216:	bf5c      	itt	pl
 80a3218:	2201      	movpl	r2, #1
 80a321a:	601a      	strpl	r2, [r3, #0]
 80a321c:	4b10      	ldr	r3, [pc, #64]	; (80a3260 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKSsj+0xbc>)
 80a321e:	681a      	ldr	r2, [r3, #0]
 80a3220:	07d1      	lsls	r1, r2, #31
 80a3222:	bf5c      	itt	pl
 80a3224:	2201      	movpl	r2, #1
 80a3226:	601a      	strpl	r2, [r3, #0]
 80a3228:	4b0e      	ldr	r3, [pc, #56]	; (80a3264 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKSsj+0xc0>)
 80a322a:	681a      	ldr	r2, [r3, #0]
 80a322c:	07d2      	lsls	r2, r2, #31
 80a322e:	bf5c      	itt	pl
 80a3230:	2201      	movpl	r2, #1
 80a3232:	601a      	strpl	r2, [r3, #0]
 80a3234:	4770      	bx	lr
 80a3236:	bf00      	nop
 80a3238:	200010f8 	.word	0x200010f8
 80a323c:	200010f4 	.word	0x200010f4
 80a3240:	200010f0 	.word	0x200010f0
 80a3244:	200010ec 	.word	0x200010ec
 80a3248:	200010e8 	.word	0x200010e8
 80a324c:	200010e4 	.word	0x200010e4
 80a3250:	200010e0 	.word	0x200010e0
 80a3254:	200010dc 	.word	0x200010dc
 80a3258:	200010d8 	.word	0x200010d8
 80a325c:	200010d4 	.word	0x200010d4
 80a3260:	200010d0 	.word	0x200010d0
 80a3264:	200010cc 	.word	0x200010cc

080a3268 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj>:
 80a3268:	4b18      	ldr	r3, [pc, #96]	; (80a32cc <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x64>)
 80a326a:	681a      	ldr	r2, [r3, #0]
 80a326c:	07d1      	lsls	r1, r2, #31
 80a326e:	bf5c      	itt	pl
 80a3270:	2201      	movpl	r2, #1
 80a3272:	601a      	strpl	r2, [r3, #0]
 80a3274:	4b16      	ldr	r3, [pc, #88]	; (80a32d0 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x68>)
 80a3276:	681a      	ldr	r2, [r3, #0]
 80a3278:	07d2      	lsls	r2, r2, #31
 80a327a:	bf5c      	itt	pl
 80a327c:	2201      	movpl	r2, #1
 80a327e:	601a      	strpl	r2, [r3, #0]
 80a3280:	4b14      	ldr	r3, [pc, #80]	; (80a32d4 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x6c>)
 80a3282:	681a      	ldr	r2, [r3, #0]
 80a3284:	07d0      	lsls	r0, r2, #31
 80a3286:	bf5c      	itt	pl
 80a3288:	2201      	movpl	r2, #1
 80a328a:	601a      	strpl	r2, [r3, #0]
 80a328c:	4b12      	ldr	r3, [pc, #72]	; (80a32d8 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x70>)
 80a328e:	681a      	ldr	r2, [r3, #0]
 80a3290:	07d1      	lsls	r1, r2, #31
 80a3292:	bf5c      	itt	pl
 80a3294:	2201      	movpl	r2, #1
 80a3296:	601a      	strpl	r2, [r3, #0]
 80a3298:	4b10      	ldr	r3, [pc, #64]	; (80a32dc <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x74>)
 80a329a:	681a      	ldr	r2, [r3, #0]
 80a329c:	07d2      	lsls	r2, r2, #31
 80a329e:	bf5c      	itt	pl
 80a32a0:	2201      	movpl	r2, #1
 80a32a2:	601a      	strpl	r2, [r3, #0]
 80a32a4:	4b0e      	ldr	r3, [pc, #56]	; (80a32e0 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x78>)
 80a32a6:	681a      	ldr	r2, [r3, #0]
 80a32a8:	07d0      	lsls	r0, r2, #31
 80a32aa:	bf5c      	itt	pl
 80a32ac:	2201      	movpl	r2, #1
 80a32ae:	601a      	strpl	r2, [r3, #0]
 80a32b0:	4b0c      	ldr	r3, [pc, #48]	; (80a32e4 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x7c>)
 80a32b2:	681a      	ldr	r2, [r3, #0]
 80a32b4:	07d1      	lsls	r1, r2, #31
 80a32b6:	bf5c      	itt	pl
 80a32b8:	2201      	movpl	r2, #1
 80a32ba:	601a      	strpl	r2, [r3, #0]
 80a32bc:	4b0a      	ldr	r3, [pc, #40]	; (80a32e8 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x80>)
 80a32be:	681a      	ldr	r2, [r3, #0]
 80a32c0:	07d2      	lsls	r2, r2, #31
 80a32c2:	bf5c      	itt	pl
 80a32c4:	2201      	movpl	r2, #1
 80a32c6:	601a      	strpl	r2, [r3, #0]
 80a32c8:	4770      	bx	lr
 80a32ca:	bf00      	nop
 80a32cc:	20001118 	.word	0x20001118
 80a32d0:	20001114 	.word	0x20001114
 80a32d4:	20001110 	.word	0x20001110
 80a32d8:	2000110c 	.word	0x2000110c
 80a32dc:	20001108 	.word	0x20001108
 80a32e0:	20001104 	.word	0x20001104
 80a32e4:	20001100 	.word	0x20001100
 80a32e8:	200010fc 	.word	0x200010fc

080a32ec <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj>:
 80a32ec:	4b18      	ldr	r3, [pc, #96]	; (80a3350 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x64>)
 80a32ee:	681a      	ldr	r2, [r3, #0]
 80a32f0:	07d1      	lsls	r1, r2, #31
 80a32f2:	bf5c      	itt	pl
 80a32f4:	2201      	movpl	r2, #1
 80a32f6:	601a      	strpl	r2, [r3, #0]
 80a32f8:	4b16      	ldr	r3, [pc, #88]	; (80a3354 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x68>)
 80a32fa:	681a      	ldr	r2, [r3, #0]
 80a32fc:	07d2      	lsls	r2, r2, #31
 80a32fe:	bf5c      	itt	pl
 80a3300:	2201      	movpl	r2, #1
 80a3302:	601a      	strpl	r2, [r3, #0]
 80a3304:	4b14      	ldr	r3, [pc, #80]	; (80a3358 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x6c>)
 80a3306:	681a      	ldr	r2, [r3, #0]
 80a3308:	07d0      	lsls	r0, r2, #31
 80a330a:	bf5c      	itt	pl
 80a330c:	2201      	movpl	r2, #1
 80a330e:	601a      	strpl	r2, [r3, #0]
 80a3310:	4b12      	ldr	r3, [pc, #72]	; (80a335c <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x70>)
 80a3312:	681a      	ldr	r2, [r3, #0]
 80a3314:	07d1      	lsls	r1, r2, #31
 80a3316:	bf5c      	itt	pl
 80a3318:	2201      	movpl	r2, #1
 80a331a:	601a      	strpl	r2, [r3, #0]
 80a331c:	4b10      	ldr	r3, [pc, #64]	; (80a3360 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x74>)
 80a331e:	681a      	ldr	r2, [r3, #0]
 80a3320:	07d2      	lsls	r2, r2, #31
 80a3322:	bf5c      	itt	pl
 80a3324:	2201      	movpl	r2, #1
 80a3326:	601a      	strpl	r2, [r3, #0]
 80a3328:	4b0e      	ldr	r3, [pc, #56]	; (80a3364 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x78>)
 80a332a:	681a      	ldr	r2, [r3, #0]
 80a332c:	07d0      	lsls	r0, r2, #31
 80a332e:	bf5c      	itt	pl
 80a3330:	2201      	movpl	r2, #1
 80a3332:	601a      	strpl	r2, [r3, #0]
 80a3334:	4b0c      	ldr	r3, [pc, #48]	; (80a3368 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x7c>)
 80a3336:	681a      	ldr	r2, [r3, #0]
 80a3338:	07d1      	lsls	r1, r2, #31
 80a333a:	bf5c      	itt	pl
 80a333c:	2201      	movpl	r2, #1
 80a333e:	601a      	strpl	r2, [r3, #0]
 80a3340:	4b0a      	ldr	r3, [pc, #40]	; (80a336c <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x80>)
 80a3342:	681a      	ldr	r2, [r3, #0]
 80a3344:	07d2      	lsls	r2, r2, #31
 80a3346:	bf5c      	itt	pl
 80a3348:	2201      	movpl	r2, #1
 80a334a:	601a      	strpl	r2, [r3, #0]
 80a334c:	4770      	bx	lr
 80a334e:	bf00      	nop
 80a3350:	20001138 	.word	0x20001138
 80a3354:	20001134 	.word	0x20001134
 80a3358:	20001130 	.word	0x20001130
 80a335c:	2000112c 	.word	0x2000112c
 80a3360:	20001128 	.word	0x20001128
 80a3364:	20001124 	.word	0x20001124
 80a3368:	20001120 	.word	0x20001120
 80a336c:	2000111c 	.word	0x2000111c

080a3370 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKSsj>:
 80a3370:	4b24      	ldr	r3, [pc, #144]	; (80a3404 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKSsj+0x94>)
 80a3372:	681a      	ldr	r2, [r3, #0]
 80a3374:	07d0      	lsls	r0, r2, #31
 80a3376:	bf5c      	itt	pl
 80a3378:	2201      	movpl	r2, #1
 80a337a:	601a      	strpl	r2, [r3, #0]
 80a337c:	4b22      	ldr	r3, [pc, #136]	; (80a3408 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKSsj+0x98>)
 80a337e:	681a      	ldr	r2, [r3, #0]
 80a3380:	07d1      	lsls	r1, r2, #31
 80a3382:	bf5c      	itt	pl
 80a3384:	2201      	movpl	r2, #1
 80a3386:	601a      	strpl	r2, [r3, #0]
 80a3388:	4b20      	ldr	r3, [pc, #128]	; (80a340c <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKSsj+0x9c>)
 80a338a:	681a      	ldr	r2, [r3, #0]
 80a338c:	07d2      	lsls	r2, r2, #31
 80a338e:	bf5c      	itt	pl
 80a3390:	2201      	movpl	r2, #1
 80a3392:	601a      	strpl	r2, [r3, #0]
 80a3394:	4b1e      	ldr	r3, [pc, #120]	; (80a3410 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKSsj+0xa0>)
 80a3396:	681a      	ldr	r2, [r3, #0]
 80a3398:	07d0      	lsls	r0, r2, #31
 80a339a:	bf5c      	itt	pl
 80a339c:	2201      	movpl	r2, #1
 80a339e:	601a      	strpl	r2, [r3, #0]
 80a33a0:	4b1c      	ldr	r3, [pc, #112]	; (80a3414 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKSsj+0xa4>)
 80a33a2:	681a      	ldr	r2, [r3, #0]
 80a33a4:	07d1      	lsls	r1, r2, #31
 80a33a6:	bf5c      	itt	pl
 80a33a8:	2201      	movpl	r2, #1
 80a33aa:	601a      	strpl	r2, [r3, #0]
 80a33ac:	4b1a      	ldr	r3, [pc, #104]	; (80a3418 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKSsj+0xa8>)
 80a33ae:	681a      	ldr	r2, [r3, #0]
 80a33b0:	07d2      	lsls	r2, r2, #31
 80a33b2:	bf5c      	itt	pl
 80a33b4:	2201      	movpl	r2, #1
 80a33b6:	601a      	strpl	r2, [r3, #0]
 80a33b8:	4b18      	ldr	r3, [pc, #96]	; (80a341c <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKSsj+0xac>)
 80a33ba:	681a      	ldr	r2, [r3, #0]
 80a33bc:	07d0      	lsls	r0, r2, #31
 80a33be:	bf5c      	itt	pl
 80a33c0:	2201      	movpl	r2, #1
 80a33c2:	601a      	strpl	r2, [r3, #0]
 80a33c4:	4b16      	ldr	r3, [pc, #88]	; (80a3420 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKSsj+0xb0>)
 80a33c6:	681a      	ldr	r2, [r3, #0]
 80a33c8:	07d1      	lsls	r1, r2, #31
 80a33ca:	bf5c      	itt	pl
 80a33cc:	2201      	movpl	r2, #1
 80a33ce:	601a      	strpl	r2, [r3, #0]
 80a33d0:	4b14      	ldr	r3, [pc, #80]	; (80a3424 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKSsj+0xb4>)
 80a33d2:	681a      	ldr	r2, [r3, #0]
 80a33d4:	07d2      	lsls	r2, r2, #31
 80a33d6:	bf5c      	itt	pl
 80a33d8:	2201      	movpl	r2, #1
 80a33da:	601a      	strpl	r2, [r3, #0]
 80a33dc:	4b12      	ldr	r3, [pc, #72]	; (80a3428 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKSsj+0xb8>)
 80a33de:	681a      	ldr	r2, [r3, #0]
 80a33e0:	07d0      	lsls	r0, r2, #31
 80a33e2:	bf5c      	itt	pl
 80a33e4:	2201      	movpl	r2, #1
 80a33e6:	601a      	strpl	r2, [r3, #0]
 80a33e8:	4b10      	ldr	r3, [pc, #64]	; (80a342c <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKSsj+0xbc>)
 80a33ea:	681a      	ldr	r2, [r3, #0]
 80a33ec:	07d1      	lsls	r1, r2, #31
 80a33ee:	bf5c      	itt	pl
 80a33f0:	2201      	movpl	r2, #1
 80a33f2:	601a      	strpl	r2, [r3, #0]
 80a33f4:	4b0e      	ldr	r3, [pc, #56]	; (80a3430 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKSsj+0xc0>)
 80a33f6:	681a      	ldr	r2, [r3, #0]
 80a33f8:	07d2      	lsls	r2, r2, #31
 80a33fa:	bf5c      	itt	pl
 80a33fc:	2201      	movpl	r2, #1
 80a33fe:	601a      	strpl	r2, [r3, #0]
 80a3400:	4770      	bx	lr
 80a3402:	bf00      	nop
 80a3404:	20001168 	.word	0x20001168
 80a3408:	20001164 	.word	0x20001164
 80a340c:	20001160 	.word	0x20001160
 80a3410:	2000115c 	.word	0x2000115c
 80a3414:	20001158 	.word	0x20001158
 80a3418:	20001154 	.word	0x20001154
 80a341c:	20001150 	.word	0x20001150
 80a3420:	2000114c 	.word	0x2000114c
 80a3424:	20001148 	.word	0x20001148
 80a3428:	20001144 	.word	0x20001144
 80a342c:	20001140 	.word	0x20001140
 80a3430:	2000113c 	.word	0x2000113c

080a3434 <__aeabi_frsub>:
 80a3434:	f080 4000 	eor.w	r0, r0, #2147483648	; 0x80000000
 80a3438:	e002      	b.n	80a3440 <__addsf3>
 80a343a:	bf00      	nop

080a343c <__aeabi_fsub>:
 80a343c:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000

080a3440 <__addsf3>:
 80a3440:	0042      	lsls	r2, r0, #1
 80a3442:	bf1f      	itttt	ne
 80a3444:	ea5f 0341 	movsne.w	r3, r1, lsl #1
 80a3448:	ea92 0f03 	teqne	r2, r3
 80a344c:	ea7f 6c22 	mvnsne.w	ip, r2, asr #24
 80a3450:	ea7f 6c23 	mvnsne.w	ip, r3, asr #24
 80a3454:	d06a      	beq.n	80a352c <__addsf3+0xec>
 80a3456:	ea4f 6212 	mov.w	r2, r2, lsr #24
 80a345a:	ebd2 6313 	rsbs	r3, r2, r3, lsr #24
 80a345e:	bfc1      	itttt	gt
 80a3460:	18d2      	addgt	r2, r2, r3
 80a3462:	4041      	eorgt	r1, r0
 80a3464:	4048      	eorgt	r0, r1
 80a3466:	4041      	eorgt	r1, r0
 80a3468:	bfb8      	it	lt
 80a346a:	425b      	neglt	r3, r3
 80a346c:	2b19      	cmp	r3, #25
 80a346e:	bf88      	it	hi
 80a3470:	4770      	bxhi	lr
 80a3472:	f010 4f00 	tst.w	r0, #2147483648	; 0x80000000
 80a3476:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 80a347a:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
 80a347e:	bf18      	it	ne
 80a3480:	4240      	negne	r0, r0
 80a3482:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
 80a3486:	f441 0100 	orr.w	r1, r1, #8388608	; 0x800000
 80a348a:	f021 417f 	bic.w	r1, r1, #4278190080	; 0xff000000
 80a348e:	bf18      	it	ne
 80a3490:	4249      	negne	r1, r1
 80a3492:	ea92 0f03 	teq	r2, r3
 80a3496:	d03f      	beq.n	80a3518 <__addsf3+0xd8>
 80a3498:	f1a2 0201 	sub.w	r2, r2, #1
 80a349c:	fa41 fc03 	asr.w	ip, r1, r3
 80a34a0:	eb10 000c 	adds.w	r0, r0, ip
 80a34a4:	f1c3 0320 	rsb	r3, r3, #32
 80a34a8:	fa01 f103 	lsl.w	r1, r1, r3
 80a34ac:	f000 4300 	and.w	r3, r0, #2147483648	; 0x80000000
 80a34b0:	d502      	bpl.n	80a34b8 <__addsf3+0x78>
 80a34b2:	4249      	negs	r1, r1
 80a34b4:	eb60 0040 	sbc.w	r0, r0, r0, lsl #1
 80a34b8:	f5b0 0f00 	cmp.w	r0, #8388608	; 0x800000
 80a34bc:	d313      	bcc.n	80a34e6 <__addsf3+0xa6>
 80a34be:	f1b0 7f80 	cmp.w	r0, #16777216	; 0x1000000
 80a34c2:	d306      	bcc.n	80a34d2 <__addsf3+0x92>
 80a34c4:	0840      	lsrs	r0, r0, #1
 80a34c6:	ea4f 0131 	mov.w	r1, r1, rrx
 80a34ca:	f102 0201 	add.w	r2, r2, #1
 80a34ce:	2afe      	cmp	r2, #254	; 0xfe
 80a34d0:	d251      	bcs.n	80a3576 <__addsf3+0x136>
 80a34d2:	f1b1 4f00 	cmp.w	r1, #2147483648	; 0x80000000
 80a34d6:	eb40 50c2 	adc.w	r0, r0, r2, lsl #23
 80a34da:	bf08      	it	eq
 80a34dc:	f020 0001 	biceq.w	r0, r0, #1
 80a34e0:	ea40 0003 	orr.w	r0, r0, r3
 80a34e4:	4770      	bx	lr
 80a34e6:	0049      	lsls	r1, r1, #1
 80a34e8:	eb40 0000 	adc.w	r0, r0, r0
 80a34ec:	f410 0f00 	tst.w	r0, #8388608	; 0x800000
 80a34f0:	f1a2 0201 	sub.w	r2, r2, #1
 80a34f4:	d1ed      	bne.n	80a34d2 <__addsf3+0x92>
 80a34f6:	fab0 fc80 	clz	ip, r0
 80a34fa:	f1ac 0c08 	sub.w	ip, ip, #8
 80a34fe:	ebb2 020c 	subs.w	r2, r2, ip
 80a3502:	fa00 f00c 	lsl.w	r0, r0, ip
 80a3506:	bfaa      	itet	ge
 80a3508:	eb00 50c2 	addge.w	r0, r0, r2, lsl #23
 80a350c:	4252      	neglt	r2, r2
 80a350e:	4318      	orrge	r0, r3
 80a3510:	bfbc      	itt	lt
 80a3512:	40d0      	lsrlt	r0, r2
 80a3514:	4318      	orrlt	r0, r3
 80a3516:	4770      	bx	lr
 80a3518:	f092 0f00 	teq	r2, #0
 80a351c:	f481 0100 	eor.w	r1, r1, #8388608	; 0x800000
 80a3520:	bf06      	itte	eq
 80a3522:	f480 0000 	eoreq.w	r0, r0, #8388608	; 0x800000
 80a3526:	3201      	addeq	r2, #1
 80a3528:	3b01      	subne	r3, #1
 80a352a:	e7b5      	b.n	80a3498 <__addsf3+0x58>
 80a352c:	ea4f 0341 	mov.w	r3, r1, lsl #1
 80a3530:	ea7f 6c22 	mvns.w	ip, r2, asr #24
 80a3534:	bf18      	it	ne
 80a3536:	ea7f 6c23 	mvnsne.w	ip, r3, asr #24
 80a353a:	d021      	beq.n	80a3580 <__addsf3+0x140>
 80a353c:	ea92 0f03 	teq	r2, r3
 80a3540:	d004      	beq.n	80a354c <__addsf3+0x10c>
 80a3542:	f092 0f00 	teq	r2, #0
 80a3546:	bf08      	it	eq
 80a3548:	4608      	moveq	r0, r1
 80a354a:	4770      	bx	lr
 80a354c:	ea90 0f01 	teq	r0, r1
 80a3550:	bf1c      	itt	ne
 80a3552:	2000      	movne	r0, #0
 80a3554:	4770      	bxne	lr
 80a3556:	f012 4f7f 	tst.w	r2, #4278190080	; 0xff000000
 80a355a:	d104      	bne.n	80a3566 <__addsf3+0x126>
 80a355c:	0040      	lsls	r0, r0, #1
 80a355e:	bf28      	it	cs
 80a3560:	f040 4000 	orrcs.w	r0, r0, #2147483648	; 0x80000000
 80a3564:	4770      	bx	lr
 80a3566:	f112 7200 	adds.w	r2, r2, #33554432	; 0x2000000
 80a356a:	bf3c      	itt	cc
 80a356c:	f500 0000 	addcc.w	r0, r0, #8388608	; 0x800000
 80a3570:	4770      	bxcc	lr
 80a3572:	f000 4300 	and.w	r3, r0, #2147483648	; 0x80000000
 80a3576:	f043 40fe 	orr.w	r0, r3, #2130706432	; 0x7f000000
 80a357a:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 80a357e:	4770      	bx	lr
 80a3580:	ea7f 6222 	mvns.w	r2, r2, asr #24
 80a3584:	bf16      	itet	ne
 80a3586:	4608      	movne	r0, r1
 80a3588:	ea7f 6323 	mvnseq.w	r3, r3, asr #24
 80a358c:	4601      	movne	r1, r0
 80a358e:	0242      	lsls	r2, r0, #9
 80a3590:	bf06      	itte	eq
 80a3592:	ea5f 2341 	movseq.w	r3, r1, lsl #9
 80a3596:	ea90 0f01 	teqeq	r0, r1
 80a359a:	f440 0080 	orrne.w	r0, r0, #4194304	; 0x400000
 80a359e:	4770      	bx	lr

080a35a0 <__aeabi_ui2f>:
 80a35a0:	f04f 0300 	mov.w	r3, #0
 80a35a4:	e004      	b.n	80a35b0 <__aeabi_i2f+0x8>
 80a35a6:	bf00      	nop

080a35a8 <__aeabi_i2f>:
 80a35a8:	f010 4300 	ands.w	r3, r0, #2147483648	; 0x80000000
 80a35ac:	bf48      	it	mi
 80a35ae:	4240      	negmi	r0, r0
 80a35b0:	ea5f 0c00 	movs.w	ip, r0
 80a35b4:	bf08      	it	eq
 80a35b6:	4770      	bxeq	lr
 80a35b8:	f043 4396 	orr.w	r3, r3, #1258291200	; 0x4b000000
 80a35bc:	4601      	mov	r1, r0
 80a35be:	f04f 0000 	mov.w	r0, #0
 80a35c2:	e01c      	b.n	80a35fe <__aeabi_l2f+0x2a>

080a35c4 <__aeabi_ul2f>:
 80a35c4:	ea50 0201 	orrs.w	r2, r0, r1
 80a35c8:	bf08      	it	eq
 80a35ca:	4770      	bxeq	lr
 80a35cc:	f04f 0300 	mov.w	r3, #0
 80a35d0:	e00a      	b.n	80a35e8 <__aeabi_l2f+0x14>
 80a35d2:	bf00      	nop

080a35d4 <__aeabi_l2f>:
 80a35d4:	ea50 0201 	orrs.w	r2, r0, r1
 80a35d8:	bf08      	it	eq
 80a35da:	4770      	bxeq	lr
 80a35dc:	f011 4300 	ands.w	r3, r1, #2147483648	; 0x80000000
 80a35e0:	d502      	bpl.n	80a35e8 <__aeabi_l2f+0x14>
 80a35e2:	4240      	negs	r0, r0
 80a35e4:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 80a35e8:	ea5f 0c01 	movs.w	ip, r1
 80a35ec:	bf02      	ittt	eq
 80a35ee:	4684      	moveq	ip, r0
 80a35f0:	4601      	moveq	r1, r0
 80a35f2:	2000      	moveq	r0, #0
 80a35f4:	f043 43b6 	orr.w	r3, r3, #1526726656	; 0x5b000000
 80a35f8:	bf08      	it	eq
 80a35fa:	f1a3 5380 	subeq.w	r3, r3, #268435456	; 0x10000000
 80a35fe:	f5a3 0300 	sub.w	r3, r3, #8388608	; 0x800000
 80a3602:	fabc f28c 	clz	r2, ip
 80a3606:	3a08      	subs	r2, #8
 80a3608:	eba3 53c2 	sub.w	r3, r3, r2, lsl #23
 80a360c:	db10      	blt.n	80a3630 <__aeabi_l2f+0x5c>
 80a360e:	fa01 fc02 	lsl.w	ip, r1, r2
 80a3612:	4463      	add	r3, ip
 80a3614:	fa00 fc02 	lsl.w	ip, r0, r2
 80a3618:	f1c2 0220 	rsb	r2, r2, #32
 80a361c:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
 80a3620:	fa20 f202 	lsr.w	r2, r0, r2
 80a3624:	eb43 0002 	adc.w	r0, r3, r2
 80a3628:	bf08      	it	eq
 80a362a:	f020 0001 	biceq.w	r0, r0, #1
 80a362e:	4770      	bx	lr
 80a3630:	f102 0220 	add.w	r2, r2, #32
 80a3634:	fa01 fc02 	lsl.w	ip, r1, r2
 80a3638:	f1c2 0220 	rsb	r2, r2, #32
 80a363c:	ea50 004c 	orrs.w	r0, r0, ip, lsl #1
 80a3640:	fa21 f202 	lsr.w	r2, r1, r2
 80a3644:	eb43 0002 	adc.w	r0, r3, r2
 80a3648:	bf08      	it	eq
 80a364a:	ea20 70dc 	biceq.w	r0, r0, ip, lsr #31
 80a364e:	4770      	bx	lr

080a3650 <__aeabi_fmul>:
 80a3650:	f04f 0cff 	mov.w	ip, #255	; 0xff
 80a3654:	ea1c 52d0 	ands.w	r2, ip, r0, lsr #23
 80a3658:	bf1e      	ittt	ne
 80a365a:	ea1c 53d1 	andsne.w	r3, ip, r1, lsr #23
 80a365e:	ea92 0f0c 	teqne	r2, ip
 80a3662:	ea93 0f0c 	teqne	r3, ip
 80a3666:	d06f      	beq.n	80a3748 <__aeabi_fmul+0xf8>
 80a3668:	441a      	add	r2, r3
 80a366a:	ea80 0c01 	eor.w	ip, r0, r1
 80a366e:	0240      	lsls	r0, r0, #9
 80a3670:	bf18      	it	ne
 80a3672:	ea5f 2141 	movsne.w	r1, r1, lsl #9
 80a3676:	d01e      	beq.n	80a36b6 <__aeabi_fmul+0x66>
 80a3678:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
 80a367c:	ea43 1050 	orr.w	r0, r3, r0, lsr #5
 80a3680:	ea43 1151 	orr.w	r1, r3, r1, lsr #5
 80a3684:	fba0 3101 	umull	r3, r1, r0, r1
 80a3688:	f00c 4000 	and.w	r0, ip, #2147483648	; 0x80000000
 80a368c:	f5b1 0f00 	cmp.w	r1, #8388608	; 0x800000
 80a3690:	bf3e      	ittt	cc
 80a3692:	0049      	lslcc	r1, r1, #1
 80a3694:	ea41 71d3 	orrcc.w	r1, r1, r3, lsr #31
 80a3698:	005b      	lslcc	r3, r3, #1
 80a369a:	ea40 0001 	orr.w	r0, r0, r1
 80a369e:	f162 027f 	sbc.w	r2, r2, #127	; 0x7f
 80a36a2:	2afd      	cmp	r2, #253	; 0xfd
 80a36a4:	d81d      	bhi.n	80a36e2 <__aeabi_fmul+0x92>
 80a36a6:	f1b3 4f00 	cmp.w	r3, #2147483648	; 0x80000000
 80a36aa:	eb40 50c2 	adc.w	r0, r0, r2, lsl #23
 80a36ae:	bf08      	it	eq
 80a36b0:	f020 0001 	biceq.w	r0, r0, #1
 80a36b4:	4770      	bx	lr
 80a36b6:	f090 0f00 	teq	r0, #0
 80a36ba:	f00c 4c00 	and.w	ip, ip, #2147483648	; 0x80000000
 80a36be:	bf08      	it	eq
 80a36c0:	0249      	lsleq	r1, r1, #9
 80a36c2:	ea4c 2050 	orr.w	r0, ip, r0, lsr #9
 80a36c6:	ea40 2051 	orr.w	r0, r0, r1, lsr #9
 80a36ca:	3a7f      	subs	r2, #127	; 0x7f
 80a36cc:	bfc2      	ittt	gt
 80a36ce:	f1d2 03ff 	rsbsgt	r3, r2, #255	; 0xff
 80a36d2:	ea40 50c2 	orrgt.w	r0, r0, r2, lsl #23
 80a36d6:	4770      	bxgt	lr
 80a36d8:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 80a36dc:	f04f 0300 	mov.w	r3, #0
 80a36e0:	3a01      	subs	r2, #1
 80a36e2:	dc5d      	bgt.n	80a37a0 <__aeabi_fmul+0x150>
 80a36e4:	f112 0f19 	cmn.w	r2, #25
 80a36e8:	bfdc      	itt	le
 80a36ea:	f000 4000 	andle.w	r0, r0, #2147483648	; 0x80000000
 80a36ee:	4770      	bxle	lr
 80a36f0:	f1c2 0200 	rsb	r2, r2, #0
 80a36f4:	0041      	lsls	r1, r0, #1
 80a36f6:	fa21 f102 	lsr.w	r1, r1, r2
 80a36fa:	f1c2 0220 	rsb	r2, r2, #32
 80a36fe:	fa00 fc02 	lsl.w	ip, r0, r2
 80a3702:	ea5f 0031 	movs.w	r0, r1, rrx
 80a3706:	f140 0000 	adc.w	r0, r0, #0
 80a370a:	ea53 034c 	orrs.w	r3, r3, ip, lsl #1
 80a370e:	bf08      	it	eq
 80a3710:	ea20 70dc 	biceq.w	r0, r0, ip, lsr #31
 80a3714:	4770      	bx	lr
 80a3716:	f092 0f00 	teq	r2, #0
 80a371a:	f000 4c00 	and.w	ip, r0, #2147483648	; 0x80000000
 80a371e:	bf02      	ittt	eq
 80a3720:	0040      	lsleq	r0, r0, #1
 80a3722:	f410 0f00 	tsteq.w	r0, #8388608	; 0x800000
 80a3726:	3a01      	subeq	r2, #1
 80a3728:	d0f9      	beq.n	80a371e <__aeabi_fmul+0xce>
 80a372a:	ea40 000c 	orr.w	r0, r0, ip
 80a372e:	f093 0f00 	teq	r3, #0
 80a3732:	f001 4c00 	and.w	ip, r1, #2147483648	; 0x80000000
 80a3736:	bf02      	ittt	eq
 80a3738:	0049      	lsleq	r1, r1, #1
 80a373a:	f411 0f00 	tsteq.w	r1, #8388608	; 0x800000
 80a373e:	3b01      	subeq	r3, #1
 80a3740:	d0f9      	beq.n	80a3736 <__aeabi_fmul+0xe6>
 80a3742:	ea41 010c 	orr.w	r1, r1, ip
 80a3746:	e78f      	b.n	80a3668 <__aeabi_fmul+0x18>
 80a3748:	ea0c 53d1 	and.w	r3, ip, r1, lsr #23
 80a374c:	ea92 0f0c 	teq	r2, ip
 80a3750:	bf18      	it	ne
 80a3752:	ea93 0f0c 	teqne	r3, ip
 80a3756:	d00a      	beq.n	80a376e <__aeabi_fmul+0x11e>
 80a3758:	f030 4c00 	bics.w	ip, r0, #2147483648	; 0x80000000
 80a375c:	bf18      	it	ne
 80a375e:	f031 4c00 	bicsne.w	ip, r1, #2147483648	; 0x80000000
 80a3762:	d1d8      	bne.n	80a3716 <__aeabi_fmul+0xc6>
 80a3764:	ea80 0001 	eor.w	r0, r0, r1
 80a3768:	f000 4000 	and.w	r0, r0, #2147483648	; 0x80000000
 80a376c:	4770      	bx	lr
 80a376e:	f090 0f00 	teq	r0, #0
 80a3772:	bf17      	itett	ne
 80a3774:	f090 4f00 	teqne	r0, #2147483648	; 0x80000000
 80a3778:	4608      	moveq	r0, r1
 80a377a:	f091 0f00 	teqne	r1, #0
 80a377e:	f091 4f00 	teqne	r1, #2147483648	; 0x80000000
 80a3782:	d014      	beq.n	80a37ae <__aeabi_fmul+0x15e>
 80a3784:	ea92 0f0c 	teq	r2, ip
 80a3788:	d101      	bne.n	80a378e <__aeabi_fmul+0x13e>
 80a378a:	0242      	lsls	r2, r0, #9
 80a378c:	d10f      	bne.n	80a37ae <__aeabi_fmul+0x15e>
 80a378e:	ea93 0f0c 	teq	r3, ip
 80a3792:	d103      	bne.n	80a379c <__aeabi_fmul+0x14c>
 80a3794:	024b      	lsls	r3, r1, #9
 80a3796:	bf18      	it	ne
 80a3798:	4608      	movne	r0, r1
 80a379a:	d108      	bne.n	80a37ae <__aeabi_fmul+0x15e>
 80a379c:	ea80 0001 	eor.w	r0, r0, r1
 80a37a0:	f000 4000 	and.w	r0, r0, #2147483648	; 0x80000000
 80a37a4:	f040 40fe 	orr.w	r0, r0, #2130706432	; 0x7f000000
 80a37a8:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 80a37ac:	4770      	bx	lr
 80a37ae:	f040 40fe 	orr.w	r0, r0, #2130706432	; 0x7f000000
 80a37b2:	f440 0040 	orr.w	r0, r0, #12582912	; 0xc00000
 80a37b6:	4770      	bx	lr

080a37b8 <__aeabi_fdiv>:
 80a37b8:	f04f 0cff 	mov.w	ip, #255	; 0xff
 80a37bc:	ea1c 52d0 	ands.w	r2, ip, r0, lsr #23
 80a37c0:	bf1e      	ittt	ne
 80a37c2:	ea1c 53d1 	andsne.w	r3, ip, r1, lsr #23
 80a37c6:	ea92 0f0c 	teqne	r2, ip
 80a37ca:	ea93 0f0c 	teqne	r3, ip
 80a37ce:	d069      	beq.n	80a38a4 <__aeabi_fdiv+0xec>
 80a37d0:	eba2 0203 	sub.w	r2, r2, r3
 80a37d4:	ea80 0c01 	eor.w	ip, r0, r1
 80a37d8:	0249      	lsls	r1, r1, #9
 80a37da:	ea4f 2040 	mov.w	r0, r0, lsl #9
 80a37de:	d037      	beq.n	80a3850 <__aeabi_fdiv+0x98>
 80a37e0:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
 80a37e4:	ea43 1111 	orr.w	r1, r3, r1, lsr #4
 80a37e8:	ea43 1310 	orr.w	r3, r3, r0, lsr #4
 80a37ec:	f00c 4000 	and.w	r0, ip, #2147483648	; 0x80000000
 80a37f0:	428b      	cmp	r3, r1
 80a37f2:	bf38      	it	cc
 80a37f4:	005b      	lslcc	r3, r3, #1
 80a37f6:	f142 027d 	adc.w	r2, r2, #125	; 0x7d
 80a37fa:	f44f 0c00 	mov.w	ip, #8388608	; 0x800000
 80a37fe:	428b      	cmp	r3, r1
 80a3800:	bf24      	itt	cs
 80a3802:	1a5b      	subcs	r3, r3, r1
 80a3804:	ea40 000c 	orrcs.w	r0, r0, ip
 80a3808:	ebb3 0f51 	cmp.w	r3, r1, lsr #1
 80a380c:	bf24      	itt	cs
 80a380e:	eba3 0351 	subcs.w	r3, r3, r1, lsr #1
 80a3812:	ea40 005c 	orrcs.w	r0, r0, ip, lsr #1
 80a3816:	ebb3 0f91 	cmp.w	r3, r1, lsr #2
 80a381a:	bf24      	itt	cs
 80a381c:	eba3 0391 	subcs.w	r3, r3, r1, lsr #2
 80a3820:	ea40 009c 	orrcs.w	r0, r0, ip, lsr #2
 80a3824:	ebb3 0fd1 	cmp.w	r3, r1, lsr #3
 80a3828:	bf24      	itt	cs
 80a382a:	eba3 03d1 	subcs.w	r3, r3, r1, lsr #3
 80a382e:	ea40 00dc 	orrcs.w	r0, r0, ip, lsr #3
 80a3832:	011b      	lsls	r3, r3, #4
 80a3834:	bf18      	it	ne
 80a3836:	ea5f 1c1c 	movsne.w	ip, ip, lsr #4
 80a383a:	d1e0      	bne.n	80a37fe <__aeabi_fdiv+0x46>
 80a383c:	2afd      	cmp	r2, #253	; 0xfd
 80a383e:	f63f af50 	bhi.w	80a36e2 <__aeabi_fmul+0x92>
 80a3842:	428b      	cmp	r3, r1
 80a3844:	eb40 50c2 	adc.w	r0, r0, r2, lsl #23
 80a3848:	bf08      	it	eq
 80a384a:	f020 0001 	biceq.w	r0, r0, #1
 80a384e:	4770      	bx	lr
 80a3850:	f00c 4c00 	and.w	ip, ip, #2147483648	; 0x80000000
 80a3854:	ea4c 2050 	orr.w	r0, ip, r0, lsr #9
 80a3858:	327f      	adds	r2, #127	; 0x7f
 80a385a:	bfc2      	ittt	gt
 80a385c:	f1d2 03ff 	rsbsgt	r3, r2, #255	; 0xff
 80a3860:	ea40 50c2 	orrgt.w	r0, r0, r2, lsl #23
 80a3864:	4770      	bxgt	lr
 80a3866:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 80a386a:	f04f 0300 	mov.w	r3, #0
 80a386e:	3a01      	subs	r2, #1
 80a3870:	e737      	b.n	80a36e2 <__aeabi_fmul+0x92>
 80a3872:	f092 0f00 	teq	r2, #0
 80a3876:	f000 4c00 	and.w	ip, r0, #2147483648	; 0x80000000
 80a387a:	bf02      	ittt	eq
 80a387c:	0040      	lsleq	r0, r0, #1
 80a387e:	f410 0f00 	tsteq.w	r0, #8388608	; 0x800000
 80a3882:	3a01      	subeq	r2, #1
 80a3884:	d0f9      	beq.n	80a387a <__aeabi_fdiv+0xc2>
 80a3886:	ea40 000c 	orr.w	r0, r0, ip
 80a388a:	f093 0f00 	teq	r3, #0
 80a388e:	f001 4c00 	and.w	ip, r1, #2147483648	; 0x80000000
 80a3892:	bf02      	ittt	eq
 80a3894:	0049      	lsleq	r1, r1, #1
 80a3896:	f411 0f00 	tsteq.w	r1, #8388608	; 0x800000
 80a389a:	3b01      	subeq	r3, #1
 80a389c:	d0f9      	beq.n	80a3892 <__aeabi_fdiv+0xda>
 80a389e:	ea41 010c 	orr.w	r1, r1, ip
 80a38a2:	e795      	b.n	80a37d0 <__aeabi_fdiv+0x18>
 80a38a4:	ea0c 53d1 	and.w	r3, ip, r1, lsr #23
 80a38a8:	ea92 0f0c 	teq	r2, ip
 80a38ac:	d108      	bne.n	80a38c0 <__aeabi_fdiv+0x108>
 80a38ae:	0242      	lsls	r2, r0, #9
 80a38b0:	f47f af7d 	bne.w	80a37ae <__aeabi_fmul+0x15e>
 80a38b4:	ea93 0f0c 	teq	r3, ip
 80a38b8:	f47f af70 	bne.w	80a379c <__aeabi_fmul+0x14c>
 80a38bc:	4608      	mov	r0, r1
 80a38be:	e776      	b.n	80a37ae <__aeabi_fmul+0x15e>
 80a38c0:	ea93 0f0c 	teq	r3, ip
 80a38c4:	d104      	bne.n	80a38d0 <__aeabi_fdiv+0x118>
 80a38c6:	024b      	lsls	r3, r1, #9
 80a38c8:	f43f af4c 	beq.w	80a3764 <__aeabi_fmul+0x114>
 80a38cc:	4608      	mov	r0, r1
 80a38ce:	e76e      	b.n	80a37ae <__aeabi_fmul+0x15e>
 80a38d0:	f030 4c00 	bics.w	ip, r0, #2147483648	; 0x80000000
 80a38d4:	bf18      	it	ne
 80a38d6:	f031 4c00 	bicsne.w	ip, r1, #2147483648	; 0x80000000
 80a38da:	d1ca      	bne.n	80a3872 <__aeabi_fdiv+0xba>
 80a38dc:	f030 4200 	bics.w	r2, r0, #2147483648	; 0x80000000
 80a38e0:	f47f af5c 	bne.w	80a379c <__aeabi_fmul+0x14c>
 80a38e4:	f031 4300 	bics.w	r3, r1, #2147483648	; 0x80000000
 80a38e8:	f47f af3c 	bne.w	80a3764 <__aeabi_fmul+0x114>
 80a38ec:	e75f      	b.n	80a37ae <__aeabi_fmul+0x15e>
 80a38ee:	bf00      	nop

080a38f0 <__gesf2>:
 80a38f0:	f04f 3cff 	mov.w	ip, #4294967295	; 0xffffffff
 80a38f4:	e006      	b.n	80a3904 <__cmpsf2+0x4>
 80a38f6:	bf00      	nop

080a38f8 <__lesf2>:
 80a38f8:	f04f 0c01 	mov.w	ip, #1
 80a38fc:	e002      	b.n	80a3904 <__cmpsf2+0x4>
 80a38fe:	bf00      	nop

080a3900 <__cmpsf2>:
 80a3900:	f04f 0c01 	mov.w	ip, #1
 80a3904:	f84d cd04 	str.w	ip, [sp, #-4]!
 80a3908:	ea4f 0240 	mov.w	r2, r0, lsl #1
 80a390c:	ea4f 0341 	mov.w	r3, r1, lsl #1
 80a3910:	ea7f 6c22 	mvns.w	ip, r2, asr #24
 80a3914:	bf18      	it	ne
 80a3916:	ea7f 6c23 	mvnsne.w	ip, r3, asr #24
 80a391a:	d011      	beq.n	80a3940 <__cmpsf2+0x40>
 80a391c:	b001      	add	sp, #4
 80a391e:	ea52 0c53 	orrs.w	ip, r2, r3, lsr #1
 80a3922:	bf18      	it	ne
 80a3924:	ea90 0f01 	teqne	r0, r1
 80a3928:	bf58      	it	pl
 80a392a:	ebb2 0003 	subspl.w	r0, r2, r3
 80a392e:	bf88      	it	hi
 80a3930:	17c8      	asrhi	r0, r1, #31
 80a3932:	bf38      	it	cc
 80a3934:	ea6f 70e1 	mvncc.w	r0, r1, asr #31
 80a3938:	bf18      	it	ne
 80a393a:	f040 0001 	orrne.w	r0, r0, #1
 80a393e:	4770      	bx	lr
 80a3940:	ea7f 6c22 	mvns.w	ip, r2, asr #24
 80a3944:	d102      	bne.n	80a394c <__cmpsf2+0x4c>
 80a3946:	ea5f 2c40 	movs.w	ip, r0, lsl #9
 80a394a:	d105      	bne.n	80a3958 <__cmpsf2+0x58>
 80a394c:	ea7f 6c23 	mvns.w	ip, r3, asr #24
 80a3950:	d1e4      	bne.n	80a391c <__cmpsf2+0x1c>
 80a3952:	ea5f 2c41 	movs.w	ip, r1, lsl #9
 80a3956:	d0e1      	beq.n	80a391c <__cmpsf2+0x1c>
 80a3958:	f85d 0b04 	ldr.w	r0, [sp], #4
 80a395c:	4770      	bx	lr
 80a395e:	bf00      	nop

080a3960 <__aeabi_cfrcmple>:
 80a3960:	4684      	mov	ip, r0
 80a3962:	4608      	mov	r0, r1
 80a3964:	4661      	mov	r1, ip
 80a3966:	e7ff      	b.n	80a3968 <__aeabi_cfcmpeq>

080a3968 <__aeabi_cfcmpeq>:
 80a3968:	b50f      	push	{r0, r1, r2, r3, lr}
 80a396a:	f7ff ffc9 	bl	80a3900 <__cmpsf2>
 80a396e:	2800      	cmp	r0, #0
 80a3970:	bf48      	it	mi
 80a3972:	f110 0f00 	cmnmi.w	r0, #0
 80a3976:	bd0f      	pop	{r0, r1, r2, r3, pc}

080a3978 <__aeabi_fcmpeq>:
 80a3978:	f84d ed08 	str.w	lr, [sp, #-8]!
 80a397c:	f7ff fff4 	bl	80a3968 <__aeabi_cfcmpeq>
 80a3980:	bf0c      	ite	eq
 80a3982:	2001      	moveq	r0, #1
 80a3984:	2000      	movne	r0, #0
 80a3986:	f85d fb08 	ldr.w	pc, [sp], #8
 80a398a:	bf00      	nop

080a398c <__aeabi_fcmplt>:
 80a398c:	f84d ed08 	str.w	lr, [sp, #-8]!
 80a3990:	f7ff ffea 	bl	80a3968 <__aeabi_cfcmpeq>
 80a3994:	bf34      	ite	cc
 80a3996:	2001      	movcc	r0, #1
 80a3998:	2000      	movcs	r0, #0
 80a399a:	f85d fb08 	ldr.w	pc, [sp], #8
 80a399e:	bf00      	nop

080a39a0 <__aeabi_fcmple>:
 80a39a0:	f84d ed08 	str.w	lr, [sp, #-8]!
 80a39a4:	f7ff ffe0 	bl	80a3968 <__aeabi_cfcmpeq>
 80a39a8:	bf94      	ite	ls
 80a39aa:	2001      	movls	r0, #1
 80a39ac:	2000      	movhi	r0, #0
 80a39ae:	f85d fb08 	ldr.w	pc, [sp], #8
 80a39b2:	bf00      	nop

080a39b4 <__aeabi_fcmpge>:
 80a39b4:	f84d ed08 	str.w	lr, [sp, #-8]!
 80a39b8:	f7ff ffd2 	bl	80a3960 <__aeabi_cfrcmple>
 80a39bc:	bf94      	ite	ls
 80a39be:	2001      	movls	r0, #1
 80a39c0:	2000      	movhi	r0, #0
 80a39c2:	f85d fb08 	ldr.w	pc, [sp], #8
 80a39c6:	bf00      	nop

080a39c8 <__aeabi_fcmpgt>:
 80a39c8:	f84d ed08 	str.w	lr, [sp, #-8]!
 80a39cc:	f7ff ffc8 	bl	80a3960 <__aeabi_cfrcmple>
 80a39d0:	bf34      	ite	cc
 80a39d2:	2001      	movcc	r0, #1
 80a39d4:	2000      	movcs	r0, #0
 80a39d6:	f85d fb08 	ldr.w	pc, [sp], #8
 80a39da:	bf00      	nop

080a39dc <__aeabi_f2iz>:
 80a39dc:	ea4f 0240 	mov.w	r2, r0, lsl #1
 80a39e0:	f1b2 4ffe 	cmp.w	r2, #2130706432	; 0x7f000000
 80a39e4:	d30f      	bcc.n	80a3a06 <__aeabi_f2iz+0x2a>
 80a39e6:	f04f 039e 	mov.w	r3, #158	; 0x9e
 80a39ea:	ebb3 6212 	subs.w	r2, r3, r2, lsr #24
 80a39ee:	d90d      	bls.n	80a3a0c <__aeabi_f2iz+0x30>
 80a39f0:	ea4f 2300 	mov.w	r3, r0, lsl #8
 80a39f4:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 80a39f8:	f010 4f00 	tst.w	r0, #2147483648	; 0x80000000
 80a39fc:	fa23 f002 	lsr.w	r0, r3, r2
 80a3a00:	bf18      	it	ne
 80a3a02:	4240      	negne	r0, r0
 80a3a04:	4770      	bx	lr
 80a3a06:	f04f 0000 	mov.w	r0, #0
 80a3a0a:	4770      	bx	lr
 80a3a0c:	f112 0f61 	cmn.w	r2, #97	; 0x61
 80a3a10:	d101      	bne.n	80a3a16 <__aeabi_f2iz+0x3a>
 80a3a12:	0242      	lsls	r2, r0, #9
 80a3a14:	d105      	bne.n	80a3a22 <__aeabi_f2iz+0x46>
 80a3a16:	f010 4000 	ands.w	r0, r0, #2147483648	; 0x80000000
 80a3a1a:	bf08      	it	eq
 80a3a1c:	f06f 4000 	mvneq.w	r0, #2147483648	; 0x80000000
 80a3a20:	4770      	bx	lr
 80a3a22:	f04f 0000 	mov.w	r0, #0
 80a3a26:	4770      	bx	lr

080a3a28 <atoi>:
 80a3a28:	220a      	movs	r2, #10
 80a3a2a:	2100      	movs	r1, #0
 80a3a2c:	f000 b9a4 	b.w	80a3d78 <strtol>

080a3a30 <atol>:
 80a3a30:	220a      	movs	r2, #10
 80a3a32:	2100      	movs	r1, #0
 80a3a34:	f000 b9a0 	b.w	80a3d78 <strtol>

080a3a38 <__cxa_atexit>:
 80a3a38:	b510      	push	{r4, lr}
 80a3a3a:	4c05      	ldr	r4, [pc, #20]	; (80a3a50 <__cxa_atexit+0x18>)
 80a3a3c:	4613      	mov	r3, r2
 80a3a3e:	b12c      	cbz	r4, 80a3a4c <__cxa_atexit+0x14>
 80a3a40:	460a      	mov	r2, r1
 80a3a42:	4601      	mov	r1, r0
 80a3a44:	2002      	movs	r0, #2
 80a3a46:	f3af 8000 	nop.w
 80a3a4a:	bd10      	pop	{r4, pc}
 80a3a4c:	4620      	mov	r0, r4
 80a3a4e:	bd10      	pop	{r4, pc}
 80a3a50:	00000000 	.word	0x00000000

080a3a54 <memcpy>:
 80a3a54:	b510      	push	{r4, lr}
 80a3a56:	1e43      	subs	r3, r0, #1
 80a3a58:	440a      	add	r2, r1
 80a3a5a:	4291      	cmp	r1, r2
 80a3a5c:	d004      	beq.n	80a3a68 <memcpy+0x14>
 80a3a5e:	f811 4b01 	ldrb.w	r4, [r1], #1
 80a3a62:	f803 4f01 	strb.w	r4, [r3, #1]!
 80a3a66:	e7f8      	b.n	80a3a5a <memcpy+0x6>
 80a3a68:	bd10      	pop	{r4, pc}

080a3a6a <memset>:
 80a3a6a:	4603      	mov	r3, r0
 80a3a6c:	4402      	add	r2, r0
 80a3a6e:	4293      	cmp	r3, r2
 80a3a70:	d002      	beq.n	80a3a78 <memset+0xe>
 80a3a72:	f803 1b01 	strb.w	r1, [r3], #1
 80a3a76:	e7fa      	b.n	80a3a6e <memset+0x4>
 80a3a78:	4770      	bx	lr
	...

080a3a7c <srand>:
 80a3a7c:	b538      	push	{r3, r4, r5, lr}
 80a3a7e:	4b12      	ldr	r3, [pc, #72]	; (80a3ac8 <srand+0x4c>)
 80a3a80:	4605      	mov	r5, r0
 80a3a82:	681c      	ldr	r4, [r3, #0]
 80a3a84:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 80a3a86:	b9d3      	cbnz	r3, 80a3abe <srand+0x42>
 80a3a88:	2018      	movs	r0, #24
 80a3a8a:	f7fe fd6d 	bl	80a2568 <malloc>
 80a3a8e:	f243 330e 	movw	r3, #13070	; 0x330e
 80a3a92:	63a0      	str	r0, [r4, #56]	; 0x38
 80a3a94:	8003      	strh	r3, [r0, #0]
 80a3a96:	f64a 33cd 	movw	r3, #43981	; 0xabcd
 80a3a9a:	8043      	strh	r3, [r0, #2]
 80a3a9c:	f241 2334 	movw	r3, #4660	; 0x1234
 80a3aa0:	8083      	strh	r3, [r0, #4]
 80a3aa2:	f24e 636d 	movw	r3, #58989	; 0xe66d
 80a3aa6:	80c3      	strh	r3, [r0, #6]
 80a3aa8:	f64d 63ec 	movw	r3, #57068	; 0xdeec
 80a3aac:	8103      	strh	r3, [r0, #8]
 80a3aae:	2305      	movs	r3, #5
 80a3ab0:	8143      	strh	r3, [r0, #10]
 80a3ab2:	230b      	movs	r3, #11
 80a3ab4:	8183      	strh	r3, [r0, #12]
 80a3ab6:	2201      	movs	r2, #1
 80a3ab8:	2300      	movs	r3, #0
 80a3aba:	e9c0 2304 	strd	r2, r3, [r0, #16]
 80a3abe:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 80a3ac0:	2200      	movs	r2, #0
 80a3ac2:	611d      	str	r5, [r3, #16]
 80a3ac4:	615a      	str	r2, [r3, #20]
 80a3ac6:	bd38      	pop	{r3, r4, r5, pc}
 80a3ac8:	200003a8 	.word	0x200003a8

080a3acc <rand>:
 80a3acc:	4b19      	ldr	r3, [pc, #100]	; (80a3b34 <rand+0x68>)
 80a3ace:	b510      	push	{r4, lr}
 80a3ad0:	681c      	ldr	r4, [r3, #0]
 80a3ad2:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 80a3ad4:	b9d3      	cbnz	r3, 80a3b0c <rand+0x40>
 80a3ad6:	2018      	movs	r0, #24
 80a3ad8:	f7fe fd46 	bl	80a2568 <malloc>
 80a3adc:	f243 330e 	movw	r3, #13070	; 0x330e
 80a3ae0:	63a0      	str	r0, [r4, #56]	; 0x38
 80a3ae2:	8003      	strh	r3, [r0, #0]
 80a3ae4:	f64a 33cd 	movw	r3, #43981	; 0xabcd
 80a3ae8:	8043      	strh	r3, [r0, #2]
 80a3aea:	f241 2334 	movw	r3, #4660	; 0x1234
 80a3aee:	8083      	strh	r3, [r0, #4]
 80a3af0:	f24e 636d 	movw	r3, #58989	; 0xe66d
 80a3af4:	80c3      	strh	r3, [r0, #6]
 80a3af6:	f64d 63ec 	movw	r3, #57068	; 0xdeec
 80a3afa:	8103      	strh	r3, [r0, #8]
 80a3afc:	2305      	movs	r3, #5
 80a3afe:	8143      	strh	r3, [r0, #10]
 80a3b00:	230b      	movs	r3, #11
 80a3b02:	8183      	strh	r3, [r0, #12]
 80a3b04:	2201      	movs	r2, #1
 80a3b06:	2300      	movs	r3, #0
 80a3b08:	e9c0 2304 	strd	r2, r3, [r0, #16]
 80a3b0c:	6ba1      	ldr	r1, [r4, #56]	; 0x38
 80a3b0e:	4c0a      	ldr	r4, [pc, #40]	; (80a3b38 <rand+0x6c>)
 80a3b10:	690b      	ldr	r3, [r1, #16]
 80a3b12:	6948      	ldr	r0, [r1, #20]
 80a3b14:	435c      	muls	r4, r3
 80a3b16:	4a09      	ldr	r2, [pc, #36]	; (80a3b3c <rand+0x70>)
 80a3b18:	fb02 4000 	mla	r0, r2, r0, r4
 80a3b1c:	fba3 2302 	umull	r2, r3, r3, r2
 80a3b20:	3201      	adds	r2, #1
 80a3b22:	4403      	add	r3, r0
 80a3b24:	f143 0300 	adc.w	r3, r3, #0
 80a3b28:	e9c1 2304 	strd	r2, r3, [r1, #16]
 80a3b2c:	f023 4000 	bic.w	r0, r3, #2147483648	; 0x80000000
 80a3b30:	bd10      	pop	{r4, pc}
 80a3b32:	bf00      	nop
 80a3b34:	200003a8 	.word	0x200003a8
 80a3b38:	5851f42d 	.word	0x5851f42d
 80a3b3c:	4c957f2d 	.word	0x4c957f2d

080a3b40 <strcpy>:
 80a3b40:	4603      	mov	r3, r0
 80a3b42:	f811 2b01 	ldrb.w	r2, [r1], #1
 80a3b46:	f803 2b01 	strb.w	r2, [r3], #1
 80a3b4a:	2a00      	cmp	r2, #0
 80a3b4c:	d1f9      	bne.n	80a3b42 <strcpy+0x2>
 80a3b4e:	4770      	bx	lr

080a3b50 <strlen>:
 80a3b50:	4603      	mov	r3, r0
 80a3b52:	f813 2b01 	ldrb.w	r2, [r3], #1
 80a3b56:	2a00      	cmp	r2, #0
 80a3b58:	d1fb      	bne.n	80a3b52 <strlen+0x2>
 80a3b5a:	1a18      	subs	r0, r3, r0
 80a3b5c:	3801      	subs	r0, #1
 80a3b5e:	4770      	bx	lr

080a3b60 <strncmp>:
 80a3b60:	b530      	push	{r4, r5, lr}
 80a3b62:	b182      	cbz	r2, 80a3b86 <strncmp+0x26>
 80a3b64:	1e45      	subs	r5, r0, #1
 80a3b66:	3901      	subs	r1, #1
 80a3b68:	f815 3f01 	ldrb.w	r3, [r5, #1]!
 80a3b6c:	f811 4f01 	ldrb.w	r4, [r1, #1]!
 80a3b70:	42a3      	cmp	r3, r4
 80a3b72:	d106      	bne.n	80a3b82 <strncmp+0x22>
 80a3b74:	43ec      	mvns	r4, r5
 80a3b76:	4414      	add	r4, r2
 80a3b78:	42e0      	cmn	r0, r4
 80a3b7a:	d001      	beq.n	80a3b80 <strncmp+0x20>
 80a3b7c:	2b00      	cmp	r3, #0
 80a3b7e:	d1f3      	bne.n	80a3b68 <strncmp+0x8>
 80a3b80:	461c      	mov	r4, r3
 80a3b82:	1b18      	subs	r0, r3, r4
 80a3b84:	bd30      	pop	{r4, r5, pc}
 80a3b86:	4610      	mov	r0, r2
 80a3b88:	bd30      	pop	{r4, r5, pc}

080a3b8a <strncpy>:
 80a3b8a:	4603      	mov	r3, r0
 80a3b8c:	b510      	push	{r4, lr}
 80a3b8e:	b142      	cbz	r2, 80a3ba2 <strncpy+0x18>
 80a3b90:	f811 4b01 	ldrb.w	r4, [r1], #1
 80a3b94:	3a01      	subs	r2, #1
 80a3b96:	f803 4b01 	strb.w	r4, [r3], #1
 80a3b9a:	2c00      	cmp	r4, #0
 80a3b9c:	d1f7      	bne.n	80a3b8e <strncpy+0x4>
 80a3b9e:	441a      	add	r2, r3
 80a3ba0:	e000      	b.n	80a3ba4 <strncpy+0x1a>
 80a3ba2:	bd10      	pop	{r4, pc}
 80a3ba4:	4293      	cmp	r3, r2
 80a3ba6:	d002      	beq.n	80a3bae <strncpy+0x24>
 80a3ba8:	f803 4b01 	strb.w	r4, [r3], #1
 80a3bac:	e7fa      	b.n	80a3ba4 <strncpy+0x1a>
 80a3bae:	bd10      	pop	{r4, pc}

080a3bb0 <strtok>:
 80a3bb0:	4b17      	ldr	r3, [pc, #92]	; (80a3c10 <strtok+0x60>)
 80a3bb2:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80a3bb6:	681d      	ldr	r5, [r3, #0]
 80a3bb8:	4606      	mov	r6, r0
 80a3bba:	6dac      	ldr	r4, [r5, #88]	; 0x58
 80a3bbc:	460f      	mov	r7, r1
 80a3bbe:	b9fc      	cbnz	r4, 80a3c00 <strtok+0x50>
 80a3bc0:	2050      	movs	r0, #80	; 0x50
 80a3bc2:	f7fe fcd1 	bl	80a2568 <malloc>
 80a3bc6:	65a8      	str	r0, [r5, #88]	; 0x58
 80a3bc8:	6084      	str	r4, [r0, #8]
 80a3bca:	6dab      	ldr	r3, [r5, #88]	; 0x58
 80a3bcc:	6004      	str	r4, [r0, #0]
 80a3bce:	6044      	str	r4, [r0, #4]
 80a3bd0:	611c      	str	r4, [r3, #16]
 80a3bd2:	60dc      	str	r4, [r3, #12]
 80a3bd4:	6dab      	ldr	r3, [r5, #88]	; 0x58
 80a3bd6:	619c      	str	r4, [r3, #24]
 80a3bd8:	615c      	str	r4, [r3, #20]
 80a3bda:	6dab      	ldr	r3, [r5, #88]	; 0x58
 80a3bdc:	62dc      	str	r4, [r3, #44]	; 0x2c
 80a3bde:	629c      	str	r4, [r3, #40]	; 0x28
 80a3be0:	6dab      	ldr	r3, [r5, #88]	; 0x58
 80a3be2:	635c      	str	r4, [r3, #52]	; 0x34
 80a3be4:	631c      	str	r4, [r3, #48]	; 0x30
 80a3be6:	6dab      	ldr	r3, [r5, #88]	; 0x58
 80a3be8:	63dc      	str	r4, [r3, #60]	; 0x3c
 80a3bea:	639c      	str	r4, [r3, #56]	; 0x38
 80a3bec:	6dab      	ldr	r3, [r5, #88]	; 0x58
 80a3bee:	645c      	str	r4, [r3, #68]	; 0x44
 80a3bf0:	641c      	str	r4, [r3, #64]	; 0x40
 80a3bf2:	6dab      	ldr	r3, [r5, #88]	; 0x58
 80a3bf4:	64dc      	str	r4, [r3, #76]	; 0x4c
 80a3bf6:	649c      	str	r4, [r3, #72]	; 0x48
 80a3bf8:	6dab      	ldr	r3, [r5, #88]	; 0x58
 80a3bfa:	771c      	strb	r4, [r3, #28]
 80a3bfc:	6dab      	ldr	r3, [r5, #88]	; 0x58
 80a3bfe:	625c      	str	r4, [r3, #36]	; 0x24
 80a3c00:	6daa      	ldr	r2, [r5, #88]	; 0x58
 80a3c02:	4639      	mov	r1, r7
 80a3c04:	4630      	mov	r0, r6
 80a3c06:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 80a3c0a:	2301      	movs	r3, #1
 80a3c0c:	f000 b802 	b.w	80a3c14 <__strtok_r>
 80a3c10:	200003a8 	.word	0x200003a8

080a3c14 <__strtok_r>:
 80a3c14:	b5f0      	push	{r4, r5, r6, r7, lr}
 80a3c16:	b948      	cbnz	r0, 80a3c2c <__strtok_r+0x18>
 80a3c18:	6810      	ldr	r0, [r2, #0]
 80a3c1a:	b938      	cbnz	r0, 80a3c2c <__strtok_r+0x18>
 80a3c1c:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80a3c1e:	f817 6b01 	ldrb.w	r6, [r7], #1
 80a3c22:	b15e      	cbz	r6, 80a3c3c <__strtok_r+0x28>
 80a3c24:	42b5      	cmp	r5, r6
 80a3c26:	d1fa      	bne.n	80a3c1e <__strtok_r+0xa>
 80a3c28:	b12b      	cbz	r3, 80a3c36 <__strtok_r+0x22>
 80a3c2a:	4620      	mov	r0, r4
 80a3c2c:	4604      	mov	r4, r0
 80a3c2e:	460f      	mov	r7, r1
 80a3c30:	f814 5b01 	ldrb.w	r5, [r4], #1
 80a3c34:	e7f3      	b.n	80a3c1e <__strtok_r+0xa>
 80a3c36:	6014      	str	r4, [r2, #0]
 80a3c38:	7003      	strb	r3, [r0, #0]
 80a3c3a:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80a3c3c:	b94d      	cbnz	r5, 80a3c52 <__strtok_r+0x3e>
 80a3c3e:	6015      	str	r5, [r2, #0]
 80a3c40:	4628      	mov	r0, r5
 80a3c42:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80a3c44:	f817 6b01 	ldrb.w	r6, [r7], #1
 80a3c48:	42b5      	cmp	r5, r6
 80a3c4a:	d007      	beq.n	80a3c5c <__strtok_r+0x48>
 80a3c4c:	2e00      	cmp	r6, #0
 80a3c4e:	d1f9      	bne.n	80a3c44 <__strtok_r+0x30>
 80a3c50:	461c      	mov	r4, r3
 80a3c52:	4623      	mov	r3, r4
 80a3c54:	460f      	mov	r7, r1
 80a3c56:	f813 5b01 	ldrb.w	r5, [r3], #1
 80a3c5a:	e7f3      	b.n	80a3c44 <__strtok_r+0x30>
 80a3c5c:	b115      	cbz	r5, 80a3c64 <__strtok_r+0x50>
 80a3c5e:	2100      	movs	r1, #0
 80a3c60:	7021      	strb	r1, [r4, #0]
 80a3c62:	e000      	b.n	80a3c66 <__strtok_r+0x52>
 80a3c64:	462b      	mov	r3, r5
 80a3c66:	6013      	str	r3, [r2, #0]
 80a3c68:	bdf0      	pop	{r4, r5, r6, r7, pc}
	...

080a3c6c <_strtol_r>:
 80a3c6c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 80a3c70:	460f      	mov	r7, r1
 80a3c72:	4680      	mov	r8, r0
 80a3c74:	483f      	ldr	r0, [pc, #252]	; (80a3d74 <_strtol_r+0x108>)
 80a3c76:	f8d0 9000 	ldr.w	r9, [r0]
 80a3c7a:	463d      	mov	r5, r7
 80a3c7c:	f815 4b01 	ldrb.w	r4, [r5], #1
 80a3c80:	eb09 0004 	add.w	r0, r9, r4
 80a3c84:	7840      	ldrb	r0, [r0, #1]
 80a3c86:	f000 0008 	and.w	r0, r0, #8
 80a3c8a:	f000 06ff 	and.w	r6, r0, #255	; 0xff
 80a3c8e:	b108      	cbz	r0, 80a3c94 <_strtol_r+0x28>
 80a3c90:	462f      	mov	r7, r5
 80a3c92:	e7f2      	b.n	80a3c7a <_strtol_r+0xe>
 80a3c94:	2c2d      	cmp	r4, #45	; 0x2d
 80a3c96:	d103      	bne.n	80a3ca0 <_strtol_r+0x34>
 80a3c98:	1cbd      	adds	r5, r7, #2
 80a3c9a:	787c      	ldrb	r4, [r7, #1]
 80a3c9c:	2601      	movs	r6, #1
 80a3c9e:	e003      	b.n	80a3ca8 <_strtol_r+0x3c>
 80a3ca0:	2c2b      	cmp	r4, #43	; 0x2b
 80a3ca2:	bf04      	itt	eq
 80a3ca4:	787c      	ldrbeq	r4, [r7, #1]
 80a3ca6:	1cbd      	addeq	r5, r7, #2
 80a3ca8:	b113      	cbz	r3, 80a3cb0 <_strtol_r+0x44>
 80a3caa:	2b10      	cmp	r3, #16
 80a3cac:	d10a      	bne.n	80a3cc4 <_strtol_r+0x58>
 80a3cae:	e05b      	b.n	80a3d68 <_strtol_r+0xfc>
 80a3cb0:	2c30      	cmp	r4, #48	; 0x30
 80a3cb2:	d157      	bne.n	80a3d64 <_strtol_r+0xf8>
 80a3cb4:	7828      	ldrb	r0, [r5, #0]
 80a3cb6:	f000 00df 	and.w	r0, r0, #223	; 0xdf
 80a3cba:	2858      	cmp	r0, #88	; 0x58
 80a3cbc:	d14d      	bne.n	80a3d5a <_strtol_r+0xee>
 80a3cbe:	786c      	ldrb	r4, [r5, #1]
 80a3cc0:	2310      	movs	r3, #16
 80a3cc2:	3502      	adds	r5, #2
 80a3cc4:	2e00      	cmp	r6, #0
 80a3cc6:	bf14      	ite	ne
 80a3cc8:	f04f 4c00 	movne.w	ip, #2147483648	; 0x80000000
 80a3ccc:	f06f 4c00 	mvneq.w	ip, #2147483648	; 0x80000000
 80a3cd0:	fbbc faf3 	udiv	sl, ip, r3
 80a3cd4:	2700      	movs	r7, #0
 80a3cd6:	4638      	mov	r0, r7
 80a3cd8:	fb03 cc1a 	mls	ip, r3, sl, ip
 80a3cdc:	eb09 0e04 	add.w	lr, r9, r4
 80a3ce0:	f89e e001 	ldrb.w	lr, [lr, #1]
 80a3ce4:	f01e 0f04 	tst.w	lr, #4
 80a3ce8:	d001      	beq.n	80a3cee <_strtol_r+0x82>
 80a3cea:	3c30      	subs	r4, #48	; 0x30
 80a3cec:	e00b      	b.n	80a3d06 <_strtol_r+0x9a>
 80a3cee:	f01e 0e03 	ands.w	lr, lr, #3
 80a3cf2:	d01b      	beq.n	80a3d2c <_strtol_r+0xc0>
 80a3cf4:	f1be 0f01 	cmp.w	lr, #1
 80a3cf8:	bf0c      	ite	eq
 80a3cfa:	f04f 0e37 	moveq.w	lr, #55	; 0x37
 80a3cfe:	f04f 0e57 	movne.w	lr, #87	; 0x57
 80a3d02:	ebce 0404 	rsb	r4, lr, r4
 80a3d06:	42a3      	cmp	r3, r4
 80a3d08:	dd10      	ble.n	80a3d2c <_strtol_r+0xc0>
 80a3d0a:	f1b7 3fff 	cmp.w	r7, #4294967295	; 0xffffffff
 80a3d0e:	d00a      	beq.n	80a3d26 <_strtol_r+0xba>
 80a3d10:	4550      	cmp	r0, sl
 80a3d12:	d806      	bhi.n	80a3d22 <_strtol_r+0xb6>
 80a3d14:	d101      	bne.n	80a3d1a <_strtol_r+0xae>
 80a3d16:	4564      	cmp	r4, ip
 80a3d18:	dc03      	bgt.n	80a3d22 <_strtol_r+0xb6>
 80a3d1a:	fb03 4000 	mla	r0, r3, r0, r4
 80a3d1e:	2701      	movs	r7, #1
 80a3d20:	e001      	b.n	80a3d26 <_strtol_r+0xba>
 80a3d22:	f04f 37ff 	mov.w	r7, #4294967295	; 0xffffffff
 80a3d26:	f815 4b01 	ldrb.w	r4, [r5], #1
 80a3d2a:	e7d7      	b.n	80a3cdc <_strtol_r+0x70>
 80a3d2c:	1c7b      	adds	r3, r7, #1
 80a3d2e:	d10c      	bne.n	80a3d4a <_strtol_r+0xde>
 80a3d30:	2e00      	cmp	r6, #0
 80a3d32:	f04f 0322 	mov.w	r3, #34	; 0x22
 80a3d36:	bf14      	ite	ne
 80a3d38:	f04f 4000 	movne.w	r0, #2147483648	; 0x80000000
 80a3d3c:	f06f 4000 	mvneq.w	r0, #2147483648	; 0x80000000
 80a3d40:	f8c8 3000 	str.w	r3, [r8]
 80a3d44:	b92a      	cbnz	r2, 80a3d52 <_strtol_r+0xe6>
 80a3d46:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80a3d4a:	b106      	cbz	r6, 80a3d4e <_strtol_r+0xe2>
 80a3d4c:	4240      	negs	r0, r0
 80a3d4e:	b172      	cbz	r2, 80a3d6e <_strtol_r+0x102>
 80a3d50:	b107      	cbz	r7, 80a3d54 <_strtol_r+0xe8>
 80a3d52:	1e69      	subs	r1, r5, #1
 80a3d54:	6011      	str	r1, [r2, #0]
 80a3d56:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80a3d5a:	2430      	movs	r4, #48	; 0x30
 80a3d5c:	2b00      	cmp	r3, #0
 80a3d5e:	d1b1      	bne.n	80a3cc4 <_strtol_r+0x58>
 80a3d60:	2308      	movs	r3, #8
 80a3d62:	e7af      	b.n	80a3cc4 <_strtol_r+0x58>
 80a3d64:	230a      	movs	r3, #10
 80a3d66:	e7ad      	b.n	80a3cc4 <_strtol_r+0x58>
 80a3d68:	2c30      	cmp	r4, #48	; 0x30
 80a3d6a:	d0a3      	beq.n	80a3cb4 <_strtol_r+0x48>
 80a3d6c:	e7aa      	b.n	80a3cc4 <_strtol_r+0x58>
 80a3d6e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80a3d72:	bf00      	nop
 80a3d74:	20000344 	.word	0x20000344

080a3d78 <strtol>:
 80a3d78:	4613      	mov	r3, r2
 80a3d7a:	460a      	mov	r2, r1
 80a3d7c:	4601      	mov	r1, r0
 80a3d7e:	4802      	ldr	r0, [pc, #8]	; (80a3d88 <strtol+0x10>)
 80a3d80:	6800      	ldr	r0, [r0, #0]
 80a3d82:	f7ff bf73 	b.w	80a3c6c <_strtol_r>
 80a3d86:	bf00      	nop
 80a3d88:	200003a8 	.word	0x200003a8

080a3d8c <dynalib_user>:
 80a3d8c:	080a001d 080a005d 080a0089 080a008d     ....]...........
 80a3d9c:	00000000                                ....

080a3da0 <_ZTVN9NSFastLED7WS2812BILh15ELNS_6EOrderE66EEE>:
	...
 80a3da8:	080a18df 080a187d 080a0189 080a015d     ....}.......]...

080a3db8 <_ZZN9NSFastLEDL7sin16_CEtE5slope>:
 80a3db8:	262c3031 040e171f                       10,&....

080a3dc0 <_ZL19brightnessLevelsArr>:
 80a3dc0:	00000000 00000030 00000080 000000ff     ....0...........

080a3dd0 <Sunset_Real_gp>:
 80a3dd0:	00007800 0016b316 0068ff33 1216a755     .x......3.h.U...
 80a3de0:	67006487 820010c6 a00000ff 20746553     .d.g........Set 
 80a3df0:	67697262 656e7468 74207373 5300206f     brightness to .S
 80a3e00:	7065656c 74655300 74615020 6e726574     leep.Set Pattern
 80a3e10:	206f7420 70002c00 003a7277 3a747262      to .,.pwr:.brt:
 80a3e20:	003a6700 63003a62 7a74003a 6c66003a     .g:.b:.c:.tz:.fl
 80a3e30:	6b6c6370 6548003a 206f6c6c 454c202d     pclk:.Hello - LE
 80a3e40:	6f632044 6f72746e 72656c6c 74617000     D controller.pat
 80a3e50:	6e726574 65646e49 61760078 62616972     ternIndex.variab
 80a3e60:	7000656c 7265776f 69726200 6e746867     le.power.brightn
 80a3e70:	00737365 00620067 656d6974 656e6f7a     ess.g.b.timezone
 80a3e80:	696c6600 6f6c4370 22006b63 70005d00     .flipClock.".].p
 80a3e90:	65747461 614e6e72 0073656d 6e696152     atternNames.Rain
 80a3ea0:	00776f62 6e696152 20776f62 68746957     bow.Rainbow With
 80a3eb0:	696c4720 72657474 6e695300 6e6f6c65      Glitter.Sinelon
 80a3ec0:	61654200 754a0074 656c6767 74654d00     .Beat.Juggle.Met
 80a3ed0:	20726f65 776f6853 4a007265 6c676775     eor Shower.Juggl
 80a3ee0:	00322065 65726946 74615700 00007265     e 2.Fire.Water..

080a3ef0 <_ZZN9NSFastLEDL7sin16_CEtE4base>:
 80a3ef0:	18f90000 471c30fb 6a6d5a82 7d897641     .....0.G.ZmjAv.}

080a3f00 <_ZN9NSFastLEDL16b_m16_interleaveE>:
 80a3f00:	29313100 0a751b5a                       .11)Z.u.

080a3f08 <_ZN9NSFastLED12LavaColors_pE>:
 80a3f08:	00000000 00800000 00000000 00800000     ................
 80a3f18:	008b0000 00800000 008b0000 008b0000     ................
 80a3f28:	008b0000 00ff0000 00ffa500 00ffffff     ................
 80a3f38:	00ffa500 00ff0000 008b0000 00000000     ................

080a3f48 <_ZN9NSFastLED15RainbowColors_pE>:
 80a3f48:	00ff0000 00d52a00 00ab5500 00ab7f00     .....*...U......
 80a3f58:	00abab00 0056d500 0000ff00 0000d52a     ......V.....*...
 80a3f68:	0000ab55 000056aa 000000ff 002a00d5     U....V........*.
 80a3f78:	005500ab 007f0081 00ab0055 00d5002b     ..U.....U...+...

080a3f88 <_ZN9NSFastLED13PartyColors_pE>:
 80a3f88:	005500ab 0084007c 00b5004b 00e5001b     ..U.|...K.......
 80a3f98:	00e81700 00b84700 00ab7700 00abab00     .....G...w......
 80a3fa8:	00ab5500 00dd2200 00f2000e 00c2003e     .U..."......>...
 80a3fb8:	008f0071 005f00a1 002f00d0 000007f9     q....._.../.....

080a3fc8 <_ZN9NSFastLED13CloudColors_pE>:
 80a3fc8:	000000ff 0000008b 0000008b 0000008b     ................
 80a3fd8:	0000008b 0000008b 0000008b 0000008b     ................
 80a3fe8:	000000ff 0000008b 0087ceeb 0087ceeb     ................
 80a3ff8:	00add8e6 00ffffff 00add8e6 0087ceeb     ................

080a4008 <_ZN9NSFastLED12HeatColors_pE>:
 80a4008:	00000000 00330000 00660000 00990000     ......3...f.....
 80a4018:	00cc0000 00ff0000 00ff3300 00ff6600     .........3...f..
 80a4028:	00ff9900 00ffcc00 00ffff00 00ffff33     ............3...
 80a4038:	00ffff66 00ffff99 00ffffcc 00ffffff     f...............

080a4048 <_ZN9NSFastLED14ForestColors_pE>:
 80a4048:	00006400 00006400 00556b2f 00006400     .d...d../kU..d..
 80a4058:	00008000 00228b22 006b8e23 00008000     ....".".#.k.....
 80a4068:	002e8b57 0066cdaa 0032cd32 009acd32     W.....f.2.2.2...
 80a4078:	0090ee90 007cfc00 0066cdaa 00228b22     ......|...f.".".

080a4088 <_ZN9NSFastLED21RainbowStripeColors_pE>:
 80a4088:	00ff0000 00000000 00ab5500 00000000     .........U......
 80a4098:	00abab00 00000000 0000ff00 00000000     ................
 80a40a8:	0000ab55 00000000 000000ff 00000000     U...............
 80a40b8:	005500ab 00000000 00ab0055 00000000     ..U.....U.......

080a40c8 <_ZN9NSFastLED13OceanColors_pE>:
 80a40c8:	00191970 0000008b 00191970 00000080     p.......p.......
 80a40d8:	0000008b 000000cd 002e8b57 00008080     ........W.......
 80a40e8:	005f9ea0 000000ff 00008b8b 006495ed     .._...........d.
 80a40f8:	007fffd4 002e8b57 0000ffff 0087cefa     ....W...........

080a4108 <_ZTV7TwoWire>:
	...
 80a4110:	080a260b 080a2655 080a262d 080a260d     .&..U&..-&...&..
 80a4120:	080a2635 080a263d 080a2645 080a264d     5&..=&..E&..M&..

080a4130 <_ZTV9IPAddress>:
	...
 80a4138:	080a269b 080a268d 080a268f 6e6c0066     .&...&...&..f.ln
 80a4148:	006e6600 65646f63 74656400 006c6961     .fn.code.detail.
 80a4158:	25000a0d 75303130 205d0020 00642500     ...%010u .] .%d.
 80a4168:	2800202c 00203a29 63005b20 2065646f     , .(): . [.code 
 80a4178:	2500203d 65640069 6c696174 203d2073     = .%i.details = 
 80a4188:	75616200 65530064 6c616972 42535500     .baud.Serial.USB
 80a4198:	69726553 00316c61 65707974 72617000     Serial1.type.par
 80a41a8:	63006d61 6900646d 6e680064 74730064     am.cmd.id.hnd.st
 80a41b8:	66006d72 00746c69 006c766c 48646461     rm.filt.lvl.addH
 80a41c8:	6c646e61 72007265 766f6d65 6e614865     andler.removeHan
 80a41d8:	72656c64 756e6500 6e61486d 72656c64     dler.enumHandler
 80a41e8:	534a0073 74534e4f 6d616572 48676f4c     s.JSONStreamLogH
 80a41f8:	6c646e61 61007265 6e007070 00656e6f     andler.app.none.
 80a4208:	63617274 6e690065 77006f66 006e7261     trace.info.warn.
 80a4218:	6f727265 61700072 0063696e 006c6c61     error.panic.all.

080a4228 <_ZTV8SPIClass>:
	...
 80a4230:	080a2825 080a2827 2b25005a 3a643330     %(..'(..Z.%+03d:
 80a4240:	75323025 2d592500 252d6d25 48255464     %02u.%Y-%m-%dT%H
 80a4250:	3a4d253a 7a255325 63736100 656d6974     :%M:%S%z.asctime
 80a4260:	00000000                                ....

080a4264 <_ZTV11USARTSerial>:
	...
 80a426c:	080a2be1 080a2c05 080a2c11 080a2711     .+...,...,...'..
 80a427c:	080a2bed 080a2bf9 080a2bf3 080a2bff     .+...+...+...+..
 80a428c:	080a2be3 080a2be7                       .+...+..

080a4294 <_ZTV9USBSerial>:
	...
 80a429c:	080a2cb9 080a2cfd 080a2cd7 080a2711     .,...,...,...'..
 80a42ac:	080a2cd1 080a2cbb 080a2cc3 080a2cf7     .,...,...,...,..
 80a42bc:	080a2ccb 080a2cb5                       .,...,..

080a42c4 <_ZTVN5spark9WiFiClassE>:
	...
 80a42cc:	080a2e2b                                +...

080a42d0 <_ctype_>:
 80a42d0:	20202000 20202020 28282020 20282828     .         ((((( 
 80a42e0:	20202020 20202020 20202020 20202020                     
 80a42f0:	10108820 10101010 10101010 10101010      ...............
 80a4300:	04040410 04040404 10040404 10101010     ................
 80a4310:	41411010 41414141 01010101 01010101     ..AAAAAA........
 80a4320:	01010101 01010101 01010101 10101010     ................
 80a4330:	42421010 42424242 02020202 02020202     ..BBBBBB........
 80a4340:	02020202 02020202 02020202 10101010     ................
 80a4350:	00000020 00000000 00000000 00000000      ...............
	...

080a43d4 <__sf_fake_stdin>:
	...

080a43f4 <__sf_fake_stdout>:
	...

080a4414 <__sf_fake_stderr>:
	...
 80a4434:	00000043                                         C.

080a4436 <link_const_variable_data_end>:
	...

080a4438 <link_constructors_location>:
 80a4438:	080a1941 	.word	0x080a1941
 80a443c:	080a1d7d 	.word	0x080a1d7d
 80a4440:	080a1d99 	.word	0x080a1d99
 80a4444:	080a20ed 	.word	0x080a20ed
 80a4448:	080a2275 	.word	0x080a2275
 80a444c:	080a2279 	.word	0x080a2279
 80a4450:	080a227d 	.word	0x080a227d
 80a4454:	080a2281 	.word	0x080a2281
 80a4458:	080a2285 	.word	0x080a2285
 80a445c:	080a2701 	.word	0x080a2701
 80a4460:	080a2809 	.word	0x080a2809
 80a4464:	080a2b55 	.word	0x080a2b55
 80a4468:	080a2bcd 	.word	0x080a2bcd
 80a446c:	080a2e35 	.word	0x080a2e35
 80a4470:	080a3125 	.word	0x080a3125
 80a4474:	080a3155 	.word	0x080a3155
 80a4478:	080a31a5 	.word	0x080a31a5
 80a447c:	080a3269 	.word	0x080a3269
 80a4480:	080a32ed 	.word	0x080a32ed
 80a4484:	080a3371 	.word	0x080a3371

080a4488 <link_constructors_end>:
	...
